[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Oijee! Andmeanalüüs",
    "section": "",
    "text": "Saateks\nSellel lehel on esitatud õpik, mida võib käsitleda sissejuhatusena kaasaegsesse kvantitatiivsesse andmeanalüüsi. Nii ei ole siin esitatud kuigi palju traditsioonilist statistikat ega muude kui arvandmete analüüsimist. Andmeteadusele kohaselt on enamuse käsitletavate meetodite eesmärk prognoosimine, mitte nähtuste selgitamine. Rõhuasetus on meetodite praktilisel rakendamisel, mitte nende teoreetilise tausta selgitamisel.\nÕpik on abivahend kursuse Sissejuhatus andmeteadusesse ja -analüüsi jaoks Eesti Maaülikoolis.\nLogol on kujutatud andmeanalüüs DALL-E masinõppe mudeli nägemuses."
  },
  {
    "objectID": "andmeteadus.html#andmed-on-abstraktsioon",
    "href": "andmeteadus.html#andmed-on-abstraktsioon",
    "title": "1  Andmed ja andmeteadus",
    "section": "1.1 Andmed on abstraktsioon",
    "text": "1.1 Andmed on abstraktsioon\nAndmed on teave mingi nähtuse kohta enamasti lihtsustatud kujul. Andmed on tegelikkuse lihtsustus (abstraktsioon), mille aluseks on andmete koguja poolt tehtud otsused ja valikud. Seetõttu ei ole andmed kunagi objektiivsed, vaid alati kallutatud ja erapoolikud (Kelleher & Tierney, 2018). See erapoolikus sõltub sellest, mille alusel ja kuidas mingit nähtust on mõõdetud (operatsionaliseeritud). Andmete kallutatust saab esitada täpsuse ja usaldusväärsuse alusel.\nTäpsus (validity) kirjeldab andmete õigsust või kehtivust. Täpselt mõõdetud andmed näitavad täpselt seda, mida soovime, ega ole kallutatud1. Nii sõltub andmete täpsus eelkõige sellest, mis üldist nähtust mõõdetakse.1 Nt korruptsiooni mõõdetakse selle alusel, mil määral inimesed seda tajuvad. See ei ole täpne, sest ei näita tegelikku korruptsiooni.\nUsaldusväärsus (reliability) kirjeldab andmete hajuvust. Usaldusväärselt mõõdetud andmed annavad igal kordusmõõtmisel sama tulemuse. Kui füüsikaliste mõõtmiste korral sõltub usaldusväärsus ka mõõtmisvahendist, siis sotsiaalteadustes on see seotud eelkõige mõõdetavate nähtuste ja mõõtmise ajaga2. Usaldusväärsus oleneb mõõtmise viisist ja sellest, keda või mida konkreetselt mõõdetakse.2 Nt mõõtes suhtumist toidu ohutusse, siis ei saa me teha usaldusväärseid üldistusi, kui uurime uudistega rohkem kursis olevaid isikuid ja küsitleme ajal, kui meedias kajastatakse palju mõnda toidumürgituse juhtumit.\n\n\n\n\n\n\nWarning\n\n\n\nAndmete täpsust ja usaldusväärsust on oluline silmas pidada andmeanalüüsi tulemuste tõlgendamisel.\n\n\nMingi konkreetse andmekogumi iseloomustamiseks on kaks peamist viisi. Andmeteaduses eristatakse andmeid enamasti praktilises mõttes andmete vormi alusel. Nii võib andmik olla kas\n\nkorrastatud (structured) korrektselt vormistatud andmetabel,\nkorrastamata (unstructured) piltide, dokumentide, videote vms kujul või\npoolkorrastatud (semistructured), kui andmeväljad ei ole esitatud tabelina, aga neid saab üksteisega seostada.\n\nSelleks et andmeid analüüsida on enamasti siiski vajalik need korrastatud andmetabeliks vormistada.\nTeoreetilisemas mõttes eristatakse andmike nende päritolu alusel:\n\nprimaarandmed on kogutud konkreetse analüüsi jaoks,\nsekundaarandmed aga mingil muul eesmärgil.\n\nKui andmed on kogutud konkreetse analüüsi jaoks, siis on need suurema tõenäosusega täpsed ja usaldusväärsed.\nAndmetega seotud toimingud saab kokku võtta nelja A abil (Saltz & Stanton, 2017):\n\narhitektuur (architecture),\nammutamine (acquisition),\nanalüüs (analysis),\narhiveerimine (archiving)."
  },
  {
    "objectID": "andmeteadus.html#andmeteadus-ei-ole-teadus",
    "href": "andmeteadus.html#andmeteadus-ei-ole-teadus",
    "title": "1  Andmed ja andmeteadus",
    "section": "1.2 Andmeteadus ei ole teadus",
    "text": "1.2 Andmeteadus ei ole teadus\nMõistet “andmeteadus” hakati kasutama 1990. aastatel (Kelleher & Tierney, 2018). Väga suurte korrastamata andmike ilmumine ja arvutitehnika areng tähendas, et andmete analüüsimiseks arvutitel tuli kuidagi tuua sisse statistilistele meetoditele omane rangus. Suurte andmike uurimisel arvutitel ei piisanud enam ainult programmeerimise oskusest, vaid vaja oli ka teadmisi andmete ja statistika kohta.\nSeega võibki andmeteaduseks pidada statistiliste ja arvutitel põhinevate tehnikate rakendamist selleks, et saada parem arusaam mingist konkreetsest andmikust. Sealjuures ei pruugi need andmikud olla tavapärased andmetabelid, vaid on sageli korrastamata andmed. Kuna igasuguses vormis andmeid on võimalik teisendada numbriteks, saavad andmeteadustes kasutatavad protseduurid hakkama ka mahukate korrastamata andmikega 3. Otsitav arusaam nende andmete kohta võib seisneda nt mustrite, klastrite või erindite tuvastamises. Kuna andmeteaduses ühendatakse matemaatilised tehnikad ja klassikalised statistilised meetodid nende rakendamisega arvutitel, siis võib andmeteadustes kasutatavaid protseduure nimetada algoritmideks.3 Korrastamata suurandmed on nt veebilehtede külastatavus, sotsiaalmeedia postitused, erinevate sensorite poolt kogutud teave.\nNeed algoritmid käsitlevad osa andmetest sisenditena ja teist osa väljunditena. Nende kahe vaheliste seoste alusel tuvastavad algoritmid (varjatud) mustreid, mida sageli klassikaliste statistiliste meetoditega ei ole võimalik leida. Praktilistes andmeteaduse rakendustes on nende algoritmide lõppeesmärk siiski prognoosida sisendite alusel kõige sobivam väljund selliste andmeväljade kohta, mille puhul see väljund teada ei ole 4.4 Algoritmide abil saame prognoosida nt laenusaajate tõenäosuse laen tagasi maksta (väljund) teades nende sotsiaal-majanduslikke näitajaid (sisendid).\n\n\n\n\n\n\nImportant\n\n\n\nAndmeteadus on statistiliste ja arvutitel põhinevate tehnikate rakendamine andmikest mustrite tuvastamiseks ja nende alusel prognooside tegemiseks.\n\n\nEnamus katseid andmeteadust mõtestada teevad seda mitme nähtuse kaudu (Kelleher & Tierney, 2018; Pinheiro et al., 2021; Spiegelhalter, 2019; Taddy, 2019): klassikaline statistika, algoritmid, suurandmed, masinõpe, andmekaeve, andmehaldus ja andmebaasid, erialateadmised, andmete kasutamise eetika. Väga laias mõttes võibki andmeteaduseks pidada kõike, mis on mingilgi viisil andmetega seotud. Nii on kirjeldatud andmeteadust ka tegevuste kaudu, hõlmates andmekogumist, andmete haldamist ja korrastamist, analüüsimist ja tõlgendamist (Çetinkaya-Rundel & Ellison, 2021; Kelleher & Tierney, 2018). Selline väga lai lähenemine võib olla ka põhjuseks, miks arvatakse, et andmeteadus on ületähtsustatud (Taddy, 2019): mõistet on kasutatud viitamaks ka tegevustele, mis tegelikult ei hõlma andmeteadust. On tavapärane, et ennast andmeteadlaseks nimetavatel inimestel puudub vastav hariduslik ettevalmistus ja teadustöö kogemus.\nNii võib väita, et suur osa sellest, mida nimetatatakse andmeteaduseks on pigem andmeanalüüs ja sellega tegelevad inimesed mitte teadlased, vaid analüütikud. Ka mõiste “andmeteadus” kasutusele võtmisel ei olnud rõhuasetus teadustööl5. Seega kui peame teaduseks uue teadmise loomist tavapärase teadustöö mõistes, siis ei ole andmeteaduse rakendamine iseenesest teadus ega teaduslik, vaid pigem praktiline andmeanalüüs arvutitel.5 Mõiste esimesi kasutusi põhjendati nii: “Data Science is likely the remaining good name reserved for us” (Wu, 1997)."
  },
  {
    "objectID": "andmeteadus.html#andmeteadus-või-statistika",
    "href": "andmeteadus.html#andmeteadus-või-statistika",
    "title": "1  Andmed ja andmeteadus",
    "section": "1.3 Andmeteadus või statistika?",
    "text": "1.3 Andmeteadus või statistika?\nAndmete analüüsimisel võivad olla väga erinevad eesmärgid, sageli isegi mitu korraga. Selleks võib olla mõne nähtuse kirjeldamine, üldistamine, prognoosimine või juhtimine (description, inference, prediction, prescription). Traditsiooniliselt on klassikalise statistika arenguloos olnud peamine tähelepanu sellel, kuidas kõige täpsemini teha mingi valimi alusel üldistusi kogumi kohta. Arengud andmeteaduses ja eelkõige masinõppes on olnud samas aga suunatud sellele, kuidas kõige täpsemini mingit tulemust prognoosida, jättes kõrvale üldistamise ja kõik muud kaalutlused.\nNii on andmeteaduses sageli rakendava masinõppe korral mudel enamasti nö must kast, mille alusel ei ole võimalik tuvastada, kuidas mingi konkreetse prognoosini jõuti. Enamuse statistika meetodite puhul on selle mudeli tõlgendamine aga just peamine eesmärk. Seega, kui andmeteadustes on rõhuasetus suurima võimaliku prognoosi täpsuse saavutamisel, siis statistikas on oluline koostada täpne ja püsiv mudel, mis rahuldaks kõik teoreetilised eeldused ja pakuks seeläbi kõige mõistlikuma selgituse tunnuste vahelistele seostele. Nii põhineb suur enamus teadustööst statistika meetoditel, samas kui praktilisemates rakendustes (nt tehnoloogias ja ärinduses) vajatakse pigem andmeteaduse poolt pakutavaid prognoose.\n\n\n\n\n\n\nImportant\n\n\n\nStatistilisi meetodeid kasutatakse enamasti tunnuste vaheliste seoste selgitamiseks ja selle käigus ka valimi alusel kogumi kohta üldistuste tegemiseks. Andmeteadustes rakendatava masinõppe eesmärk on aga eelkõige võimalikult täpsete prognooside tegemine.\n\n\nKui statistilisi meetodeid kasutades on enamasti oluline teha valimi alusel järeldusi kogumi kohta, siis andmeteadustes ei pöörata kogumile tähelepanu ja sageli eeldatakse vaikimisi, et olemas olev valim on kogumi suhtes esinduslik. Seetõttu keskendub statistika andmete kirjeldamisele teoreetilistele jaotuste kaudu, samas kui andmeteadustes kasutatakse üldistuste tegemiseks taasvalikut (resampling). See on siiski pigem üldistus ja tegelikkuses kasutatakse mõlemas lähenemises parameetrilisi ja mitteparameetrilisi meetodeid.\nKuna aga statistikas oletatakse, et andmed järgivad mingisugust teoreetilist jaotust, siis igasuguste punkthinnangute leidmise käigus arvutatakse ka selle oodatav hajuvus, vähemalt üldistamise korral. Kuigi andmeteadustes kasutatava masinõppe rakendamisel on prognoosi täpsus oluline, siis selle prognoosi hajuvus nt usaldusvahemike kontekstis enamasti mitte6. Erinevale lähenemisele ebakindlusele tulemuse suhtes viitab ka see, kuidas arvutuste tulemust nimetatakse: statistikas räägitakse võimalikest hinnangutest (estimate), andmeteadustes aga lihtsalt mõõtmise tulemusest (metric). Ehk statistikas keskendutakse palju tulemuse ebakindluse hindamisele, samas kui andmeteadustes ainult tulemusele endale.6 Nt kogumisse kuuluvate ettevõtete keskmise käibe hindamisel valimi alusel on statistikas oluline esitada, millisesse vahemikku see jääb, samas kui masinõppes oleks oluline ainult keskmine ise\nPraktilisemas mõttes rakendatakse nende kahe lähenemise puhul ka erinevaid meetodeid erinevatel andmetel. Isegi suur osa kaasajal kasutatavast statistikast kujunes ajal, kui andmikud olid väikesed ja arvutusi tehti enamasti käsitsi paberil. Seega statistilised arvutused pidid olema käsitsi lahendamiseks piisavalt lihtsad, mistõttu vastavad meetodid põhinesid suurel määral matemaatikateoorial ja paljudel eeldustel andmete jaotuse kohta. Andmeteadus seevastu on arenenud aga koos suurandmete leviku ja arvutite võimsuse kasvuga. Nii hõlmavad paljud andmeteaduste rakendused suurandmeid (sh reaalajas tekkivaid andmeid), mis vajavad suurt arvutusvõimsust ja vähem teoreetilisi eeldusi. Kui lihtsustada, siis võib öelda, et statistika põhineb matemaatikal, andmeteadus aga arvutamisel.\n\nLihtsustatud statistika ja andmeteaduse (masinõppe) võrdlus. Tegelikkuses esineb kahes veerus palju kattuvusi.\n\n\n\n\n\n\n\n\nStatistika\nAndmeteadus (masinõpe)\n\n\n\n\nEesmärk\nÜldistamine\nPrognoosimine\n\n\nEbakindluse hindamine\nTeoreetilised jaotused\nTaasvalik\n\n\nEbakindlus\nHinnangu osa\nEbaoluline\n\n\nAndmed\nKorrastatud väikese või keskmise suurusega\nKorrastamata suurandmed\n\n\nMeetodid\nMatemaatikal põhinevad ja traditsioonilised\nArvutamisel põhinevad ja hiljutised\n\n\n\n\n\n\n\n\nÇetinkaya-Rundel, M., & Ellison, V. (2021). A Fresh Look at Introductory Data Science. Journal of Statistics and Data Science Education, 29(sup1), S16–S26. https://doi.org/10.1080/10691898.2020.1804497\n\n\nKelleher, J. D., & Tierney, B. (2018). Data science. The MIT Press.\n\n\nPinheiro, C., Patetta, M., & Safari, an O. M. C. (2021). Introduction to Statistical and Machine Learning Methods for Data Science. SAS Institute Inc.\n\n\nSaltz, J. S., & Stanton, J. M. (2017). An introduction to data science. SAGE Publications, Inc.\n\n\nSpiegelhalter, D. J. (2019). The art of statistics: learning from data. Pelican Books.\n\n\nTaddy, M. (2019). Business data science: combining machine learning and economics to optimize, automate, and accelerate business decisions (First edition). McGraw-Hill Education.\n\n\nWu, J. (1997). Statistics = data science? http://www2. isye. gatech. edu/~ jeffwu/presentations/datascience.pdf"
  },
  {
    "objectID": "mlaibd.html#masinõpe-ei-ole-veel-päris-tehisintellekt",
    "href": "mlaibd.html#masinõpe-ei-ole-veel-päris-tehisintellekt",
    "title": "2  Masinõpe ja suurandmed",
    "section": "2.1 Masinõpe ei ole veel päris tehisintellekt",
    "text": "2.1 Masinõpe ei ole veel päris tehisintellekt\nMasinõpe on andmeteadustes kasutatav üldine tehnika, mida rakendatakse konkreetsetel algoritmidel või mudelitel selleks, et saavutada nende võimalikult suur täpsus prognoosimisel. Selleks üritatakse masinõppe käigus leida sobivaimad parameetrid. Nii põhineb masinõpe algoritmi või mudeli arendamisel: masinõppe käigus võetakse aluseks olemasolevad sisendite ja väljundite paarid, et arendada algoritmide võimekust leida sobiv väljund sellistele juhtudele, kus teada on ainult sisendi väärtus1. Mudelite ja algoritmide arendamisel võrreldakse nende erinevaid võimalikke parameetreid erinevate andmike kontekstis, seega seisneb masinõppe tööpõhimõte erinevate parameetrite ja andmete kombinatsioonide võrdlemises.1 Nt kui mudeli sisendiks on pildid võimalike vähkkasvajatega ja väljundiks vähkkasvaja tegelik tuvastamine, siis masinõppe käigus saab arendada mudeli, mis määrab pildi järgi võimalikult täpselt vähkkasvaja olemasolu ka juhul, kui see veel teada ei ole\n\n\n\n\n\n\nImportant\n\n\n\nMasinõpe põhineb mudeli või algoritmi rakendamisel erinevate parameetritega ja andmiku erinevatel osadel selleks, et leida selline mudel või algoritm, mis võimalikult täpselt prognoosiks.\n\n\nSageli arvatakse, et masinõpe on üks tehisintellekti (artificial intelligence) rakendusi, sest see on võimeline lahendama ülesandeid ilma inimese sekkumiseta (Pinheiro et al., 2021). Selline arusaam on mõneti mõistetav, kui mõtestame tehisintellekti nii, et see hõlmab arvutusi selliste ülesannete lahendamiseks, millega tavapäraselt saavad hakkama ainult inimesed (Spiegelhalter, 2019). Õppimine masinõppes viitab justkui selle oskusele leida andmetest iseseisvalt mustreid ja nende alusel otsuseid (prognoose) teha. Samas on masinõpe piiratud mustrite leidmisega ainult olemasolevatest andmetest ega suuda arvesse võtta väljaspool neid olevaid tegureid ega “mängureegleid” (Taddy, 2019). Selleks on vajalik abstraktne teoreetiline mõtlemine ja arusaam sellest, kuidas maailm üldiselt toimib. Nii ei ole tehisintellekt otsuste tegemisel võimeline arvesse võtma ka eetikat ega ühiskondlikke norme. Ehk masinõppe abil saab lahendada ainult üksikuid väga konkreetseid ülesandeid, aga see ei asenda veel inimesi."
  },
  {
    "objectID": "mlaibd.html#andmeteadus-võimaldab-rakendada-suurandmeid",
    "href": "mlaibd.html#andmeteadus-võimaldab-rakendada-suurandmeid",
    "title": "2  Masinõpe ja suurandmed",
    "section": "2.2 Andmeteadus võimaldab rakendada suurandmeid",
    "text": "2.2 Andmeteadus võimaldab rakendada suurandmeid\nSuurandmed on sellised andmed, mis on suured. Tegelikult on suurandmetel veel palju eripärasid, mis tulenevalt eelkõige nende automatiseeritud loomisest. Tavapäraselt selgitatakse suurandmete olemust nn kolme V alusel:\n\nandmete suur maht (volume),\nandmete loomise suur kiirus (velocity) ja\nandmete suur mitmekesisus (variety).\n\n\n\n\n\n\n\nImportant\n\n\n\nSuurandmeid iseloomustab nende suur maht, loomise kiirus ja mitmekesisus.\n\n\nLisaks nendele kolmele on kirjanduses suurandmetele veel mitmeid omadusi omistatud (Kitchin & McArdle, 2016):\n\nkõikehõlmavus ja esinduslikkus,\npeenekoelisus ja eripärasus,\nühendatavus teiste andmikega,\nvõimalus kiiresti andmevälju lisada,\nkorrastamatus ja müra,\nsuur (rahaline) väärtus,\nmitmetähenduslikkus.\n\nSiiski on leitud, et isegi kolme V-d esindavad omadused ei iseloomusta sugugi kõiki suurandmeid ja üldiselt saab suurandmeid kirjeldada pigem erinevate kombinatsioonide kaudu eelpool nimetatud omadustest (Kitchin & McArdle, 2016). Need omadused võimaldavad aga eristada suurandmeid nö tavapärastest korrastatud tabelitena esitatud andmetest.\nKlassikalised statistilised meetodid ei ole enamasti sobilikud suurandmete analüüsimiseks. Kuna suur osa statistikast seisneb valimi alusel üldistuste tegemises, siis vastavad meetodid ei ole lihtsalt asjakohased, kui andmed esindavad tervet kogumit ja eesmärk on prognoosimine. Sealjuures ilmnevad ka tehnilised puudujäägid. Statistikas laialt levinud statistiline hüpoteeside testimine on tundlik suurte valimite suhtes ja viitab sellistel juhtudel alati statistiliselt olulisele erinevusele. Samuti hõlmavad paljud meetodid vabadusastmete arvu, mida ei saa kasutada, kui tunnuseid on rohkem kui vaatlusi. Andmeteaduses levinud meetoditel selliseid piiranguid enamasti ei ole.\nSuurandmed ilmusid seoses teabe digitaliseerimisega, mis võimaldas andmeid lihtsamini koguda ja odavamalt hoiustada, ning suurandmete analüüsimise võimaluste tekkimisega, mille aluseks oli arvutite riistvaralise võimekuse ja vastavate tarkvaraliste võimaluste areng. Need arengud võimaldasid samal ajal ka andmeteaduste kui eriala ilmumist, mida toetas lisaks ka ühisosa leidmine teadustöös arvutiteaduse, statistika ning sotsiaalteaduste vahel (Taddy, 2019). Ühest küljest tekitas suurandmete olemasolu vajaduse andmeteaduse meetodite järgi, teisalt pakkusid suurandmed võimaluse rakendada meetodeid, mis klassikalise statistika alla ei kuulunud.\n\n\n\n\n\nKitchin, R., & McArdle, G. (2016). What makes Big Data, Big Data? Exploring the ontological characteristics of 26 datasets. Big Data & Society, 3(1), 205395171663113. https://doi.org/10.1177/2053951716631130\n\n\nPinheiro, C., Patetta, M., & Safari, an O. M. C. (2021). Introduction to Statistical and Machine Learning Methods for Data Science. SAS Institute Inc.\n\n\nSpiegelhalter, D. J. (2019). The art of statistics: learning from data. Pelican Books.\n\n\nTaddy, M. (2019). Business data science: combining machine learning and economics to optimize, automate, and accelerate business decisions (First edition). McGraw-Hill Education."
  },
  {
    "objectID": "analüüs.html#analüüsi-käik",
    "href": "analüüs.html#analüüsi-käik",
    "title": "3  Andmete analüüs",
    "section": "3.1 Analüüsi käik",
    "text": "3.1 Analüüsi käik\nAndmeanalüüsi teel soovitud teadmiseni jõudmiseks on vajalik sooritada teatud tegevused teatud järjekorras. Kuigi erinevate autorite poolt esitatud andmeanalüüsi sammud mõnevõrra erinevad (Peng & Matsui, 2016; Pinheiro et al., 2021; Spiegelhalter, 2019), siis saab need kokku võtta järgnevalt:\n\npüstita uurimisküsimus,\nkavanda selle küsimuse lahendamine,\nkogu vajalikud andmed,\nloo arusaam andmetes sisalduvast,\ntee arvutused vastavalt uurimisküsimusele,\ntõlgenda arvutuste tulemusi,\nesita tulemused teksti ja/või joonistena.\n\nÄrinduse valdkonnas kasutatakse mõnikord standardiseeritud CRISP-DM lähenemist, mis määrab tegevused ettevõtte siseste andmete praktiliseks rakendamiseks. Võrreldes eelnevalt kirjeldatud sammudega hõlmab nimetatud lähenemine ka andmete kättesaadavuse hindamist ja pöörab enam tähelepanu mudeli rakendamisele."
  },
  {
    "objectID": "analüüs.html#andmeanalüüsi-põhimõtted",
    "href": "analüüs.html#andmeanalüüsi-põhimõtted",
    "title": "3  Andmete analüüs",
    "section": "3.2 Andmeanalüüsi põhimõtted",
    "text": "3.2 Andmeanalüüsi põhimõtted\nKogemus näitab, et teatud vead kipuvad andmetega tegelemisel korduma ja nii saab esitada teatud põhimõtted, mida selle käigus silmas pidada. Alljärgnevate soovituse hulgas on muuhulgas eeskuju võetud Spiegelhalter (2019) poolt esitatud põhimõtetest.\n\nPea iga tegevuse puhul alati meeles, mis on analüüsi lõppeesmärk. Vastasel juhul on oht jääda pusima mingi tegevuse juures, mis tegelikult ei olegi eriti vajalik.\nAndmeanalüüsis ei saa kõike ette näha, aga siiski tuleb kasuks kõik tegevused ette kavandada. Nt juba andmete kogumistel peaks olema selge, millise meetodi abil neid hiljem uuritakse.\nAndmete analüüsimine ei kulge enamasti sirgjooneliselt algusest lõpuni, vaid enamasti on vaja tegevusi korrata või eelmise tegevuse juurde tagasi minna. Nt kui kogutud andmed ei võimalda vajaliku meetodi rakendamist, siis võib olla vajalik andmeid täiendada.\nVeendu, et andmed on täpsed ja usaldusväärsed või kui ei ole, siis peab see olema arvesse võetav. Sobimatute andmete analüüsimine on maha visatud aeg ja vaev.\nKasuta ainult meetodeid, millest aru saad. Tarkvara kuvab peaaegu alati arvutuse tulemuse, isegi siis kui see on täiesti seosetu.\nEelista alati lihtsust keerukatele arvutustele. Kuigi mõne keerulise meetodi rakendamine võib tunduda peen ja usutav, siis on lihtsate meetodite rakendamisest sageli palju rohkem kasu, sest tulemused on läbipaistvamad ja arusaadavamad.\nÜldistuste tegemisel esita alati punkthinnangute usaldusvahemikud või kasuta üldse ainult vahemikhinnanguid. Kahe rühma mingi tunnuse punkthinnangud võivad olla erinevad, aga kui vastavad vahemikhinnangud kattuvad, siis me ei saa seda erinevust üldistada1.\nNähtuste üldistamisel otsi tasakaalu nihke ja hajuvuse vähendamise vahel. Statistiline mudel peaks olema piisavalt täpne olemasoleva valimi suhtes, aga ka piisavalt ebatäpne, et see kirjeldaks täpselt ka mõnda muud valimit.\nVõimalusel võrdle enda analüüsi tulemusi mingite varasemate tulemustega ja uuri, kas ka teistsugused meetodid annavad sama tulemuse ehk valideeri tulemusi.\nTeosta andmete analüüs nii, et see oleks korratav. Korratavuse võimaldamiseks tuleb analüüs vormistada nii, et kõik tegevused andmetega oleksid tuvastatavad käsulehelt (script).\nOtsi andmetest mustreid. Selleks uuri seoseid erinevate tunnuste vahel, mitte ära keskendu üksikutele tunnustele.\n\n1 Nt kui mingis valimis olevate ettevõtete käive keskmiselt kasvas, aga selle keskmise kasvu usaldusvahemik kattis ka 0, siis on tõenäoline, et üldiselt selliste ettevõtete käive ei muutunudkiEraldi võib välja tuua mõned soovitused, mida pidada meeles andmetest mustrite leidmisel.\n\nUuri, mil viisil muutuvad ühe tunnuse väärtused teise tunnuse väärtuste muutudes.\nAgregeerimise ja summeerimise käigus läheb alati vähemalt osa andmetes olevast infost kaduma.\nAndmete jaotus on enamasti kaldu kas suurte või harvem väikeste väärtuste suhtes ja seega on kallutatud ka mõõdikud, mis on tundlikud erindite suhtes2.\nMustreid on enamasti lihtsam tuvastada joonistelt kui arvutuste tulemustest.\nMõned mustrid ilmnevad ainult juhul, kui uurida tunnuseid teisendatud kujul (transformed). Teisendusi on oluline meeles pidada tulemuste tõlgendamisel.\n\n\n\n\n\n\n2 Nt töötasu jaotus ühiskonnas on kaldu suuremate töötasude poole, mitõttu ka töötasude aritmeetiline keskmine on kaldu suurema väärtuse suunas.\n\nPeng, R., & Matsui, E. (2016). The Art of Data Science. Leanpub.\n\n\nPinheiro, C., Patetta, M., & Safari, an O. M. C. (2021). Introduction to Statistical and Machine Learning Methods for Data Science. SAS Institute Inc.\n\n\nSpiegelhalter, D. J. (2019). The art of statistics: learning from data. Pelican Books."
  },
  {
    "objectID": "tarkvara.html#tabelarvutus",
    "href": "tarkvara.html#tabelarvutus",
    "title": "4  Tarkvara andmetöötluseks",
    "section": "4.1 Tabelarvutus",
    "text": "4.1 Tabelarvutus\nTabelarvutuse rakendused võimaldavad andmete töötlemist ainult kahemõõtmelise tabelina või selliste tabelite kogumikuna. Selliseid tabeleid on mugav hallata ainult siis, kui need on eriti veergude arvu mõttes väiksed. Kuigi paljudel tabelarvutuse rakendustel on olemas ka funktsioonid ja lisad mitmete statistiliste protseduuride teostamiseks, siis on tabelarvutus mugav pigem matemaatiliste tehete rakendamiseks otse lahtritel. Seetõttu on nende rakenduste kasutamine väga lihtsasti õpitav, aga neil puuduvad võimalused paljudeks tegevusteks, mis on vajalikud andmete põhjalikumal analüüsimisel. Siiski on tabelarvutuse rakendused kasulikud andmete sisestamiseks ja lihtsate kokkuvõtete tegemiseks."
  },
  {
    "objectID": "tarkvara.html#statistikarakendused",
    "href": "tarkvara.html#statistikarakendused",
    "title": "4  Tarkvara andmetöötluseks",
    "section": "4.2 Statistikarakendused",
    "text": "4.2 Statistikarakendused\nSarnaselt tabelarvutusele on vähemalt enamusel statistikarakendustel olemas andmetabeli vaade, aga suurem osa andmetöötlusest tehakse tervete ridade või veergude kaupa, mitte iga lahtrit üksikult muutes. Selleks eeldavad statistkarakendused nn korrastatud andmetabelit, milles read esindavad vaatlusi ja veerud tunnuseid. See loogika lihtsustab märkimisväärselt statistiliste protseduuride kasutamist. Erinevalt tabelarvutuse rakendustest kuvatakse arvutuste tulemused mitte otse andmetabelis vaid eraldi vaates. Kuigi statistikarakendused sisaldavad protseduure enamuse klassikalise statistika meetodite rakendamiseks, siis paljudel juhtudel ei võimalda need keerukamaid arvutusi ega korrastamata andmete kasutamist."
  },
  {
    "objectID": "tarkvara.html#programmeerimiskeeled",
    "href": "tarkvara.html#programmeerimiskeeled",
    "title": "4  Tarkvara andmetöötluseks",
    "section": "4.3 Programmeerimiskeeled",
    "text": "4.3 Programmeerimiskeeled\nProgrammeerimiskeelte kasutamine on põhimõtteliselt väga lihtne: objektidel (andmed) rakendatakse funktsioone (tehted). Kogu keerukus seisneb objektide ja funktsioonide tundmises ning nende omavahelises kombineerimises.\nKõige selgemalt eristab programmeerimiskeeli teistest rakendustest graafilise kasutajaliidese puudumine. Seega ei toimu andmete töötlemine mitte menüüdest valikute tegemise teel, vaid kõik tegevused toimuvad käsitsi sisse trükitavate käskude alusel, mida saab sisestada otse käsurealt või käsulehelt. Andmeid saab hoiustada väga mitmesugusel kujul alates üksiktutest väärtustest ja lõpetades mitmemõõtmeliste tabelitega.\nSamuti ei ole käsurea vahendusel andmetega tegeledes andmed pidevalt nähtaval ja seega peab kasutaja väga täpselt meeles pidama, millisel kujul andmed parajasti hoiustatud on. Nt tabelina vormistatud andmete puhul on oluline teada, mida esindavad read ja mida veerud, mis on veergude nimetused ja mis tüüpi tunnusena on andmed veergudes."
  },
  {
    "objectID": "tarkvara.html#r-keel",
    "href": "tarkvara.html#r-keel",
    "title": "4  Tarkvara andmetöötluseks",
    "section": "4.4 R keel",
    "text": "4.4 R keel\nVäga üksikud programmeerimiskeeled on loodud ainult andmete töötlemiseks. Nendest kõige laialdasemalt kasutatav on R keel. Seda võib laiemas mõtes pidada arvutuskeskkonnaks, mis on ette nähtud andmete töötlemiseks, arvutuste tegemiseks ja jooniste kuvamiseks1.1 Põhjalikum R keele kirjeldus on esitatud selle ametlikul leheküljel.\nR keele kasutamiseks tuleb arvutisse laadida ja paigaldada vastav rakendus. Keele kasutamiseks on soovitatav paigaldada arvutisse ka rakendus RStudio Desktop."
  },
  {
    "objectID": "kasutus.html#käsurida",
    "href": "kasutus.html#käsurida",
    "title": "5  Põhikasutus",
    "section": "5.1 Käsurida",
    "text": "5.1 Käsurida\nKäsureal (command line) esitatud käsu alusel teeb R rakendus vastavalt R keele loogikale arvutused ja esitab vastuse. Nii saab käsurida kasutada ka lihtsalt kalkulaatorina ja sealjuures saab korraga teha ka mitu tehet.\n\n13 + 8 # Liitmine\n\n[1] 21\n\n8 - 5 # Lahutamine \n\n[1] 3\n\n21 / 3 # Jagamine \n\n[1] 7\n\n5 * 3 # Korrutamine \n\n[1] 15\n\n2^3 # Astendamine \n\n[1] 8\n\n9^(1/2) # Ruutjuur\n\n[1] 3\n\n13 + (8 - 5) * 9^(1/2)\n\n[1] 22\n\n\nR keele võimekus avaldub aga siis, kui kasutame käske salvestamaks väärtused objektidesse ja rakendamaks neil erinevaid funktsioone.\nMõnikord väljastab R käsu sisestamisel veateate. Teatega “Error” kaasneb käsu täitmata jätmine, samas kui teade “Warning” tähendab, et käsk küll täideti, aga teatud tingimustel."
  },
  {
    "objectID": "kasutus.html#objektid-ja-funktsioonid",
    "href": "kasutus.html#objektid-ja-funktsioonid",
    "title": "5  Põhikasutus",
    "section": "5.2 Objektid ja funktsioonid",
    "text": "5.2 Objektid ja funktsioonid\n\nTo understand computations in R, two slogans are helpful:\nEverything that exists is an object.\nEverything that happens is a function call.\n- John Chambers\n\nAndmete töötlemiseks on vaja need kuidagi salvestada. Väärtusi saab R keeles salvestada objektidena. Sealjuures väärtused, mis ei ole arvud, tuleb ümbritseda jutumärkidega.\n\n# Objekti võib salvestada arve...\nkama &lt;- 2\nkama\n\n[1] 2\n\n# ...aga ka sõnu või lauseid.\npesa &lt;- 'muna'\npesa\n\n[1] \"muna\"\n\n# Trükitav nö nool ei tohi sisaldada tühikuid, \n# sest vastasel juhul käsitletakse käsku võrdlusena.\nkama &lt; - 2\n\n[1] FALSE\n\n\nObjekte võib nimetada kuidas iganes1, aga nimetused peavad algama tähega ega tohi sisaldada teatud kirjavahemärke ega tühikuid.1 Objektidele nime valimine võtab sageli rohkem aega kui peaks: “There are only two hard things in Computer Science: cache invalidation and naming things.”\nVäärtuste klasse on R keeles väga palju, aga olulisimaks võib pidada nendest kolme:\n\nüksik väärtus on element,\n\nmitu väärtust on vektor,\ntabelina vormistatud väärtused on andmetabel (data frame).\n\nVäärtuse klass sõltub sellest, mis kujul me andmed sisestame.\n\n# Element\nkaks &lt;- 3\nkaks\n\n[1] 3\n\n# Vektor\nnimed &lt;- c('Alar', 'Kaja', 'Jüri')\nnimed\n\n[1] \"Alar\" \"Kaja\" \"Jüri\"\n\n# Andmetabel\nõpilased &lt;- data.frame(nimi = nimed, \n                       hinne = c(5,4,2))\nõpilased\n\n  nimi hinne\n1 Alar     5\n2 Kaja     4\n3 Jüri     2\n\n\nNagu näha, siis rohkem kui ühe elemendi esitamiseks peame kasutama vastavat funktsiooni.\nSamuti ilmneb, et funktsiooni nimetuse järele sulgudesse tuleb sisestada funktsiooni argumendid. Esimene argument on enamasti objekt ja järgnevad argumendid täpsustused.\n\nFibonacci &lt;- c(1,NA,2,3,NA)\n# Kuna vektor sisaldab teadmata väärtusi, \n# siis ei väljasta funktsioon vektori summat.\nsum(Fibonacci)\n\n[1] NA\n\n# Saame täpsustada, et soovime summa arvutada ilma puuduvate väärtusteta.\nsum(Fibonacci, na.rm = TRUE)\n\n[1] 6\n\n\nIga funktsiooni kõikide argumentide teada saamiseks saab kuvada vastava funktsiooni abilehe. Selleks tuleb sisestada käsk, milles funktsiooni nimetusele eelneb küsimärk.\n\n?sum\n\n\n\n\n\n\n\nNote\n\n\n\nR keele kasutamine on põhimõtteliselt väga lihtne: see on lihtsalt funktsioonide rakendamine objektidel. Kogu keerukus seisneb objektide ja funktsioonide tundmises ning nende omavahel kombineerimises."
  },
  {
    "objectID": "kasutus.html#laiendused",
    "href": "kasutus.html#laiendused",
    "title": "5  Põhikasutus",
    "section": "5.3 Laiendused",
    "text": "5.3 Laiendused\nR keele paigaldamisel tuleb kaasa palju funktsioone, mis võimaldavad rakendada põhilisi andmetöötluse ja statistilise analüüsi protseduure. Võimaluste lisamiseks on aga paljud R keele kasutajad kirjutanud ise funktsioone ja koondanud need laiendustesse või pakkidesse (packages), mis on saadaval ka teistele kasutajatele2. Selleks, et neid laiendusi kasutada tuleb need esmalt arvutisse paigaldada ja seejärel töölauale laadida.2 Ametlikult tunnustatud R keele laiendused on CRAN hoidlas.\n\n# Laadime laienduse alla ja paigaldame arvutisse.\ninstall.packages('tidyverse')\n# Laienduse kasutamiseks tuleb see esmalt R töölauale laadida.\nlibrary('tidyverse')\n\nEelnevate käskudega paigaldatud ja laaditud laiendus tidyverse sisaldab tegelikult palju teisi laiendusi, mille funktsioonid lihtsustavad käskude kirjutamist R keeles. Edaspidi kasutame paljusid antud laienduses sisalduvaid funktsioone."
  },
  {
    "objectID": "kasutus.html#sisestamine",
    "href": "kasutus.html#sisestamine",
    "title": "5  Põhikasutus",
    "section": "5.4 Sisestamine",
    "text": "5.4 Sisestamine\nMõistagi ei pea andmed R töölauale sisestama üksikute väärtuste kaupa nii nagu eelnevas näites. Lisatavates lainedustes olevate funktsioonide abil on R võimeline lugema andmeid peaaegu misiganes vormingus. Siiski on soovitatav kasutada R keelega kaasas olevaid funktsioone, mis tunnevad eelkõige lihttekstina salvestatud andmeid. Üheks selliseks andmevorminguks on CSV (comma separated value), mis on lihtsalt teksti sisaldav fail, milles väärtused on eraldatud komadega.\nCSV vormingus andmete R töölauale laadimiseks saab kasutada funktsiooni read.csv(), mille argumendiks on andmefaili koht failisüsteemis. Kui andmete esimene rida sisaldab veergude nimetusi, siis tuleb seda argumendiga täpsustada argumendiga header = TRUE.\n\n# Loeme objekti \"thi\" töölaua kaustas olevast failist \"thi.csv\"\n# Need on tarbijahinnaindeksi (THI) andmed Statistikaameti tabeli IA02 alusel\nthi &lt;- read.csv('C:/Users/kasutajanimi/Desktop/thi.csv', header = TRUE)\n\n\n\n\n\n\n\nCaution\n\n\n\nKui salvestada tabel CSV vormingus Microsoft Exceli abil, siis on väärtuse eraldajateks hoopis semikoolonid. Sellisel juhul loeb funktsioon read.csv() andmeid valesti. Lahenduseks on kasutada funktsiooni read.csv2() , mis arvestab väärtuste eraldajatena semikoolonit ja komakohtade eraldajatena komasid.\nCSV aluseks on USA standard, milles arvude komakohad eraldatakse punktiga. Kuna Euroopas eraldatakse arvudes komakohad komaga, siis ei saa komasid kasutada väärtuse eraldamiseks ja Excel eraldab väärtused hoopis semikoolonitega.\n\n\nFaililaiendiga .xlsx nö tabelarvutuse vihikutes ei pruugi andmed olla vormistatud korrektse andmetabelina ja võivad sisaldada tabelist väljaspool olevaid väärtusi. Nt tühjade ridade või veergudega tabelid ilmuvad statistikarakendustesse või R töölauale laadides sageli vigaselt. Selliste vigade kõrvaldamine on enamasti keerulisem võrreldes CSV vormingu kasutamisega. Sellepärast on ka soovitatav kasutada CSV vormingut. Kui on siiski vajadus laadida töölauale .xlsx vormingus olevad andmed, siis selleks saab kasutada funktsiooni read_excel().\n\nthi &lt;- read_excel('C:/Users/kasutajanimi/Desktop/thi.xlsx')\n\n\n\n\n\n\n\nTip\n\n\n\nKui andmed on mingi muu faililaiendiga (nt .xlsx), siis on soovitatav need esmalt CSVna salvestada ja alles seejärel R töölauale laadida.\n\n\nKui soovime kõik loetavad ja salvestatavad failid koondada ühte kausta, siis võime määrata selle vaikimisi kaustaks. Sel juhul ei pea me faili täielikku asukohta sisestama, vaid piisab faili nimest ja -laiendist.\n\nsetwd('C:/Users/kasutajanimi/Desktop/')\nthi &lt;- read.csv('thi.csv')\n\n\n\n\n\n\n\nWarning\n\n\n\nR keel tunnistab failide asukoha kirjes kaustade eraldajatena paremale kaldu olevaid kaldkriipse (/). See vastab MacOS ja Linuxi failisüsteemile. Microsoft Windows kasutab aga vasakule kaldu olevaid kaldkriipse (\\). Seega tuleb Windowsi süsteemis faili asukoha kopeerimisel R keelde kaldkriipsud vastavalt ära muuta."
  },
  {
    "objectID": "kasutus.html#ülevaade-objektist",
    "href": "kasutus.html#ülevaade-objektist",
    "title": "5  Põhikasutus",
    "section": "5.5 Ülevaade objektist",
    "text": "5.5 Ülevaade objektist\nAndmete sisestamisel on hea mõte veenduda, et andmed laaditi töölauale õigesti. Selleks saame kasutada funktsiooni head(), mis kuvab esimesed viis rida.\n\nhead(thi)\n\n  Aasta Kaubagrupp      Kuu Tarbijahinnaindeks\n1  1998      Kokku  Jaanuar             105.58\n2  1998      Kokku Veebruar             106.59\n3  1998      Kokku    Märts             107.43\n4  1998      Kokku   Aprill             107.90\n5  1998      Kokku      Mai             108.28\n6  1998      Kokku    Juuni             108.48\n\n\nKõikidest andmetabeli tunnustest saame ülevaate funktsiooni str() abil. Samuti kuvab funktsioon vaatluste ja tunnuste arvu.\n\nstr(thi)\n\n'data.frame':   3991 obs. of  4 variables:\n $ Aasta             : chr  \"1998\" \"1998\" \"1998\" \"1998\" ...\n $ Kaubagrupp        : chr  \"Kokku\" \"Kokku\" \"Kokku\" \"Kokku\" ...\n $ Kuu               : chr  \"Jaanuar\" \"Veebruar\" \"Märts\" \"Aprill\" ...\n $ Tarbijahinnaindeks: num  106 107 107 108 108 ..."
  },
  {
    "objectID": "kasutus.html#valimine",
    "href": "kasutus.html#valimine",
    "title": "5  Põhikasutus",
    "section": "5.6 Valimine",
    "text": "5.6 Valimine\nTabelarvutuses saab vajalike lahtrite valimiseks kasutada kursorit, aga käsureal ei saa valikud vormistada muul viisil kui käsuna. Selleks kõige lihtsam viis on sisestada soovitud väärtuste asukoht objekti järel nurksulgudesse.\n\n# Vektori kolmas väärtus\nFibonacci\n\n[1]  1 NA  2  3 NA\n\nFibonacci[3]\n\n[1] 2\n\n# Andmetabel esimese rea ja neljanda veeru väärtus\nthi[1, 4]\n\n[1] 105.58\n\n# Andmetabeli veeru Tarbijahinnaindeks esimene rida\nthi$Tarbijahinnaindeks[1]\n\n[1] 105.58\n\n# Andmetabel esimese rea ja kõikide veergude väärtused\nthi[1, ]\n\n  Aasta Kaubagrupp     Kuu Tarbijahinnaindeks\n1  1998      Kokku Jaanuar             105.58\n\n\nEnamasti ei soovi me aga vajalikke väärtusi valida mitte nende asukoha alusel, vaid mingi teise tunnuse väärtuse alusel. Sellisel juhul saame esitada valiku tõeväärtusena.\n\n# Kolmas ja neljas väärtus asukoha alusel\nFibonacci[c(3,4)]\n\n[1] 2 3\n\n# Kolmas ja neljas väärtus tõeväärtusena\nFibonacci[c(FALSE,FALSE,TRUE,TRUE,FALSE)]\n\n[1] 2 3\n\n\nTõeväärtused võivad sisaldada ka mitut tingimust.\n\n# Read, mille korral THI oli vähem kui 100 ja kaubagrupp ei olnud side\nthi[thi$Tarbijahinnaindeks &lt; 100 & thi$Kaubagrupp != 'Side', ]\n\n    Aasta                      Kaubagrupp       Kuu Tarbijahinnaindeks\n176  1999 Toit ja mittealkohoolsed joogid    August              99.40\n177  1999 Toit ja mittealkohoolsed joogid September              99.12\n178  1999 Toit ja mittealkohoolsed joogid  Oktoober              99.89\n\n# Aasta ja THI väärtused jaanuarikuus kõikide kaupade arvestuses\nthi[thi$Kuu == 'Jaanuar' & thi$Kaubagrupp == 'Kokku', \n    c('Aasta', 'Tarbijahinnaindeks')]\n\n     Aasta Tarbijahinnaindeks\n1     1998             105.58\n157   1999             110.44\n313   2000             114.01\n469   2001             120.63\n625   2002             125.70\n781   2003             128.94\n937   2004             129.55\n1093  2005             135.03\n1249  2006             141.31\n1405  2007             148.54\n1561  2008             164.88\n1717  2009             171.58\n1873  2010             170.39\n2029  2011             179.34\n2185  2012             187.38\n2341  2013             193.84\n2497  2014             195.95\n2653  2015             193.40\n2809  2016             192.31\n2965  2017             197.58\n3121  2018             204.44\n3277  2019             209.98\n3433  2020             213.40\n3589  2021             213.88\n3745  2022             238.13\n3901  2023             282.40\n\n\n\n\n\n\n\n\nNote\n\n\n\nTõeväärtuse abil saame objektist valida väärtused mingi teise objekti väärtuse alusel. Selle teise objekti väärtused tuleb määrata võrdlusoperaatori abil. Mitme võrdluse korral peame võrdlused eraldama loogikaoperaatoritega.\n\n\nVõrdlusoperaatorite (relational operators) abil saame tekitada tõeväärtuse, mille alusel saame valida soovitud väärtuse mingi muu objekti väärtuse järgi. Võrdlusoperaatoreid on kuus:\n\nvõrdub == (kaks võrdusmärki),\nei võrdu !=,\nsuurem kui &gt;,\nväiksem kui &lt;,\nsuurem või võrdne kui &gt;=,\nväiksem või võrdne kui &lt;=.\n\nLoogikaoperaatorite (logical operators) abil saame ühendada mitu võrdlust. Lihtsamaid loogikaoperaatoreid on kolm (!, &, |) ja neid saab kasutada võrdluste liitmisel tõeväärtuste moodustamiseks nt järgnevalt:\n\nmitte x (!x)\nx ja y (x & y),\nx või y (x | y),\nx ja mitte y (x & !y).\n\n\n5.6.1 Valimine andmetabelist\nEelneva kirjelduse alusel võib väärtuste valimine tunduda keeruline ja tülikas. Seda saab teatud mõttes lihtsustada, kui kasutame varem paigaldatud laienduses sisalduvaid funktsioone. Ridade valimiseks on funktsioon filter() ja veergude valimiseks select().\n\n# THI aastal 2020\nfilter(thi, Aasta == 2020 & Kaubagrupp == 'Kokku')\n\n   Aasta Kaubagrupp       Kuu Tarbijahinnaindeks\n1   2020      Kokku   Jaanuar             213.40\n2   2020      Kokku  Veebruar             214.45\n3   2020      Kokku     Märts             212.94\n4   2020      Kokku    Aprill             212.09\n5   2020      Kokku       Mai             210.67\n6   2020      Kokku     Juuni             212.57\n7   2020      Kokku     Juuli             212.57\n8   2020      Kokku    August             213.94\n9   2020      Kokku September             213.32\n10  2020      Kokku  Oktoober             212.24\n11  2020      Kokku  November             212.49\n12  2020      Kokku Detsember             212.50\n\n# THI veerg andmetabeli esimesel viiel real\nselect(head(thi), Tarbijahinnaindeks)\n\n  Tarbijahinnaindeks\n1             105.58\n2             106.59\n3             107.43\n4             107.90\n5             108.28\n6             108.48\n\n\nTehtud valiku salvestamiseks tuleb saadud tulemus lihtsalt sisestusoperaatori abil objekti salvestada.\n\n# Jätame alles vaid read alates aastast 2020\nthi &lt;- filter(thi, Aasta &gt;= 2020)"
  },
  {
    "objectID": "kasutus.html#kokkuvõtted",
    "href": "kasutus.html#kokkuvõtted",
    "title": "5  Põhikasutus",
    "section": "5.7 Kokkuvõtted",
    "text": "5.7 Kokkuvõtted\nVäärtuste kokku võtvaks kirjeldamiseks on väga palju viise ja neile vastavaid funktsioone, aga alustuseks vaatame liitmist, keskmist ja äärmuslikke väärtusi.\n\nFibonacci &lt;- c(0,1,1,2,3,5,8,13,21,34,55,89)\nsum(Fibonacci) # Summa\n\n[1] 232\n\nmean(Fibonacci) # Aritmeetiline keskmine\n\n[1] 19.33333\n\nmedian(Fibonacci) # Mediaan\n\n[1] 6.5\n\nmin(Fibonacci) # Väikseim väärtus\n\n[1] 0\n\nmax(Fibonacci) # Suurim väärtus\n\n[1] 89\n\nrange(Fibonacci) # Väikseima ja suurima väärtuse vahe\n\n[1]  0 89\n\nlength(Fibonacci) # Väärtuste arv\n\n[1] 12"
  },
  {
    "objectID": "kasutus.html#torutamine",
    "href": "kasutus.html#torutamine",
    "title": "5  Põhikasutus",
    "section": "5.8 Torutamine",
    "text": "5.8 Torutamine\nKoodi kirjutamise ja eriti hiljem lugemise lihtsustamiseks saab kasutada paljudes programmeerimiskeeltes kasutusel olevat toru (pipe). Torude abil saame ühe funktsiooni tulemuse suunata järgmisesse funktsiooni, mis muudab koodi selgemaks. Kokku on kolm viisi, kuidas funktsioone omavahel ühendada.\n\n# Oletame, et soovime uurida eluaseme THI muutust 2022. aastal\n## Iga iga funktsiooni tulemuse saab järjest objekti salvestada\neluase &lt;- filter(thi, Kaubagrupp == 'Eluase')\neluase &lt;- filter(eluase, Aasta == 2022)\nselect(eluase, Kuu, Tarbijahinnaindeks)\n\n         Kuu Tarbijahinnaindeks\n1    Jaanuar             452.08\n2   Veebruar             439.13\n3      Märts             456.10\n4     Aprill             538.55\n5        Mai             557.34\n6      Juuni             587.38\n7      Juuli             623.25\n8     August             683.04\n9  September             659.76\n10  Oktoober             585.75\n11  November             592.23\n12 Detsember             589.07\n\n## Nö pesastamist kasutades tõstame funktsiooni tulemuse järgmise funktsiooni sisse\nselect(filter(filter(thi, Kaubagrupp == 'Eluase'), Aasta == 2022), Kuu, Tarbijahinnaindeks)\n\n         Kuu Tarbijahinnaindeks\n1    Jaanuar             452.08\n2   Veebruar             439.13\n3      Märts             456.10\n4     Aprill             538.55\n5        Mai             557.34\n6      Juuni             587.38\n7      Juuli             623.25\n8     August             683.04\n9  September             659.76\n10  Oktoober             585.75\n11  November             592.23\n12 Detsember             589.07\n\n## Torutamise käigus saadame funktsiooni tulemuse järgmisesse funktsiooni\nthi %&gt;% \n  filter(Kaubagrupp == 'Eluase') %&gt;% \n  filter(Aasta == 2022) %&gt;% \n  select(Kuu, Tarbijahinnaindeks)\n\n         Kuu Tarbijahinnaindeks\n1    Jaanuar             452.08\n2   Veebruar             439.13\n3      Märts             456.10\n4     Aprill             538.55\n5        Mai             557.34\n6      Juuni             587.38\n7      Juuli             623.25\n8     August             683.04\n9  September             659.76\n10  Oktoober             585.75\n11  November             592.23\n12 Detsember             589.07\n\n\nNagu näha, siis arvestab torule järgnev funktsioon kõige esimese argumendina eelneva funktsiooni tulemust.\nÜhendades nüüd oskused andmetabelist andmeid valida ja kokku võtta saame juba hakata vastama mitmesugustele küsimustele.\n\n# Millal ja mis kaubagrupis oli THI pärast 2020. aastat kõige kõrgem?\nfilter(thi, Aasta &gt;= 2021) %&gt;% \n  filter(Tarbijahinnaindeks == max(Tarbijahinnaindeks))\n\n  Aasta Kaubagrupp    Kuu Tarbijahinnaindeks\n1  2022     Eluase August             683.04\n\n# Mis juhtudel on THI suurenenud 1997. aastaga võrreldes vähemalt 4 korda?\nthi %&gt;% filter(Tarbijahinnaindeks &gt; 400) \n\n   Aasta                       Kaubagrupp       Kuu Tarbijahinnaindeks\n1   2021                           Eluase September             400.24\n2   2021                           Eluase  November             405.27\n3   2021                           Eluase Detsember             484.44\n4   2022                           Eluase   Jaanuar             452.08\n5   2022                           Eluase  Veebruar             439.13\n6   2022                           Eluase     Märts             456.10\n7   2022                           Eluase    Aprill             538.55\n8   2022                           Eluase       Mai             557.34\n9   2022                           Eluase     Juuni             587.38\n10  2022                           Eluase     Juuli             623.25\n11  2022                           Eluase    August             683.04\n12  2022                           Eluase September             659.76\n13  2022                           Eluase  Oktoober             585.75\n14  2022                           Eluase  November             592.23\n15  2022                           Eluase Detsember             589.07\n16  2022 Söömine väljaspool kodu, majutus     Juuli             426.74\n17  2022 Söömine väljaspool kodu, majutus    August             416.38\n18  2023                           Eluase   Jaanuar             594.75\n19  2023                           Eluase  Veebruar             581.33\n20  2023                           Eluase     Märts             581.58\n21  2023                           Eluase    Aprill             627.92\n22  2023                           Eluase       Mai             626.18\n23  2023                           Eluase     Juuni             628.28\n24  2023                           Eluase     Juuli             614.56\n25  2023 Söömine väljaspool kodu, majutus  Veebruar             404.10\n26  2023 Söömine väljaspool kodu, majutus     Märts             410.81\n27  2023 Söömine väljaspool kodu, majutus    Aprill             409.45\n28  2023 Söömine väljaspool kodu, majutus       Mai             415.23\n29  2023 Söömine väljaspool kodu, majutus     Juuni             434.64\n30  2023 Söömine väljaspool kodu, majutus     Juuli             441.37"
  },
  {
    "objectID": "kasutus.html#salvestamine",
    "href": "kasutus.html#salvestamine",
    "title": "5  Põhikasutus",
    "section": "5.9 Salvestamine",
    "text": "5.9 Salvestamine\nNii nagu andmete R keskkonda lugemise korral on ka nende salvestamiseks soovitatav kasutada CSV vormingut. Selleks on funktsioon write.csv(), aga kui soovime hiljem selle faili avada Excelis, siis tuleb enamasti kasutada funktsiooni write.csv2().\n\nwrite.csv(thi, 'andmed/thi.csv')"
  },
  {
    "objectID": "kasutus.html#korratav-analüüs",
    "href": "kasutus.html#korratav-analüüs",
    "title": "5  Põhikasutus",
    "section": "5.10 Korratav analüüs",
    "text": "5.10 Korratav analüüs\nKuna R keele kasutamisel teeme kõik tehted käskude alusel, siis saame kõik käsud salvestada käsulehele (script). Käsulehe kasutamine annab palju võimalusi:\n\nkui soovime sisestatud käsu tühistada, siis saame jooksutada uuesti eelnevad käsud;\nkui avastame hiljem, et tegime vea või soovime midagi tehtud analüüsis muuta, siis piisab käsulehel muudatuse tegemisest ja käsulehe uuesti jooksutamisest;\nsaame hiljem üle vaadata, kuidas täpselt andmetöötluses mingi tulemuseni jõudsime;\nteised saavad veenduda meie tulemuste õigsuses, rakendades meie koosatud käsulehte mingitel andmetel.\n\n\n\n\n\n\n\nNote\n\n\n\nR keelt kasutades ei ole võimalik käske tühistada või tagasi võtta (undo). Kõik muudatused andmetes on lõplikud. Eelneva analüüsi sammu juurde tagasi minemiseks peame andmed uuesti R töölauale sisestama.\n\n\nKäsulehel on andmetöötluse tegevused enamasti teatud järjekorras:\n\ntöökausta määramine,\nlaienduste laadimine,\nandmete sisestamine,\nandmetöötlus,\ntulemuse salvestamine andmefailide, tabelite, jooniste või muul kujul."
  },
  {
    "objectID": "kasutus.html#aruanded-r-keeles",
    "href": "kasutus.html#aruanded-r-keeles",
    "title": "5  Põhikasutus",
    "section": "5.11 Aruanded R keeles",
    "text": "5.11 Aruanded R keeles\nLisaks käsulehele saab analüüsi vormistada ka terve aruandena. Rakenduses RStudio saab selleks kõik käsud ja sinna juurde kuuluvad selgitused vormistada lihttekstina vastavalt Quarto eeskirjadele. Vastavaid .qmd faililaiendiga lihtteksti faile saab salvestada paljudes erinevates vormingutes, sh PDFi, HTMLi ja Microsoft Wordi dokumentidena. Teksti vormistamiseks tuleb sealjuures kasutada Markdown märgistuskeelt."
  },
  {
    "objectID": "korrastus.html#veeru-nimetused",
    "href": "korrastus.html#veeru-nimetused",
    "title": "6  Korrastus",
    "section": "6.1 Veeru nimetused",
    "text": "6.1 Veeru nimetused\nKui oleme andmed töölauale laadinud, siis esmalt on mõistlik saada nendest ülevaade. Selleks kasutame juba tuttavaid funktsioone objekti esimeste ridade (head()) ja ülesehituse (str()) kuvamiseks.\n\nhead(palk)\n\n                       Näitaja               Tegevusala   Vaatlusperiood\n1 Keskmine brutokuupalk, eurot Kokku – kõik tegevusalad   2002 I kvartal\n2 Keskmine brutokuupalk, eurot Kokku – kõik tegevusalad  2002 II kvartal\n3 Keskmine brutokuupalk, eurot Kokku – kõik tegevusalad 2002 III kvartal\n4 Keskmine brutokuupalk, eurot Kokku – kõik tegevusalad  2002 IV kvartal\n5 Keskmine brutokuupalk, eurot Kokku – kõik tegevusalad   2003 I kvartal\n6 Keskmine brutokuupalk, eurot Kokku – kõik tegevusalad  2003 II kvartal\n  PA001: KESKMINE BRUTOPALK, TÖÖJÕUKULU, TÖÖTATUD TUNNID JA TÖÖTAJATE ARV\n1                                                                     366\n2                                                                     406\n3                                                                     374\n4                                                                     416\n5                                                                     405\n6                                                                     442\n\nstr(palk)\n\n'data.frame':   7920 obs. of  4 variables:\n $ Näitaja                                                                : chr  \"Keskmine brutokuupalk, eurot\" \"Keskmine brutokuupalk, eurot\" \"Keskmine brutokuupalk, eurot\" \"Keskmine brutokuupalk, eurot\" ...\n $ Tegevusala                                                             : chr  \"Kokku – kõik tegevusalad\" \"Kokku – kõik tegevusalad\" \"Kokku – kõik tegevusalad\" \"Kokku – kõik tegevusalad\" ...\n $ Vaatlusperiood                                                         : chr  \"2002 I kvartal\" \"2002 II kvartal\" \"2002 III kvartal\" \"2002 IV kvartal\" ...\n $ PA001: KESKMINE BRUTOPALK, TÖÖJÕUKULU, TÖÖTATUD TUNNID JA TÖÖTAJATE ARV: num  366 406 374 416 405 442 411 455 431 474 ...\n\n\nNäeme, et neljandal veerul on pikk ja lohisev nimetus. Andmetabel veeru nimetusi saame kuvada funktsiooniga names() ja selle funktsiooni nimetust kasutades saame ka neljandale veerule uue nime anda.\n\nnames(palk)\n\n[1] \"Näitaja\"                                                                \n[2] \"Tegevusala\"                                                             \n[3] \"Vaatlusperiood\"                                                         \n[4] \"PA001: KESKMINE BRUTOPALK, TÖÖJÕUKULU, TÖÖTATUD TUNNID JA TÖÖTAJATE ARV\"\n\nnames(palk)[4] &lt;- 'väärtus'\nnames(palk)\n\n[1] \"Näitaja\"        \"Tegevusala\"     \"Vaatlusperiood\" \"väärtus\""
  },
  {
    "objectID": "korrastus.html#tunnuse-tüüp",
    "href": "korrastus.html#tunnuse-tüüp",
    "title": "6  Korrastus",
    "section": "6.2 Tunnuse tüüp",
    "text": "6.2 Tunnuse tüüp\nAndmetabeli ülesehituse küsimisel kuvatakse ka iga tunnuse tüüp, millest sagedasemad on arvtunnus (num) ja nimitunnus (chr). Täpsemalt loe mõõtmise tasemete ja tunnuse tüüpide kohta peatükist 8.\n\nstr(palk)\n\n'data.frame':   7920 obs. of  4 variables:\n $ Näitaja       : chr  \"Keskmine brutokuupalk, eurot\" \"Keskmine brutokuupalk, eurot\" \"Keskmine brutokuupalk, eurot\" \"Keskmine brutokuupalk, eurot\" ...\n $ Tegevusala    : chr  \"Kokku – kõik tegevusalad\" \"Kokku – kõik tegevusalad\" \"Kokku – kõik tegevusalad\" \"Kokku – kõik tegevusalad\" ...\n $ Vaatlusperiood: chr  \"2002 I kvartal\" \"2002 II kvartal\" \"2002 III kvartal\" \"2002 IV kvartal\" ...\n $ väärtus       : num  366 406 374 416 405 442 411 455 431 474 ...\n\n\n\n\n\n\n\n\nWarning\n\n\n\nTunnuse tüüp peab olema objektis määratud vastavalt tunnuse mõõtmise tasemele. Arvud peavad olema objektides salvestatud arvtunnusena ning sõnad ja laused nimitunnusena. Vastupidisel juhul käsitlevad funktsioonid tunnuseid valesti ega võimalda rakendada vajalikke tehteid.\n\n\nTunnuse tüüp on oluline selleks et funktsioonid oskaksid neid õigesti kasutada. Nt kui arve sisaldav veerg on laaditud mingil põhjusel1 objekti nimitunnusena, siis ei ole võimalik sellise tunnusega matemaatilisi tehteid teha. Kui aga andmetabelis on mingi vaatluse kood (nt isikukood), mille R keel tuvastab arvtunnusena, siis on mõistlik salvestada see nimitunnusena, et mitte selle alusel kogemata arvutusi teha. Tunnuste tüübi teisendamiseks saab kasutada funktsioone as.character() ja as.numeric().1 Kui arve sisaldavasse veergu on sattunud mõni sõna, täht, kirjavahemärk vms, siis R loeb selles veerus olevad väärtused enamasti nimitunnusteks.\n\n# Kui arvud on salvestatud nimitunnusena, siis ei saa arvutata keskmist.\npalk$väärtus &lt;- as.character(palk$väärtus)\nhead(palk$väärtus) %&gt;% mean\n\nWarning in mean.default(.): argument is not numeric or logical: returning NA\n\n\n[1] NA\n\n# Kui arvtunnus on õigesti sisestatud, siis saab selle alusel ka arvutada.\npalk$väärtus &lt;- as.numeric(palk$väärtus)\nhead(palk$väärtus) %&gt;% mean\n\n[1] 401.5"
  },
  {
    "objectID": "korrastus.html#kordumatud-väärtused",
    "href": "korrastus.html#kordumatud-väärtused",
    "title": "6  Korrastus",
    "section": "6.3 Kordumatud väärtused",
    "text": "6.3 Kordumatud väärtused\nEelnevalt kuvatud andmetabeli puhul huvitab meid ilmselt, mis võimalikud väärtused on veergudes “Näitaja”, “Tegevusala” ja “Vaatlusperiood”. Kuna tabelis on 7920 rida, siis ei ole otstarbekas kuvada kõiki väärtusi, vaid ainult neid, mis ei kordu. Selleks on käsklus unique().\n\nunique(palk$Näitaja)\n\n[1] \"Keskmine brutokuupalk, eurot\"                          \n[2] \"Keskmine kuutööjõukulu töötaja kohta, eurot\"           \n[3] \"Osalise tööajaga töötajate töötatud tundide osakaal, %\"\n[4] \"Keskmine töötajate arv, taandatud täistööajale\"        \n\nunique(palk$Tegevusala)\n\n [1] \"Kokku – kõik tegevusalad\"                                          \n [2] \"Põllumajandus, metsamajandus ja kalapüük\"                          \n [3] \"Mäetööstus\"                                                        \n [4] \"Töötlev tööstus\"                                                   \n [5] \"Elektrienergia, gaasi, auru ja konditsioneeritud õhuga varustamine\"\n [6] \"Veevarustus; kanalisatsioon; jäätme- ja saastekäitlus\"             \n [7] \"Ehitus\"                                                            \n [8] \"Hulgi- ja jaekaubandus; mootorsõidukite ja mootorrataste remont\"   \n [9] \"Veondus ja laondus\"                                                \n[10] \"Majutus ja toitlustus\"                                             \n[11] \"Info ja side\"                                                      \n[12] \"Finants- ja kindlustustegevus\"                                     \n[13] \"Kinnisvaraalane tegevus\"                                           \n[14] \"Kutse-, teadus- ja tehnikaalane tegevus\"                           \n[15] \"Haldus- ja abitegevused\"                                           \n[16] \"Avalik haldus ja riigikaitse; kohustuslik sotsiaalkindlustus\"      \n[17] \"Haridus\"                                                           \n[18] \"Tervishoid ja sotsiaalhoolekanne\"                                  \n[19] \"Kunst, meelelahutus ja vaba aeg\"                                   \n[20] \"Muud teenindavad tegevused\"                                        \n\nunique(palk$Vaatlusperiood)\n\n [1] \"2002 I kvartal\"   \"2002 II kvartal\"  \"2002 III kvartal\" \"2002 IV kvartal\" \n [5] \"2003 I kvartal\"   \"2003 II kvartal\"  \"2003 III kvartal\" \"2003 IV kvartal\" \n [9] \"2004 I kvartal\"   \"2004 II kvartal\"  \"2004 III kvartal\" \"2004 IV kvartal\" \n[13] \"2005 I kvartal\"   \"2005 II kvartal\"  \"2005 III kvartal\" \"2005 IV kvartal\" \n[17] \"2006 I kvartal\"   \"2006 II kvartal\"  \"2006 III kvartal\" \"2006 IV kvartal\" \n[21] \"2007 I kvartal\"   \"2007 II kvartal\"  \"2007 III kvartal\" \"2007 IV kvartal\" \n[25] \"2008\"             \"2008 I kvartal\"   \"2008 II kvartal\"  \"2008 III kvartal\"\n[29] \"2008 IV kvartal\"  \"2009\"             \"2009 I kvartal\"   \"2009 II kvartal\" \n[33] \"2009 III kvartal\" \"2009 IV kvartal\"  \"2010\"             \"2010 I kvartal\"  \n[37] \"2010 II kvartal\"  \"2010 III kvartal\" \"2010 IV kvartal\"  \"2011\"            \n[41] \"2011 I kvartal\"   \"2011 II kvartal\"  \"2011 III kvartal\" \"2011 IV kvartal\" \n[45] \"2012\"             \"2012 I kvartal\"   \"2012 II kvartal\"  \"2012 III kvartal\"\n[49] \"2012 IV kvartal\"  \"2013\"             \"2013 I kvartal\"   \"2013 II kvartal\" \n[53] \"2013 III kvartal\" \"2013 IV kvartal\"  \"2014\"             \"2014 I kvartal\"  \n[57] \"2014 II kvartal\"  \"2014 III kvartal\" \"2014 IV kvartal\"  \"2015\"            \n[61] \"2015 I kvartal\"   \"2015 II kvartal\"  \"2015 III kvartal\" \"2015 IV kvartal\" \n[65] \"2016\"             \"2016 I kvartal\"   \"2016 II kvartal\"  \"2016 III kvartal\"\n[69] \"2016 IV kvartal\"  \"2017\"             \"2017 I kvartal\"   \"2017 II kvartal\" \n[73] \"2017 III kvartal\" \"2017 IV kvartal\"  \"2018\"             \"2018 I kvartal\"  \n[77] \"2018 II kvartal\"  \"2018 III kvartal\" \"2018 IV kvartal\"  \"2019\"            \n[81] \"2019 I kvartal\"   \"2019 II kvartal\"  \"2019 III kvartal\" \"2019 IV kvartal\" \n[85] \"2020\"             \"2020 I kvartal\"   \"2020 II kvartal\"  \"2020 III kvartal\"\n[89] \"2020 IV kvartal\"  \"2021\"             \"2021 I kvartal\"   \"2021 II kvartal\" \n[93] \"2021 III kvartal\" \"2021 IV kvartal\"  \"2022\"             \"2022 I kvartal\"  \n[97] \"2022 II kvartal\"  \"2022 III kvartal\" \"2022 IV kvartal\" \n\n\nNäeme, et vaatlusperioodi veerus on läbisegi aastad ja kvartalid. Kui teisendame vastava tunnuse arvtunnuseks, siis tähti sisaldavad väärtused muutuvad puuduvateks väärtusteks.\n\npalk$Vaatlusperiood &lt;- as.numeric(palk$Vaatlusperiood)\n\nWarning: NAs introduced by coercion\n\nunique(palk$Vaatlusperiood)\n\n [1]   NA 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021\n[16] 2022"
  },
  {
    "objectID": "korrastus.html#puuduvad-väärtused",
    "href": "korrastus.html#puuduvad-väärtused",
    "title": "6  Korrastus",
    "section": "6.4 Puuduvad väärtused",
    "text": "6.4 Puuduvad väärtused\nKui andmetes esineb puuduvaid väärtusi, siis on kolm peamist viisi, kuidas nendega tekkivaid probleeme lahendada.\n\nEnamasti eemaldatakse andmetabelist vaatlused (read), milles esinevad puuduvad väärtused.\nKui on teada, et puuduvad väärtused esinevad juhuslikult, siis on lihtne viis on asendada need veeru keskmise väärtusega.\nÕigem on tuletada puuduvad väärtused aga teiste veergude väärtuste alusel. Tõeste väärtuse prognoosimiseks on palju erievaid võimalusi, sh masinõpe.\nKui puuduvaid väärtusi soovitakse analüüsi kaasata või eraldi uurida, siis saab need eraldi väärtusega määratleda. Puuduvate nimitunnuse väärtustele võib anda mingi nimetuse, arvtunnuse korral võib puuduvad väärtused määratleda eraldi veerus loogilise muutujana.\n\nVaatlusperioodi teisendamise tulemusel on nüüd vastavas veerus puuduvad väärtused nendel juhtudel, kus lisaks aastaarvule oli kirjas ka kvartal. Seega saame tabelisse alles jätta vaid aastaid esindavad väärtused kui eemaldame need read, kus vaatlusperiood puudub. Puuduvate väärtuse määratlemiseks saame kasutada funktsiooni is.na() ja olemasolevate väärtuse valimiseks peame seega lisaman funktsiooni ette loogikaoperaatori !.\n\n# Algne ridade arv\nnrow(palk)\n\n[1] 7920\n\n# Sõelume välja väärtused, kus vaatlusperiood ei ole puudu.\npalk &lt;- filter(palk, !is.na(Vaatlusperiood))\n# Ridade arv pärast puuduvate väärtustega ridade eemaldamist\nnrow(palk)\n\n[1] 1200\n\n\nTeine võimalus on kasutada funktsiooni complete.cases(), mis väljastab andmetabelis puuduvate väärtusteta read määrava tõeväärtuse, võttes puuduvate väärtuse määramisel arvesse kõiki veerge.\n\n# Valime read, kus on ainult täielikud vaatlused\npalk &lt;- palk[complete.cases(palk), ]\n# Eemaldame puuduvate väärtustega read\npalk &lt;- na.omit(palk)"
  },
  {
    "objectID": "korrastus.html#väärtuste-asendamine",
    "href": "korrastus.html#väärtuste-asendamine",
    "title": "6  Korrastus",
    "section": "6.5 Väärtuste asendamine",
    "text": "6.5 Väärtuste asendamine\nMõnikord esineb andmetes väärtusi, mis ei ole teoreetiliselt võimalikud. Sellisel juhul on kolm viisi, kuidas sobimatud väärtused kõrvaldada.\n\nArvtunnuse korral saab ebasobiva väärtuse asendada vastavalt vähima või suurima teoreetiliselt võimaliku väärtusega.\nVõimalusel saab eemaldada kogu ebasobivaid väärtuseid sisaldava tunnuse.\nEbasobivaid väärtusi saab kohelda nii nagu puuduvaid väärtuseid.\n\nKui oletame, et meie andmetabelis oleval ajavahemikul oli alampalk kõige vähem 278 eurot kuus, siis ei tohiks olla väärtuseid, kus keskmine brutokuupalk on sellest madalam.\n\n# Tekitame uue andmetabeli ainult kõikide tegevusalade keskmise kuupalgaga\nbruto &lt;- filter(palk, \n                Näitaja == 'Keskmine brutokuupalk, eurot' &\n                  Tegevusala == 'Kokku – kõik tegevusalad')\n# Määrame väärtuseks 278 juhtudel, kus väärtus on vähem kui 278\nbruto$väärtus[bruto$väärtus &lt; 278] &lt;- 278"
  },
  {
    "objectID": "korrastus.html#väärtuste-teisendamine",
    "href": "korrastus.html#väärtuste-teisendamine",
    "title": "6  Korrastus",
    "section": "6.6 Väärtuste teisendamine",
    "text": "6.6 Väärtuste teisendamine\nVäärtuste teisendamise käigus antakse tunnusele uued väärtused lähtudes algsetest väärtustest. Selleks on mitu põhjust ja viisi.\n\nKui tunnusel on palju äärmuslikul suuri või väikseid väärtusi, siis selline tunnus ei sobi paljude parameetriliste meetodite rakendamiseks. Sellisel juhul saab kasutada erinevaid matemaatilisi teisendusi, mis muudab väärtuste jaotuse sümmeetrilisemaks2.\nTeatud meetodid eeldavad, et andmed on mõõdetud samal skaalal ehk omavad sarnaseid väärtusi. Sellisel juhul saame väärtused standardiseerida.\nKui tunnusel on rohkem kordumatuid väärtusi kui soovime, siis saame väärtused intervallida.\n\n2 Kui tunnusel on palju äärmuslikult suuri jaotusi, siis naturaallogaritm väärtustest annab tulemuseks sümmeetrilise jaotuse.Kui soovime keskmise brutokuupalga esitada 500 euro laiuste intervallidena, siis saame intervallimiseks kasutada funktsiooni cut().\n\nbruto$intervallid &lt;- cut(bruto$väärtus, \n                         breaks = c(500,1000,1500,Inf), \n                         labels = c(\"&gt;500...1000\",\"&gt;1000...1500\",\"&gt;1500\"))\nbruto %&gt;% select(Vaatlusperiood, väärtus, intervallid)\n\n   Vaatlusperiood väärtus  intervallid\n1            2008     825  &gt;500...1000\n2            2009     784  &gt;500...1000\n3            2010     792  &gt;500...1000\n4            2011     839  &gt;500...1000\n5            2012     887  &gt;500...1000\n6            2013     949  &gt;500...1000\n7            2014    1005 &gt;1000...1500\n8            2015    1065 &gt;1000...1500\n9            2016    1146 &gt;1000...1500\n10           2017    1221 &gt;1000...1500\n11           2018    1310 &gt;1000...1500\n12           2019    1407 &gt;1000...1500\n13           2020    1448 &gt;1000...1500\n14           2021    1548        &gt;1500\n15           2022    1685        &gt;1500\n\n\nAndmetabelisse saab lisada tunnuseid või neid muuta muuhulgas ka funktsiooni mutate() abil.\n\n# Mis aastatel oli keskmine brutotöötasu üle keskmise?\nbruto &lt;- mutate(bruto, ülekeskmise = väärtus &gt; mean(väärtus))\nhead(bruto)\n\n                       Näitaja               Tegevusala Vaatlusperiood väärtus\n1 Keskmine brutokuupalk, eurot Kokku – kõik tegevusalad           2008     825\n2 Keskmine brutokuupalk, eurot Kokku – kõik tegevusalad           2009     784\n3 Keskmine brutokuupalk, eurot Kokku – kõik tegevusalad           2010     792\n4 Keskmine brutokuupalk, eurot Kokku – kõik tegevusalad           2011     839\n5 Keskmine brutokuupalk, eurot Kokku – kõik tegevusalad           2012     887\n6 Keskmine brutokuupalk, eurot Kokku – kõik tegevusalad           2013     949\n  intervallid ülekeskmise\n1 &gt;500...1000       FALSE\n2 &gt;500...1000       FALSE\n3 &gt;500...1000       FALSE\n4 &gt;500...1000       FALSE\n5 &gt;500...1000       FALSE\n6 &gt;500...1000       FALSE"
  },
  {
    "objectID": "korrastus.html#korrasandmed",
    "href": "korrastus.html#korrasandmed",
    "title": "6  Korrastus",
    "section": "6.7 Korrasandmed",
    "text": "6.7 Korrasandmed\nKorrasandmed (tidy data (Wickham, 2014)) on andmetabeli vormistamise viis, mille korral\n\niga tunnus on eraldi veerus,\niga vaatlus on eraldi real,\niga vaatluste aluseks olev üksus on omaette tabelis3.\n\n\n3 Nt tellimuste tabelis ei peaks olema kõiki tellija tunnuseid, vaid tellimused ja tellijad tuleks hoida eraldi tabeltes ning ainult vajaduse korral need tellija koodi alusel kokku viia.\n6.7.1 Andmetabeli laiendamine\nMeie andmed brutotöötasu kohta vastavad tingimusele, et iga vaatlus (mõõtmine) on eraldi real. Kui lähtume aga sellest, et iga näitaja on omaette tunnus, siis peaks iga näitaja väärtused olema eraldi veerus, et meie andmed korrasandmete tingimusele vastaksid.\n\nhead(palk)\n\n                       Näitaja               Tegevusala Vaatlusperiood väärtus\n1 Keskmine brutokuupalk, eurot Kokku – kõik tegevusalad           2008     825\n2 Keskmine brutokuupalk, eurot Kokku – kõik tegevusalad           2009     784\n3 Keskmine brutokuupalk, eurot Kokku – kõik tegevusalad           2010     792\n4 Keskmine brutokuupalk, eurot Kokku – kõik tegevusalad           2011     839\n5 Keskmine brutokuupalk, eurot Kokku – kõik tegevusalad           2012     887\n6 Keskmine brutokuupalk, eurot Kokku – kõik tegevusalad           2013     949\n\n\nSellist andmetabelit, milles iga rida sisaldab ainult ühte väärtust, võiks nimetada täielikult kitsaks. Selline kitsas andmetabel ei pruugi olla kõige sobivam viis selles olevate andmete analüüsimiseks. Nt on praegu keeruline võrrelda kahe näitaja väärtusi, sest need väärtused on kõik ühes veerus. Kui soovime tõsta iga näitaja eraldi veergu ehk antud juhul andmetabelit laiendada, siis saame selleks kasutada funktsiooni pivot_wider().\n\npalk &lt;- pivot_wider(palk, names_from = 'Näitaja', values_from = 'väärtus')\nhead(palk)\n\n# A tibble: 6 × 6\n  Tegevusala        Vaatlusperiood Keskmine brutokuupal…¹ Keskmine kuutööjõuku…²\n  &lt;chr&gt;                      &lt;dbl&gt;                  &lt;dbl&gt;                  &lt;dbl&gt;\n1 Kokku – kõik teg…           2008                    825                   1113\n2 Kokku – kõik teg…           2009                    784                   1067\n3 Kokku – kõik teg…           2010                    792                   1074\n4 Kokku – kõik teg…           2011                    839                   1137\n5 Kokku – kõik teg…           2012                    887                   1203\n6 Kokku – kõik teg…           2013                    949                   1284\n# ℹ abbreviated names: ¹​`Keskmine brutokuupalk, eurot`,\n#   ²​`Keskmine kuutööjõukulu töötaja kohta, eurot`\n# ℹ 2 more variables:\n#   `Osalise tööajaga töötajate töötatud tundide osakaal, %` &lt;dbl&gt;,\n#   `Keskmine töötajate arv, taandatud täistööajale` &lt;dbl&gt;\n\n# Kuna veeru nimed sisaldavad nüüd tühikuid, siis nimetame need ümber.\nnames(palk) &lt;- c('tegevusala', 'aasta', \n                 'kesk.palk', 'kesk.kulu', 'osatööaeg', 'töötajad')\nhead(palk)\n\n# A tibble: 6 × 6\n  tegevusala               aasta kesk.palk kesk.kulu osatööaeg töötajad\n  &lt;chr&gt;                    &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 Kokku – kõik tegevusalad  2008       825      1113       6.4   543432\n2 Kokku – kõik tegevusalad  2009       784      1067       8.2   488166\n3 Kokku – kõik tegevusalad  2010       792      1074       8.1   458523\n4 Kokku – kõik tegevusalad  2011       839      1137       7.3   469123\n5 Kokku – kõik tegevusalad  2012       887      1203       7.2   489054\n6 Kokku – kõik tegevusalad  2013       949      1284       7     487591\n\n\nSellisel kujul tabeliga on meil võimalik erinevatel küsimustele vastamiseks arvutusi teha.\n\n# Mitu eurot kulus keskmiselt tööjõumaksudeks?\npalk$kesk.maksud &lt;- palk$kesk.kulu - palk$kesk.palk\nhead(palk)\n\n# A tibble: 6 × 7\n  tegevusala            aasta kesk.palk kesk.kulu osatööaeg töötajad kesk.maksud\n  &lt;chr&gt;                 &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;       &lt;dbl&gt;\n1 Kokku – kõik tegevus…  2008       825      1113       6.4   543432         288\n2 Kokku – kõik tegevus…  2009       784      1067       8.2   488166         283\n3 Kokku – kõik tegevus…  2010       792      1074       8.1   458523         282\n4 Kokku – kõik tegevus…  2011       839      1137       7.3   469123         298\n5 Kokku – kõik tegevus…  2012       887      1203       7.2   489054         316\n6 Kokku – kõik tegevus…  2013       949      1284       7     487591         335\n\n\n\n\n\n\n\n\nWarning\n\n\n\nEnamus funktsioone eeldavad, et funktsiooni argumentidena esitab kasutaja tunnuse väärtusi sisaldava veeru. Seetõttu tuleks andmetabel vormistada selliselt, et iga tunnuse väärtused on eraldi veerus.\n\n\n\n\n6.7.2 Andmetabeli kitsendamine\nSageli on meil aga vastupidine olukord, kus ühe tunnuse väärtused on jagatud mitmesse veergu. See oli kunagi sagedane nt Statistikaameti tabelite korral, milles vaikimisi esitati iga aasta väärtused eraldi veerus. Sellisel kujul andmed sobivad küll aegridade joonistamiseks tabelarvutuse rakendustes, aga mitte R keele funktsioonide kasutamiseks.\nAll on esitatud Statistikaameti tabel PA5335 palgalõhe kohta, milles iga aasta väärtused on eraldi veerus.\n\nhead(lõhe)\n\n# A tibble: 6 × 13\n  `Tegevusala (EMTAK 2008)`    Näitaja `2011` `2012` `2013` `2014` `2015` `2016`\n  &lt;chr&gt;                        &lt;chr&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n1 Tegevusalad kokku            Meestö…    5.7    5.7    6.1    6.4    7      7.6\n2 Tegevusalad kokku            Naistö…    4.4    4.3    4.6    4.9    5.4    6  \n3 Tegevusalad kokku            Palgal…   22.9   24.6   24.8   23.5   22.2   20.9\n4 Põllumajandus, metsamajandu… Meestö…    4.2    4.2    4.9    5.2    6.3    6.8\n5 Põllumajandus, metsamajandu… Naistö…    3.6    3.9    4.3    4.5    5      5.5\n6 Põllumajandus, metsamajandu… Palgal…   14.7    7     12.7   14.5   20.1   19.2\n# ℹ 5 more variables: `2017` &lt;dbl&gt;, `2018` &lt;dbl&gt;, `2019` &lt;dbl&gt;, `2020` &lt;dbl&gt;,\n#   `2021` &lt;dbl&gt;\n\n\nKoondamaks kõikide aastate väärtused ühte veergu, tuleks seda andmetabelit kitsendada ehk pikendada. Seda saab teha nt funktsiooniga pivot_longer().\n\n# Viime kõik aastad ühte veergu\nlõhe &lt;- pivot_longer(lõhe, cols = as.character(2011:2021), \n                     names_to = 'aasta', values_to = 'väärtus')\nhead(lõhe)\n\n# A tibble: 6 × 4\n  `Tegevusala (EMTAK 2008)` Näitaja                                aasta väärtus\n  &lt;chr&gt;                     &lt;chr&gt;                                  &lt;chr&gt;   &lt;dbl&gt;\n1 Tegevusalad kokku         Meestöötajate keskmine brutotunnipalk… 2011      5.7\n2 Tegevusalad kokku         Meestöötajate keskmine brutotunnipalk… 2012      5.7\n3 Tegevusalad kokku         Meestöötajate keskmine brutotunnipalk… 2013      6.1\n4 Tegevusalad kokku         Meestöötajate keskmine brutotunnipalk… 2014      6.4\n5 Tegevusalad kokku         Meestöötajate keskmine brutotunnipalk… 2015      7  \n6 Tegevusalad kokku         Meestöötajate keskmine brutotunnipalk… 2016      7.6\n\n# Viime iga näitaja eraldi veergu\nlõhe &lt;- pivot_wider(lõhe, names_from = 'Näitaja', values_from = 'väärtus')\nhead(lõhe)\n\n# A tibble: 6 × 5\n  `Tegevusala (EMTAK 2008)` aasta Meestöötajate keskmin…¹ Naistöötajate keskmi…²\n  &lt;chr&gt;                     &lt;chr&gt;                   &lt;dbl&gt;                  &lt;dbl&gt;\n1 Tegevusalad kokku         2011                      5.7                    4.4\n2 Tegevusalad kokku         2012                      5.7                    4.3\n3 Tegevusalad kokku         2013                      6.1                    4.6\n4 Tegevusalad kokku         2014                      6.4                    4.9\n5 Tegevusalad kokku         2015                      7                      5.4\n6 Tegevusalad kokku         2016                      7.6                    6  \n# ℹ abbreviated names: ¹​`Meestöötajate keskmine brutotunnipalk, eurot`,\n#   ²​`Naistöötajate keskmine brutotunnipalk, eurot`\n# ℹ 1 more variable: `Palgalõhe, %` &lt;dbl&gt;\n\n# Parendame veergude nimetusi\nnames(lõhe) &lt;- c('tegevusala', 'aasta', 'mehed.palk', 'naised.palk', 'lõhe.osa')\nhead(lõhe)\n\n# A tibble: 6 × 5\n  tegevusala        aasta mehed.palk naised.palk lõhe.osa\n  &lt;chr&gt;             &lt;chr&gt;      &lt;dbl&gt;       &lt;dbl&gt;    &lt;dbl&gt;\n1 Tegevusalad kokku 2011         5.7         4.4     22.9\n2 Tegevusalad kokku 2012         5.7         4.3     24.6\n3 Tegevusalad kokku 2013         6.1         4.6     24.8\n4 Tegevusalad kokku 2014         6.4         4.9     23.5\n5 Tegevusalad kokku 2015         7           5.4     22.2\n6 Tegevusalad kokku 2016         7.6         6       20.9\n\n\n\n\n\n\n\n\nWarning\n\n\n\nKorduvate mõõtmiste korral tuleks mõõtmise aeg kajastada eraldi veerus ja mitte jaotada sama tunnuse mõõtmisi erinevate veergude vahel."
  },
  {
    "objectID": "korrastus.html#agregeerimine",
    "href": "korrastus.html#agregeerimine",
    "title": "6  Korrastus",
    "section": "6.8 Agregeerimine",
    "text": "6.8 Agregeerimine\nSageli on vaja andmetabelis olevad väärtused edasiseks analüüsiks või kokkuvõtete saamiseks kuidagi koondada. Väärtuste kokku võtmine mingite rühmade kaupa ja mingi tehte alusel on agregeerimine. Nii on agregeerimisel vaja määrata\n\nväärtusi sisaldav kokku võetav tunnus,\nväärtusi rühmitav tunnus,\nkokkuvõtte aluseks olev tehe (funktsioon).\n\nAndmetabeli agregeerimiseks on R keeles funktsioon aggregate(), mille argumentideks tuleb sisestada need kolm tegurit.\n\nhead(palk)\n\n# A tibble: 6 × 7\n  tegevusala            aasta kesk.palk kesk.kulu osatööaeg töötajad kesk.maksud\n  &lt;chr&gt;                 &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;       &lt;dbl&gt;\n1 Kokku – kõik tegevus…  2008       825      1113       6.4   543432         288\n2 Kokku – kõik tegevus…  2009       784      1067       8.2   488166         283\n3 Kokku – kõik tegevus…  2010       792      1074       8.1   458523         282\n4 Kokku – kõik tegevus…  2011       839      1137       7.3   469123         298\n5 Kokku – kõik tegevus…  2012       887      1203       7.2   489054         316\n6 Kokku – kõik tegevus…  2013       949      1284       7     487591         335\n\n# Mis oli igal tegevusalal perioodi keskmise brutotöötasu keskmine?\naggregate(kesk.palk ~ tegevusala, palk, mean)\n\n                                                           tegevusala kesk.palk\n1        Avalik haldus ja riigikaitse; kohustuslik sotsiaalkindlustus 1385.3333\n2                                                              Ehitus 1107.7333\n3  Elektrienergia, gaasi, auru ja konditsioneeritud õhuga varustamine 1592.2000\n4                                       Finants- ja kindlustustegevus 1881.4667\n5                                             Haldus- ja abitegevused  987.8667\n6                                                             Haridus 1012.9333\n7     Hulgi- ja jaekaubandus; mootorsõidukite ja mootorrataste remont 1017.0667\n8                                                        Info ja side 1901.6667\n9                                             Kinnisvaraalane tegevus  852.6000\n10                                           Kokku – kõik tegevusalad 1127.4000\n11                                    Kunst, meelelahutus ja vaba aeg  893.5333\n12                            Kutse-, teadus- ja tehnikaalane tegevus 1332.1333\n13                                                         Mäetööstus 1375.0000\n14                                              Majutus ja toitlustus  712.9333\n15                                         Muud teenindavad tegevused  747.4667\n16                           Põllumajandus, metsamajandus ja kalapüük  962.9333\n17                                   Tervishoid ja sotsiaalhoolekanne 1177.4000\n18                                                    Töötlev tööstus 1074.9333\n19              Veevarustus; kanalisatsioon; jäätme- ja saastekäitlus 1130.5333\n20                                                 Veondus ja laondus 1103.7333\n\n\nTeine võimalus agregeerimiseks on kasutada pakis tidyverse sisalduvaid funktsioone group_by() esmalt rühmitamiseks ja summarise() seejärel kokku võtmiseks.\n\nhead(lõhe)\n\n# A tibble: 6 × 5\n  tegevusala        aasta mehed.palk naised.palk lõhe.osa\n  &lt;chr&gt;             &lt;chr&gt;      &lt;dbl&gt;       &lt;dbl&gt;    &lt;dbl&gt;\n1 Tegevusalad kokku 2011         5.7         4.4     22.9\n2 Tegevusalad kokku 2012         5.7         4.3     24.6\n3 Tegevusalad kokku 2013         6.1         4.6     24.8\n4 Tegevusalad kokku 2014         6.4         4.9     23.5\n5 Tegevusalad kokku 2015         7           5.4     22.2\n6 Tegevusalad kokku 2016         7.6         6       20.9\n\n# Mis oli igal tegevusalal kõige suurem palgalõhe?\nlõhe %&gt;% \n  group_by(tegevusala) %&gt;% # Rühmitame andmetabeli tegevusala alusel\n  summarise(max(lõhe.osa)) # Leiame suurima palgalõhe\n\n# A tibble: 20 × 2\n   tegevusala                                                    `max(lõhe.osa)`\n   &lt;chr&gt;                                                                   &lt;dbl&gt;\n 1 Avalik haldus ja riigikaitse; kohustuslik sotsiaalkindlustus             12.1\n 2 Ehitus                                                                   22  \n 3 Elektrienergia, gaasi, auru ja konditsioneeritud õhuga varus…            18.4\n 4 Finants- ja kindlustustegevus                                            43.3\n 5 Haldus- ja abitegevused                                                  20.4\n 6 Haridus                                                                  26.4\n 7 Hulgi- ja jaekaubandus; mootorsõidukite ja mootorrataste rem…            33.8\n 8 Info ja side                                                             30.1\n 9 Kinnisvaraalane tegevus                                                  27.3\n10 Kunst, meelelahutus ja vaba aeg                                          28.1\n11 Kutse-, teadus- ja tehnikaalane tegevus                                  24.7\n12 Majutus ja toitlustus                                                    20.9\n13 Muud teenindavad tegevused                                               27.4\n14 Mäetööstus                                                               36.4\n15 Põllumajandus, metsamajandus ja kalapüük                                 20.1\n16 Tegevusalad kokku                                                        24.8\n17 Tervishoid ja sotsiaalhoolekanne                                         29.7\n18 Töötlev tööstus                                                          31.5\n19 Veevarustus; kanalisatsioon, jäätme- ja saastekäitlus                    13.6\n20 Veondus ja laondus                                                       10.3\n\n\nVäga sageli on kasu ka funktsioonist table(), mille abil saab väärtuseid loendada.\n\nhead(lõhe)\n\n# A tibble: 6 × 5\n  tegevusala        aasta mehed.palk naised.palk lõhe.osa\n  &lt;chr&gt;             &lt;chr&gt;      &lt;dbl&gt;       &lt;dbl&gt;    &lt;dbl&gt;\n1 Tegevusalad kokku 2011         5.7         4.4     22.9\n2 Tegevusalad kokku 2012         5.7         4.3     24.6\n3 Tegevusalad kokku 2013         6.1         4.6     24.8\n4 Tegevusalad kokku 2014         6.4         4.9     23.5\n5 Tegevusalad kokku 2015         7           5.4     22.2\n6 Tegevusalad kokku 2016         7.6         6       20.9\n\n# Mitu korda iga tegevusala tabelis esineb?\ntable(lõhe$tegevusala)\n\n\n      Avalik haldus ja riigikaitse; kohustuslik sotsiaalkindlustus \n                                                                11 \n                                                            Ehitus \n                                                                11 \nElektrienergia, gaasi, auru ja konditsioneeritud õhuga varustamine \n                                                                11 \n                                     Finants- ja kindlustustegevus \n                                                                11 \n                                           Haldus- ja abitegevused \n                                                                11 \n                                                           Haridus \n                                                                11 \n   Hulgi- ja jaekaubandus; mootorsõidukite ja mootorrataste remont \n                                                                11 \n                                                      Info ja side \n                                                                11 \n                                           Kinnisvaraalane tegevus \n                                                                11 \n                                   Kunst, meelelahutus ja vaba aeg \n                                                                11 \n                           Kutse-, teadus- ja tehnikaalane tegevus \n                                                                11 \n                                                        Mäetööstus \n                                                                11 \n                                             Majutus ja toitlustus \n                                                                11 \n                                        Muud teenindavad tegevused \n                                                                11 \n                          Põllumajandus, metsamajandus ja kalapüük \n                                                                11 \n                                                 Tegevusalad kokku \n                                                                11 \n                                  Tervishoid ja sotsiaalhoolekanne \n                                                                11 \n                                                   Töötlev tööstus \n                                                                11 \n             Veevarustus; kanalisatsioon, jäätme- ja saastekäitlus \n                                                                11 \n                                                Veondus ja laondus \n                                                                11 \n\n# Mitmel aastal oli igal tegevusalal palgalõhe rohkem kui 10%?\ntable(lõhe$tegevusala, lõhe$lõhe.osa &gt; 10)\n\n                                                                    \n                                                                     FALSE TRUE\n  Avalik haldus ja riigikaitse; kohustuslik sotsiaalkindlustus           8    3\n  Ehitus                                                                 1   10\n  Elektrienergia, gaasi, auru ja konditsioneeritud õhuga varustamine     1   10\n  Finants- ja kindlustustegevus                                          0   11\n  Haldus- ja abitegevused                                                2    9\n  Haridus                                                                0   11\n  Hulgi- ja jaekaubandus; mootorsõidukite ja mootorrataste remont        0   11\n  Info ja side                                                           0   11\n  Kinnisvaraalane tegevus                                                0   11\n  Kunst, meelelahutus ja vaba aeg                                        1   10\n  Kutse-, teadus- ja tehnikaalane tegevus                                2    9\n  Mäetööstus                                                             0   11\n  Majutus ja toitlustus                                                  1   10\n  Muud teenindavad tegevused                                             2    9\n  Põllumajandus, metsamajandus ja kalapüük                               3    8\n  Tegevusalad kokku                                                      0   11\n  Tervishoid ja sotsiaalhoolekanne                                       0   11\n  Töötlev tööstus                                                        0   11\n  Veevarustus; kanalisatsioon, jäätme- ja saastekäitlus                  8    3\n  Veondus ja laondus                                                    10    1\n\n\nÜleval olevast tabelist näeme muuhulgas, et\n\nveonduses ja laonduses oli palgalõhe ainult ühel aastal üle 10%, samas kui\nhariduses oli kõikidel aastatel palgalõhe üle 10%.\n\n\nTabelarvutuses on andmete koondamiseks kaks võimalust:\n\nkasutada vastavaid funktsioone ja arvutada koond iga rümitava tunnuse väärtuse kohta eraldi või\ntekitada andmetabeli alusel liigendtabel (pivot table) koos kõikide rühmitava tunnuse väärtuste koonditega.\n\nFunktsioonide abil saame leida ette antud rühma väärtuste summa (=sum()), keskmise (=average()) või arvu (=count()). Selleks peame vastavate funktsioonide nimetuste lõppu lisama ühe rühmitava tunnuse korral if ja mitme korral ifs. Nt kui soovime leida veeru B ainult nende ridade summa, kus veerus A on väärtus 2020, siis peaksime kasutama funktsiooni kujul nt =sumif(A:A,2020,B:B).\nLiigendtabel võimaldab leida korraga ühe tunnuse kõikide rühmade koondi. Selleks peame esmalt määratlema veergude nimetused, määrates neile filtrid. Seejärel saame lisada liigendabeli. Selles tabelis saame esitada kas ridades või veergudes rühmitamise aluseks oleva tunnuse või mitu, tõstes need vastavatesse lahtritesse. Tabelis kuvatakse selle tunnuse koond, mille tõstame väärtuste lahtrisse. Kokkuvõtte aluseks oleva tehte saab määrata samuti selles lahtris."
  },
  {
    "objectID": "korrastus.html#tabelite-ühendamine",
    "href": "korrastus.html#tabelite-ühendamine",
    "title": "6  Korrastus",
    "section": "6.9 Tabelite ühendamine",
    "text": "6.9 Tabelite ühendamine\nMõnikord on sama vaatluse andmed erinevates tabelites. Sellisel juhul saame kaks tabelit omavahel ühendada ühe või mitme tunnuse väärtuste alusel.\nKäesolevates näidetes võiksime ühendada brutopalga ja palgalõhe andmetabelid palk ja lõhe. Mõlemas tabelis esindab iga rida ühte tegevusala ühel aastal, mistõttu saab nende kahe tunnuse alusel read kokku viia.\nSelleks peavad sama tähendusega väärtused olema samamoodi nimetatud. Saame seda kontrollida funktsiooniga setdiff(), mis näitab, millised esimeses argumendis olevad kordumatud väärtused on puudu teisest argumendist.\n\n# Milliseid palgalõhe tabelis olevaid tegevusalasid ei ole brutopalga tabelis?\nsetdiff(lõhe$tegevusala, palk$tegevusala)\n\n[1] \"Tegevusalad kokku\"                                    \n[2] \"Veevarustus; kanalisatsioon, jäätme- ja saastekäitlus\"\n\n# Milliseid brutopalga tabelis olevaid tegevusalasid ei ole palgalõhe tabelis?\nsetdiff(palk$tegevusala, lõhe$tegevusala)\n\n[1] \"Kokku – kõik tegevusalad\"                             \n[2] \"Veevarustus; kanalisatsioon; jäätme- ja saastekäitlus\"\n\n\nNäeme, et kahes tabelis on samad nähtused kas erinevate nimetustega või siis on semikooloni asemel kastatud koma. Muudame väärtuste nimetused nii, et sama nähtus oleks täpselt samamoodi sõnastatud.\n\n# Määrame palgalõhe tabelis tegevusalale semikooloni koma asemele\nlõhe$tegevusala[lõhe$tegevusala == 'Veevarustus; kanalisatsioon, jäätme- ja saastekäitlus'] &lt;- 'Veevarustus; kanalisatsioon; jäätme- ja saastekäitlus'\n# Määrame brutopalga tabelis veerus tegevusala \"Tegevusalad kokku\" seal, \n# kus on pregu on \"Kokku - kõik tegevusalad\"\npalk$tegevusala[palk$tegevusala == 'Kokku – kõik tegevusalad'] &lt;- 'Tegevusalad kokku'\n\nKaks tabelit saame ühendada funktsiooniga merge().\n\npalkLõhe &lt;- merge(\n  palk, lõhe, \n  by.x = c('tegevusala', 'aasta'), # Brutopalga tabeli ühendatavad tunnused\n  by.y = c('tegevusala', 'aasta'), # Palgalõhe tabeli ühendatavad tunnused\n  all.x = TRUE, # Jätame alles kõik brutopalga tabeli read\n  all.y = TRUE) # Jätame alles kõik palgalõhe tabeli read\n# Meie andmetabelites on ühendatavad tunnused sama nimega, \n# seega võime mõned argumendid ära jätta või neid lihtsustada\npalkLõhe &lt;- merge(palk, lõhe, all = TRUE)\nhead(palkLõhe)\n\n                                                    tegevusala aasta kesk.palk\n1 Avalik haldus ja riigikaitse; kohustuslik sotsiaalkindlustus  2008      1061\n2 Avalik haldus ja riigikaitse; kohustuslik sotsiaalkindlustus  2009       981\n3 Avalik haldus ja riigikaitse; kohustuslik sotsiaalkindlustus  2010       955\n4 Avalik haldus ja riigikaitse; kohustuslik sotsiaalkindlustus  2011       988\n5 Avalik haldus ja riigikaitse; kohustuslik sotsiaalkindlustus  2012      1037\n6 Avalik haldus ja riigikaitse; kohustuslik sotsiaalkindlustus  2013      1130\n  kesk.kulu osatööaeg töötajad kesk.maksud mehed.palk naised.palk lõhe.osa\n1      1434       2.6    34776         373         NA          NA       NA\n2      1337       3.6    34693         356         NA          NA       NA\n3      1297       3.4    34935         342         NA          NA       NA\n4      1341       3.2    35034         353        6.2         5.5     10.2\n5      1408       2.9    35138         371        5.8         5.3      9.8\n6      1526       2.6    34552         396        6.4         5.7     12.1\n\n\nÜhendatud tabeli alusel saame varem kahes eraldi tabelis olnud tunnuseid nüüd omavahel võrrelda. Näiteks saame uurida, kuidas on palgalõhe seotud osatööaja, keskmise palga ja tegevusalaga ning kuidas see seos aastate jooksul muutunud on.\n\nggplot(palkLõhe) + \n  aes(x = lõhe.osa, y = osatööaeg, size = kesk.palk, color = aasta) + \n  geom_point(alpha = .5) +\n  facet_wrap(~tegevusala, ncol = 3) +\n  theme_minimal()\n\n\n\n\n\nTabelarvutuse rakendustes ei saa ühendada omavahel terveid tabeleid. Küll aga saame ühele tabelile lisada korraga ühe veeru teisest tabelist nii, et väärtuste määramise aluseks on mingi mõlemas tabelis olev tunnus. Saame selleks kasutada funktsiooni =vlookup().\n\n\n\n\n\nKelleher, J. D., & Tierney, B. (2018). Data science. The MIT Press.\n\n\nWickham, H. (2014). Tidy Data. Journal of Statistical Software, 059(i10). https://ideas.repec.org/a/jss/jstsof/v059i10.html"
  },
  {
    "objectID": "joonised.html#joonistamise-põhimõtted",
    "href": "joonised.html#joonistamise-põhimõtted",
    "title": "7  Joonised",
    "section": "7.1 Joonistamise põhimõtted",
    "text": "7.1 Joonistamise põhimõtted\nAndmete vormistamisel joonistena võiks enamasti järgida alljärgnevaid soovitusi.\n\nLisa joonisele nii vähe kui on võimalk ja nii palju kui on vajalik.\nToo esile see, mis on kõige olulisem.\nEsita kas mingi üldine muster või too välja pisiasjad, aga mitte mõlemaid korraga.\nVeendu, et telgede ulatus ega väärtuste teisendused ei kallutaks seda, mida andmed tegelikult näitavad.\nMitme joonise kõrvutamisel veendu, et telgede ulatused on samad.\nKujuta andmepunktid või muud joonise osised läbipaistvatena, et vältida kattuvusel tekkivat teabekadu.\nÜhenda andmepunktid joontega ainult siis, kui nende järjestusel on mingi tähendus. Nt aegridade korral on näitab joon muutumist ajas.\nVärvid peaksid olema seotud kujutatavate väärtuste tähendusega.\n\nVärvide valikul on mitu põhimõtet, aga muuhulgas on oluline lähtuda tunnuse liigist ja väärtuste tähendusest (vt Crameri et al. (2020)). Üldiselt tuleks jälgida, et\n\nkõik värvid oleksid sama tugevusega (nt kollane on teistest värvidest heledam),\njärjestuse korral peaks värvide järjestus olema loogiline,\nkeskmine väärtus peaks olema selgelt neutraalse värviga eristatud,\nnähtuste vastandamise korral peaks ka värviskaala olema vastanduv.\n\nSageli viidatakse ka viiele omadusele, mis iseloomustavad head joonist (Cairo, 2016):\n\ntõene (põhineb uurimustööl),\nkasulik (rakendatav mingil eesmärgil),\nilus (kutsub vaatama),\navav (võimaldab näha midagi teisest küljest),\nselgitav (pakub uusi teadmisi)."
  },
  {
    "objectID": "joonised.html#jooniste-liigid",
    "href": "joonised.html#jooniste-liigid",
    "title": "7  Joonised",
    "section": "7.2 Jooniste liigid",
    "text": "7.2 Jooniste liigid\nVõimalikke viise jooniste vormistamiseks on lugematul hulgal. Üldiselt võib neid jooniseid eristada aga nelja omaduse alusel:\n\neesmärk (vt allpool),\nmõõtmistase (kvantitatiivsed või kvalitatiivsed tunnused),\nmõõtmed (telgede arv),\nandmete kuju (praktikas tähtsusetu).\n\nKõige otstarbekam on joonise vormistuse valimisel lähtuda andmete visualiseerimise eesmärgist, milleks võib olla kujutada\n\nvõrdlust (nt tulp-, punktjoonis),\nkoostist (nt ring-, pindala-, puujoonis),\nvooge (Sankey joonis),\nmuutust (joon),\nseost (nt hajumisjoonis, seosekaart),\njaotust (nt histogramm, tihedus-, karpjoonis),\nruumilist jaotust (punkt-, koropleetkaart),\nvõrgustikku (võrgustikjoonis).\n\nEnamus liike jooniseid võimaldavad visualiseerida ainult kvantitatiivselt mõõdetud ehk arvtunnuseid. Kvalitatiivseid tunnuseid saab joonistele lisada kas\n\nühele telgedest,\ntekitades iga kvalitatiivse tunnuse väärtuse jaoks eraldi joonise,\nkujundades vastavalt tunnuse väärtustele joonise osiseid, nt punktide suurust, kuju või värvi."
  },
  {
    "objectID": "joonised.html#joonised-r-keeles",
    "href": "joonised.html#joonised-r-keeles",
    "title": "7  Joonised",
    "section": "7.3 Joonised R keeles",
    "text": "7.3 Joonised R keeles\nAlljärgnevates näidetes joonistamise näitlikustamieks võrdleme maailma riike.\n\nlibrary('magrittr') # Laadime laienduse toru kasutamiseks\nriigid &lt;- read.csv('andmed/countries.csv')\nnames(riigid) %&lt;&gt;% strsplit('\\\\.') %&gt;% sapply(`[`, 1) # Jätame veerunimetustes alles vaid enne punkti oleva\n\nR keeles saab tekitada lihtsaid jooniseid nagu punkt- ja ringjoonis nt sageduste kujutamiseks.\n\ntable(riigid$region) %&gt;% barplot\n\n\n\ntable(riigid$region) %&gt;% pie\n\n\n\n\nSamuti tuleb R keelega kaasa mitu funktsiooni väärtuste hajumise kujutamiseks, sh histogramm ning hajumis- ja karpjoonis. Need funktsioonid ei nõua eriti palju tähemärke, mistõttu on neid mugav kasutada andmete uurimiseks.\n\nhist(riigid$arable)\n\n\n\nplot(gdp ~ phones, riigid)\n\n\n\nboxplot(gdp ~ region, riigid)\n\n\n\n\nEelnevad R keelega kaasas olevad funktsioonid on mõnevõrra piiratud ja igasuguste osiste muutmine joonistel on enamasti keerukas ja kohmakas. Seetõttu on kujunenud tavapäraseks, et joonised tekitatakse R keeles hoopis laienduses ggplot2 olevate funktsioonidega. Need pakuvad andmete joonistamiseks peaaegu piiramatult võimalusi.\nNt on ggplot2 kasutades lihtne kujutada korraga joonisel mitut tunnust.\n\nlibrary('ggplot2')\nggplot(riigid) + \n  aes(x = gdp, y = phones, size = population, color = literacy) + \n  geom_point() + \n  facet_wrap(~region) + \n  theme_light()\n\nWarning: Removed 4 rows containing missing values (`geom_point()`).\n\n\n\n\n\nAndmeid saab kujutada väga erinevat liiki joonistel, kuvada jooniseid üksteise peal ja muuta kõiki joonise osiseid.\n\nlibrary('ggplot2')\nggplot(riigid) + \n  aes(x = region, y = agriculture*100, color = arable) + \n  coord_flip() + \n  ylim(c(0,100)) +\n  geom_boxplot() + \n  geom_jitter(aes(size = population/1e6)) + \n  labs(title = \"Põllumajandus\", \n       subtitle = \"Hõive põllumajanduses erineb piirkonniti ja riigiti märkimisväärselt\", \n       x = \"Piirkond\", y = \"Hõive põllumajanduses, %\", \n       size = \"Rahvaarv, mln\", \n       color = \"Põllumajandusmaa\\nosakaal, %\") + \n  scale_color_gradient(low = 'steelblue', high = 'tomato') + \n  theme_light()\n\nWarning: Removed 15 rows containing non-finite values (`stat_boxplot()`).\n\n\nWarning: The following aesthetics were dropped during statistical transformation: colour\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\n\n\nWarning: Removed 15 rows containing missing values (`geom_point()`).\n\n\n\n\n\nLaienduse ggplot2 kasutamise kohta on internetis hulgaliselt selgitusi ja näiteid. Nt võib selle abil joonistamisel võtta kõrvale juhendi.\n\n\n\n\n\nCairo, A. (2016). The truthful art: data, charts, and maps for communication. New Riders.\n\n\nCrameri, F., Shephard, G. E., & Heron, P. J. (2020). The misuse of colour in science communication. Nature Communications, 11(1), 5444. https://doi.org/10.1038/s41467-020-19160-7\n\n\nSaltz, J. S., & Stanton, J. M. (2017). An introduction to data science. SAGE Publications, Inc."
  },
  {
    "objectID": "tunnused.html#mõõtmistasemed",
    "href": "tunnused.html#mõõtmistasemed",
    "title": "8  Tunnuste liigid",
    "section": "8.1 Mõõtmistasemed",
    "text": "8.1 Mõõtmistasemed\nKahte nähtust saab võrrelda mitmel viisl: kas üks on teisest suurem, kumb on teisest suurem, kui palju on üks teistest suurem. Vastavalt sellele saab nähtusi ka mitmel viisil mõõta. Kõige üldisemalt saame eristada nelja mõõtmistaset1, millele vastavad mõõtmisskaalad alates kõige üldistavamast:1 Eesti keeles on mõõtmistasemete olemust ilmekalt selgitanud Sauga (2020).\n\nbinaarskaala (kuni kaks järjestamata väärtust),\nnimiskaala (järjestamata väärtused),\njärjestusskala (järjestatud väärtused),\narvskaala (väärtused, mille erinevusi saame arvutada).\n\nSealjuures tuleb nähtuste mõõtmisel võtta arvesse, et mida üldistatum on mõõtmistase, seda vähem teavet see sisaldab. Seega saame väärtusi teisendada alati üldisemale mõõtmistasemele, aga mitte vähem üldisele.\nMõõtmistasemete eristamiseks on veel mitu viisi.\n\nKvantitatiivse ja kvalitatiivse mõõtmistaseme eristamine seisneb selles, kas mõõtmise tulemuseks on arvud. Kvantitatiivse mõõtmise korral on väärtused esitatavad tähenduslikult arvudena, kvalitatiivne mõõtmistase hõlmab enamasti aga arve mitte sisaldavaid väärtusi ehk sõnu või lauseid.\nDiskreetne ja pidev (discrete, continuous) mõõtmine kehtivad ainult arvskaalal ja nende erisus seisneb intervallide vahedes. Diskreetsel mõõtmisel on tulemuseks ainult täisarvud, mis saadakse enamasti millegi loendamisel. Pideval mõõtmisel võib tulemuseks olla mistahes arv.\nIntervall- ja suhteskaala (interval, ratio) on mõlemad arvskaala alaliigid, mille erinevus tuleneb väärtuse 0 tähendusest. Suhteskaalal tähendab väärtus 0 mõõdetava nähtuse puudumist, intervallskaalal aga mitte. Seetõttu võib intervallskaalal mõõdetud väärtusi ainult liita ja lahutada, suhteskaalal aga ka korrutada ja jagada (Stevens, 1946)2.\n\n2 Nt 20 eurot on kaks korda rohkem kui 10 eurot, aga 20 kraadi ei ole kaks korda soojem kui 10 kraadi.Eelnevalt selgitatud mõõtmise tasemed saab kokku võtta alloleva joonisega\n\n\n\n\ngraph\n    subgraph Kvalitatiivne\n        Binaarskaala--&gt;Nimiskaala\n        Nimiskaala--&gt;Järjestusskaala\n    end\n    subgraph Kvantitatiivne\n        Järjestusskaala--&gt;Arvskaala\n    end\n        subgraph \"Väärtuse 0 tähendus\"\n            Arvskaala--&gt;|0 ei ole puudumine|Intervallskaala\n            Arvskaala--&gt;|0 on puudumine|Suhteskaala\n        end\n        subgraph \"Intervallide vahed\"\n            Arvskaala--&gt;|Täisarvud|Diskreetne\n            Arvskaala--&gt;|Kõik arvud|Pidev\n        end"
  },
  {
    "objectID": "tunnused.html#tunnuste-liigid",
    "href": "tunnused.html#tunnuste-liigid",
    "title": "8  Tunnuste liigid",
    "section": "8.2 Tunnuste liigid",
    "text": "8.2 Tunnuste liigid\nStatistikarakendused ja R keel määravad andmete sisestamisel igale andmetabeli veerule tunnuse liigi. See tunnuse liik on otseselt seotud mõõtmistasemega. Kasutades andmetöötluseks tarkvara, mis ei ole tabelarvutus, on oluline eristada käesoleva peatüki alguses esitatud nelja üldist mõõtmistaset. Diskreetsete ja pideva skaala eristamine ei ole üldjuhul tähtis ja intervall- ja suhteskaalat tarkvara ei erista.\nKui salvestada R töölaua objekti kas või üksik väärtus, siis määratakse selle liigiks kas numeric või character, vastavalt sellele, kas tegemist on arvuga või mitte. Kui väärtus pärineb tõeväärtusest (Peatükk 5), siis määratakse selle liigiks logical.\n\n\n\n\n\n\n\n\n\nEelistus\nMõõtmistase\nTunnuse liik R keeles\nSelgitus\n\n\n\n\n1.\nBinaarskaala\nLogical\nAinult väärtused FALSE või TRUE\n\n\n2.\nArvskaala\nNumeric\nAinult arvud\n\n\n3.\nJärjestusskaala\nFactor\nÜkskõik mis väärtused järjestatakse\n\n\n4.\nNimiskaala\nCharacter\nÜkskõik mis väärtused\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nVäärtustele tunnuse liigi määramisel tuleks eelistada kõige lihtsamat tunnuse liiki. Sel juhul saab enamasti vastava tunnusega kõige enam erinevaid tehteid teha.\n\n\nTunnuste liike on tarkvaral tähtis eristada seetõttu, et sel juhul\n\nilmnevad lihtsamini puudulikud väärtused veergudes3;\ntarkvara määrab ise tunnuse jaoks vaikimisi sobiva funktsiooni rakendamise või andmete kuvamise viisi;\ntarkvara saab optimeerida arvutuskäiku nii, et see toimuks võimalikult kiiresti.\n\n\n\n\n3 Nt kui arvude veergu on sattunud mõni täht, siis saab vea tuvastada varakult tunnuse tüübi alusel ja ei ole vaja hiljem ilmneva vea põhjust mõnikod mitu tundi otsida.\n\nSauga, A. (2020). Statistika õpik majanduseriala üliõpilastele (2nd ed.). TTÜ kirjastus.\n\n\nStevens, S. S. (1946). On the Theory of Scales of Measurement. Science, 103(2684), 677–680. https://doi.org/10.1126/science.103.2684.677"
  },
  {
    "objectID": "valim.html",
    "href": "valim.html",
    "title": "9  Valim ja kogum",
    "section": "",
    "text": "Sageli on meil andmestik, mis hõlmab ainult väikest osa kõikidest vaatlustest, mida soovime kirjeldada. Selline olukord tekib tihti siis, kui andmed on saadud küsitluse teel ja vastuseid ei ole kogutud kõikidelt vastajatelt.\n\n\n\n\n\n\nImportant\n\n\n\nKui andmetes on ainult osa vaatlustest, mida soovime kirjeldada, siis on tegemist valimiga (sample). Kõik vaatlused, mida soovime kirjeldada, moodustavad kogumi (population).\n\n\nKogumist valimi võtmiseks on palju viise, aga enamasti valitakse kogumist vaatlused võimalikult juhuslikult. Sellisel juhul esindab piisavalt suur valim kogumit ja nii saame teha valimi alusel järeldusi kogumi kohta ehk kirjeldada kogumit isegi siis, kui meil ei ole selle kohta täielikku teadmist.\n\n\n\n\n\n\nWarning\n\n\n\nValim peaks võimalikult täpselt peegeldama kogumit. Seda saab saavutada juhuvalik. Juhuslik valik ei tähenda alati mitmekesisust. Kui kogum on ühetaoline, siis peaks olema ühetaoline ka valim ja vastupidi.\n\n\nIsegi juhul, kui meil on andmed kõikide vaatluste kohta, mida soovime kirjeldada, siis võib olla kasulik mõelda ka kogumist kui valimist. Mõnikord saame nii teha üldistusi ka nende aegade kohta, mis jäävad väljapoole tehtud mõõtmisi. Samuti saame nii olla kindlamad, et järeldusi mõjutavad vähem mõõtmisvead.\nValimi kasutamine ongi sageli põhjuseks, miks me ei ole päris kindlad statistilistes mõõtmistes. Kui meil on ainult osa kirjeldatavast kogumist, siis isegi juhul, kui see osa valiti juhuslikult, ei saa me kunagi täiesti kindlad olla, et valim peegeldab kogumit täpselt. See valim võis ka juhuslikult kujuneda nii, et see esindab ainult ühte äärmust kogumist1. Sellisest ebakindlusest tulenevalt nimetatakse statistikas valimi alusel arvutatud väärtusi hinnanguteks (Peatükk 21).1 Kui soovime kirjeldada erakondade toetust, siis võivad meie valimisse ka juhuslikul teel sattuda peaaegu ainult ühe erakonna toetajad, mis ei võimalda teha õigeid järeldusi."
  },
  {
    "objectID": "valikunihe.html",
    "href": "valikunihe.html",
    "title": "10  Valikunihe",
    "section": "",
    "text": "Valikunihe (selection bias) iseloomustab olukorda, kus meil ei ole uuritava nähtuse kohta täielikke andmeid ja olemasolevad andmed ei ole esinduslikud, vaid on mingis suunas kallutatud. Andmeanalüüsis tekib valikunihe enamasti siis, kui valim ei ole valitud kogumist juhuslikult ja esindab ainult teatud osa valimist. Sellisel juhul ei ole tehtud järeldused kogumi suhtes õiged, sest need iseloomustavad ainult seda kogumi osa, mis sattus valimisse.\nValikunihe ei mõjuta järeldusi aga mitte alati. Kui nihet põhjustav tunnus ei ole kuidagi seotud tunnusega, mille alusel teeme järeldused, siis ei mõjuta valikunihe ka järeldusi.\nTingimusi valikunihke tekkimiseks on erinevaid:\n\nmittejuhuslik valim ehk valiminihe (sample bias):\n\nvaatluste määramine valimisse,\nvaatluste poolne valik valimisse sattumiseks vabatahtliku valimi korral,\nvalimist välja langemine;\n\nandmete kogumine või analüüsi kordamine niikaua, kuni saadakse soovitud tulemus;\nsobivate vaatluste valimine;\nandmekogumise ajastus või ajaline valik analüüsil.\n\nValikunihe ei teki mitte ainult andmete analüüsimisel. Ainult olemasoleva teadmise alusel järelduste tegemine võib viia nihkega hinnanguni misiganes olukorras. Pea alati meeles ka seda, mida sa ei näe!"
  },
  {
    "objectID": "taasvalik.html",
    "href": "taasvalik.html",
    "title": "11  Taasvalik",
    "section": "",
    "text": "Valimi saame siis, kui valime kogumist enamasti juhuslikult mingi osa vaatlusi (Peatükk 9). Taasvalik on põhimõtteliselt sama tegevus, aga selle käigus võtame valimeid tavaliselt hoopis valimist endast ja palju kordi.\n\n\n\n\n\n\nImportant\n\n\n\nTaasvalik (resampling) tähendab korduvat valimite võtmist andmetest, mis võivad ise esindada valimit. Selle eesmärk on hinnata andmete alusel tehtud hinnangute kindlust, uurides hinnangute hajuvust erinevate valimite korral.\n\n\nTaasvaliku rakendamiseks ehk andmetes valimite võtmiseks on palju erinevaid viise:\n\nkorduvvalik (bootstrapping),\npermutatsioon (permutation),\nlõikemeetod (jackknife),\nristvalideerimine (cross-validation),\nerinevad Monte Carlo meetodid.\n\nKorduvvaliku käigus võetakse andmetest juhuslikult vaatlusi selliselt, et üks ja sama vaatlus võib korduvvaliku valimis esineda rohkem kui ühe korra. Sealjuures on igas valimis sama palju vaatlusi kui andmetes. Sobivaks valimite arvuks peetakse enamasti vähemalt 1000 valimit. Sarnaselt teistele taasvaliku meetoditele ei sea (mitteparameetriline) korduvvalik eeldusi andmete jaotusele, kuid eeldab, et andmed esindavad piisavalt täpselt kogumit, mille kohta soovitakse teha andmete alusel järeldusi. Taasvalikut kasutatakse enamasti hinnangute valimijaotuste moodustamiseks.\n\n\n\n\n\n\nWarning\n\n\n\nTaasvaliku alusel leitud hinnangud parameetri kohta kehtivad juhul, kui andmetes olev valim peegeldab kogumit piisavalt täpselt ehk on kogumi suhtes piisavalt esinduslik.\n\n\nKui arvutame iga taasvaliku teel saadud valimi alusel mõne parameetri väärtuse, siis need parmeetri väärtused koonduvad enamasti mingi konkreetse väärtuse ümber ja järgivad mingit jaotust. Sellist paljude valimite alusel leitud parameetri jaotust nimetatakse valimijaotuseks1.1 Nt tsentraalse piirteoreemi järgi järgib aritmeetilise keskmise valimijaotus alati normaaljaotust"
  },
  {
    "objectID": "seosed.html",
    "href": "seosed.html",
    "title": "12  Seosed",
    "section": "",
    "text": "Sageli huvitab meid üksikute tunnuste hajuvus või muutumine ajas või ruumis. Kõige huvitavamaid asjaolud ilmnevad enamasti aga siis, kui uurime, kuidas kahe või enama tunnuse väärtused teineteisest sõltuvad. Sõltuvusi tunnuste vahel saame tuvastada siis, kui uurime nende väärtusi objektide (nt isik, asutus, ettevõte) lõikes. Seoseid tunnuste vahel saab statistiliselt kirjeldada kolmel viisil:\n\nsuund ehk kas seos on positiivne või negatiivne;\ntugevus ehk mil määral sõltuvad ühe tunnuse väärtused teise tunnuse väärtustest;\nstatistiline olulisus ehk kas seos on juhuslik ja tuvastav ainult valimis või ka kogumile üldistatav.`\n\nLisaks saame enamasti ainult teoreetiliselt kirjeldada ka seoste põhjuslikku vahekorda."
  },
  {
    "objectID": "põhjuslikkus.html",
    "href": "põhjuslikkus.html",
    "title": "13  Põhjuslikkus",
    "section": "",
    "text": "Paljud statistilised protseduurid võimaldavad määrata, kas ja mil määral on tunnused üksteisega seotud. Tunnuste vahelise seose tugevuse mõõtmiseks on palju erinevaid arvutuskäike. Ükskõik kui tugev leitud seos aga on, ei saa me ühegi statistilise arvutusega kindlaks teha, kas ja mil viisil üks nähtus teist mõjutab. Üldiselt saame sekundaarandmeid kasutades\n\noletada, kust otsida põhjuslikke seoseid või\nkasutada teoreetilisi põhjendusi statistika abil leitud seostele põhjuslikkuse omistamiseks.\n\n\n\n\n\n\n\nWarning\n\n\n\nMitte ükski statistiline arvutus ei näita seose põhjuslikkust. Põhjuslike seoste näitamiseks on vajalikud juhusliku katse tingimustes kogutud andmed.\n\n\nPõhjuslikke seoseid saame näidata ainult eksperimendi tingimustes kogutud andmetega. Teadustöös on tunnustatud viis põhjuslike seoste määratlemiseks juhuslikustatud katse (randomized controlled trial ehk RCT). Selle käigus jagatakse uuritavad objektid juhuslikult katse- ja kontrollrühma nii, et ainus erinevus nende vahel on põhjusliku tunnusena käsitletav uuritav nähtus. Nii saab igasugune erinevus mingis tagajärgses tunnuses nende rühmade vahel tuleneda ainult sellest uuritavast nähtusest1. Kui loodusteadustes on juhuslikud katsed tavalised, siis majandus- ja ühiskonnateadustes on need enamasti kulukad või eetilistel põhjustel sobimatud2.1 Nt kui kahe rühma ainus erinevus seisneb ravimi manustamises, siis igasugune hilisem erinevus nende rühmade vahel on seletatav ravimi mõjuga.2 Siiski on mitmes riigis määratud juhuslikult kodanikupalga saajad, et uurida selle mõju inimeste käitumisele.\n\n\n\n\n\n\nImportant\n\n\n\nJuhuslikustatud katse käigus määratakse uuritavad objektid juhuslkult katse- ja kontrollrühma. Kuna seetõttu on rühmade ainus erinevus katserühmal rakendatav tegevus, siis on igasugune hilisem erinevus rühmade vahel seletatav ainult selle tegevuse mõjuga.\n\n\nÜks nähtus võib otseselt mõjutada teist (\\(X \\rightarrow Y\\)). Lisaks sellele on veel mitu seletust statistilise protseduuri abil leitud seostele tunnuste vahel:\n\nseos on vastastikkune \\[X \\leftrightarrow Y,\\]\nmingi kolmas nähtus mõjutab mõlemat uuritavat nähtust ja viimaste vahel vastastikkune mõju puudub: \\[\\displaylines{Z \\rightarrow X \\\\ Z \\rightarrow Y},\\]\nmingi kolmas nähtus vahendab ühe nähtuse mõju teisele ja mõju uuritavate nähtuste vahel on kaudne: \\[X \\rightarrow Z \\rightarrow Y,\\]\nkuigi seda esineb harva, siis seos võib olla kokkusattumus3: \\[X \\cancel{\\rightarrow} Y.\\]\n\n\n\n3 IDEE: Tõstame viina hinda, et vähendada õpetajate puudust koolides"
  },
  {
    "objectID": "tinglikkus.html",
    "href": "tinglikkus.html",
    "title": "14  Tinglikkus",
    "section": "",
    "text": "On olemas väga vähe nähtusi, mis ei ole mõjutatud ühegi teise nähtuse poolt ja mille hajuvus on seega täiesti juhuslik. Peaaegu iga tunnuse väärtuste hajuvust saame seletada vähemalt mingil määral mõne teiste tunnuste väärtustega. Sageli kipuvad ühe tunnuse väärtused sõltuvalt teise tunnuse väärtustes olema suuremad või väiksemad. Sellisel juhul saame öelda, et tunnuse väärtused on tingitud (conditional) mõnest teisest tunnusest ja seega jaotuvad ka vastavalt tinglikule jaotusele (conditional distribution). Kuna peaaegu kõik nähtused sõltuvad teistest nähtustest, siis võib pidada kõiki jaotusi tinglikeks (Wild, 2006). Seda tõsiasja võibki nimetada tunnuste tinglikkuseks. Sealjuures ei ole seoste põhjuslikkus oluline.\nMõeldes tunnuste hajuvusest kui millesti, mis on tingitud ühest või enamast teistest tunnustest, on lihtsam mõtestada seoseid tunnuste vahel. Tinglikkuse ideed rakendades vaatleme, kas ja mil viisil ühe tunnuse väärtused erinevad vastavalt mõne teise tunnuse väärtustele. Seda tegevust nimetatakse sageli ka kihitamiseks (stratification).\n\n\n\n\n\n\nImportant\n\n\n\nKihitamise käigus uurime, kuidas ühe tunnuse väärtused erinevad teise tunnuse kihtide lõikes.\n\n\nKihitamist saame kasutada mistahes tüüpi tunnuste korral, kuigi kihtide kasutamine eeldab, et üks tunnustest on rühmitatud väikesel arvul väärtustesse.\n\nTinglikkus võib hõlmata rohkem kui kahte nähtust. Sageli ilmnevad seosed tunnuste vahel alles siis, kui kihitame rohkem kui kahte tunnust korraga. See on kasulik näiteks siis, kui esineb interaktsioon.\n\n\n\n\n\n\nImportant\n\n\n\nInteraktsioon iseloomustab olukorda, kus kahe tunnuse vaheline seos muutub märkimisväärselt, kui võtame arvesse ka mõnda kolmandat tunnust.\n\n\n\n\n\n\n\nWild, C. (2006). The concept of distribution. Statistics Education Research Journal, 5(2), 10–26."
  },
  {
    "objectID": "klassifitseerimine.html",
    "href": "klassifitseerimine.html",
    "title": "15  Klassifitseerimine",
    "section": "",
    "text": "Üldises mõttes on klassifitseerimine (classification) vaatluste jaotamine klassidesse. Selle käigus määratakse vaatlusele kõige sobivam klass lähtuvalt mudelist, mida võib nimetada ka klassifitseerijaks (classifier). Selle mudeli aluseks sisendtunnus(ed) ja väljundtunnus, mis sisaldab klasse. Seega saab seda mudelit kasutada ka klassi prognoosimiseks ehk vastava nimitunnuse väärtuse määramiseks, võttes aluseks sisendtunnuste väärtused. Klassifitseerimise praktiline väärtus seisnebki eelkõige klassi määramisel vaatlustele, mille korral see teada ei ole.\n\n\n\n\n\n\nImportant\n\n\n\nAndmeanalüüsis on klass (class) sellise nimitunnuse väärtus, mis prognoosimiseks mõeldud mudelis on määratud väljundtunnuseks. Klassifitseerimisel on väljundtunnuse klasse enamasti rohkem kui kaks, aga ka klassid võivad moodustuda ka binaartunnuse alusel.\n\n\nKõige sobiva klassi määramiseks on niisiis vaja teada vastava nimitunnuse väärtusi vähemalt osade vaatluste kohta. Nii erineb klassifitseerimine klasterdamisest, mille korral vaatlused jaotatakse klastritesse ainult sisendtunnuse väärtuste alusel.\nKlassifitseerimine ei ole konkreetne meetod, vaid üldnimetus meetoditele, mida saab kasutada vaatluste klassifitseerimiseks jaotamiseks. Sealjuures on asjakohased meetodid\n\nlähinaabrid (Peatükk 25),\notsusepuu (Peatükk 24) sh juhumets,\ntugivektor,\nlogistiline (Peatükk 23) ja multinomiaalne regressioon.\ntehisnärvivõrgud.\n\nKlassifitseerimise täpsust saab hinnata veatabeli (Peatükk 23) ja sellega seotud mõõdikute alusel."
  },
  {
    "objectID": "kaugus.html",
    "href": "kaugus.html",
    "title": "16  Statistiline kaugus",
    "section": "",
    "text": "Mitmete meetodite puhul on klassifitseerimise ja klasterdamise aluseks erinevused vaatluste vahel. Sellised meetodid on nt lähinaabrid ja hierarhiline klasterdamine, aga ka k-keskmised. Sellisel juhul saab vaatluste erinevusi teineteisest mõõta statistilise kauguse alusel, eeldades et mingite tunnuste väärtustel alusel lähestikku asuvad vaatlusel on sarnased.\n\n\n\n\n\n\nImportant\n\n\n\nStatistiline kaugus (statistical distance) iseloomustab erinevusi vaatluste vahel. Selle aluseks on vaatluste kaugus teineteisest mingite tunnuste väärtuste erinevuse alusel.\n\n\nKaugust saab mõõta korraga kahe vaatluse vahel. Seega arvutatakse kaugused paariviisiliselt kõikide vaatluste omavahelise võrdlemise teel. Need kaugused esitatakse kauguste maatriksina (distance matrix), milles iga rida ja veerg esindab ühte vaatlust ning lahtrites on seega kaugused kõikide vaatluste vahel1.1 See on sarnane linnade vaheliste kauguste tabelitele, ainult et statistilise kauguse aluseks ei ole punkti paiknemine mitte füüsilises, vaid tunnuste alusel moodustunud ruumis.\nArvutuskäike kauguse mõõtmiseks on mitmeid, aga kõige sagedamini kasutatakse Eukleidilist kaugust, mille aluseks on Eukleidese teoreem. Kui meil on vaatlused \\(i\\) ja \\(j\\), siis tunnuste \\(x\\) ja \\(y\\) alusel leitakse nende vaheline kaugus \\(d(i,j)\\) alljärgnevalt: \\[d_E(i,j) = \\sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}.\\]\nMõnikord kasutatakse ka veidi lihtsamalt Manhattani kaugust: \\[d_M(i,j) = |x_i - x_j| + |y_i - y_j|.\\]\nTunnuste ruumi saame kujutada hajuvusjoonisel.\n\n\n\n\n\nJoonis 16.1: Kahemõõtmeline tunnuste ruum\n\n\n\n\nR keeles saame kaugusi leida funktsiooni dist() abil, mille argument method võimaldab valida erinevate kauguste vahel.\n\ndist(autod, method = 'euclidean')\n\n                  Hornet 4 Drive Hornet Sportabout    Valiant Duster 360\nHornet Sportabout      2.7093588                                        \nValiant                3.3090822         0.6003332                      \nDuster 360             7.1088695         4.4019200  3.8015918           \nMerc 240D              3.0001042         5.7054798  6.3057831 10.1071460\nMerc 230               1.4015081         4.1102433  4.7102123  8.5103701\nMerc 280               2.2114758         0.5000000  1.1001818  4.9017242\n                   Merc 240D   Merc 230\nHornet Sportabout                      \nValiant                                \nDuster 360                             \nMerc 240D                              \nMerc 230           1.6004999           \nMerc 280           5.2060061  3.6116617\n\n\nNii tabelist kui ka jooniselt Joonis 23.1 näeme, et mudelile Hornet 4 Drive on vaadeldavate tunnuste alusel kõige lähemal ja seega kõige sarnasem mudel Merc 230.\nKaugus oleneb tunnuste mõõteskaaladest ja väärtuse hajuvusest. Tunnused, mille väärtused on suuremad ja mis hajuvad rohkem, mõjutavad suuremal määral ka kaugust kahe vaatluse vahel. Seetõttu viiakse enne kauguste arvutamist tunnused enamasti samale skaalale standardiseerimise teel."
  },
  {
    "objectID": "klasterdamine.html#klastrite-tõlgendamine",
    "href": "klasterdamine.html#klastrite-tõlgendamine",
    "title": "17  Klasterdamine",
    "section": "17.1 Klastrite tõlgendamine",
    "text": "17.1 Klastrite tõlgendamine\nKuna klasterdamine lähtub ainult arvskaalal olevate tunnuste väärtusest, siis ei ole igal klastril konkreetset nimetust nii nagu klassifitseerimise korral. Klastritele sisulise tähenduse andmiseks peame klastreid võrdlema mingite tunnuste väärtuste alusel.\nUurime järgnevalt võimalusi klastrite sisuliseks tõlgendamiseks maailma riikide klasterdamise näitel. Enne klasterdamist peaksime eemaldama puuduvate väärtustega riigid ja standardiseerima tunnuste väärtused. Arvutuste lihtsustamiseks võime sisestada arvtunnused eraldi andmetabelisse.\n\nlibrary('magrittr')\nriigid &lt;- read.csv('andmed/countries.csv')\nrownames(riigid) &lt;- riigid$country\nriigid %&lt;&gt;% na.omit\n# Eralda arvtunnused\narvtunnused &lt;- riigid[, sapply(riigid, is.numeric)]\narvtunnused %&lt;&gt;% scale\n# Määra klastrid\nset.seed(0)\nkkesk &lt;- kmeans(arvtunnused, centers = 5, nstart = 50)\nklastrid &lt;- kkesk$cluster\n\nKõige lihtsam on klastreid arvtunnuste alusel kujutada paariviisilistel hajuvusjoonistel.\n\npairs(arvtunnused, cex = .5, col = klastrid)\n\n\n\n\nKlasterdamise tulemuse esitamiseks võimalikult paljude arvtunnuste lõikes korraga saame kujutada vaatlusi ka kahe peakomponendi alusel hajuvusjoonisel. Klastreid saab kujutada esitades vaatlused klastrile vastava värvi või kujundiga.\n\nlibrary('factoextra')\nfviz_pca_biplot(prcomp(arvtunnused), habillage = klastrid)\n\n\n\n\nSamuti saab koondada kõik vaatlusted klastri alusel ja võrrelda klastrite keskmisi tunnuste lõikes. Keskmise asemel võime kasutada ka mõnda muud mõõdikut. Klastrite kaupa saame andmetabeli kokku võtta, kasutades funktsiooni aggregate().\n\naggregate(arvtunnused, list(klaster = klastrid), mean)\n\n  klaster  population        area netmigration        gdp   literacy     phones\n1       1 -0.05681084 -0.08228393   0.06658805 -0.7939203 -1.4828453 -0.9367697\n2       2 -0.13543341 -0.14740112  -0.46515318 -0.3627625  0.3714034 -0.2207414\n3       3  9.27230705  3.01939409  -0.03759815 -0.5455107 -0.3580826 -0.2826662\n4       4 -0.15272107 -0.30138109   0.79695837  1.4225060  0.7134170  1.2690521\n5       5  0.81818752  5.18629135   0.62926516  1.2882190  0.6900443  1.3269050\n       arable  agriculture\n1 -0.04109864  1.278406603\n2 -0.04089891 -0.196382277\n3  1.52065165  0.007934873\n4  0.10227552 -0.832796324\n5 -0.40620413 -0.755605091\n\n\nMõnevõrra ilmekamalt saame klastrite keskmisi võrrelda seosekaardil.\n\naggregate(arvtunnused, list(klaster = klastrid), mean)[-1] %&gt;% t %&gt;% heatmap\n\n\n\n\nKlastreid aitab kirjeldada ka otsusepuu (Peatükk 24), milles klaster on väljundtunnus ja klastreid kirjeldavad tunnused on sisendtunnusteks. Otsusesõlmede tingimused on sisukamad, kui valime sisendtunnusteks väärtused standardiseerimata kujul.\n\nlibrary('rpart')\nlibrary('rpart.plot')\notsusepuu &lt;- rpart(as.character(klastrid) ~ ., riigid[, -1])\nrpart.plot(otsusepuu)\n\n\n\n\nKui meie andmetes on vaatlustel mingi klass, siis saame uurida ka seda, kas ja kui hästi langeb see kokku leitud klastritega.\n\ntable(klastrid, riigid$region)\n\n        \nklastrid Africa Asia Eastern Europe North America Oceania South America\n       1     35   10              0             0       2             1\n       2     19   27              8             0       7            33\n       3      0    2              0             0       0             0\n       4      0   12              4             1       2             7\n       5      0    1              0             2       1             1\n        \nklastrid Western Europe\n       1              0\n       2              0\n       3              0\n       4             21\n       5              0\n\n\nVajadusel võime anda igale klastrile ka numbri asemel nimetuse lähtudes eelnevast klastrite võrdlustest. Selle nimetuse saab määrata andmetabelisse igale vaatlusele edasiseks analüüsiks.\n\nnimed &lt;- c('Arenguriigid', 'Arenevad riigid', 'Põllumajandusmaad', 'Arenenud riigid', 'Suured riigid')\nriigid$klaster &lt;- nimed[klastrid]\nstr(riigid)\n\n'data.frame':   196 obs. of  11 variables:\n $ country     : chr  \"Afghanistan\" \"Albania\" \"Algeria\" \"Angola\" ...\n $ region      : chr  \"Asia\" \"Eastern Europe\" \"Africa\" \"Africa\" ...\n $ population  : int  31056997 3581655 32930091 12127071 13477 69108 39921833 2976372 71891 20264082 ...\n $ area        : int  647500 28748 2381740 1246700 102 443 2766890 29800 193 7686850 ...\n $ netmigration: num  23.06 -4.93 -0.39 0 10.76 ...\n $ gdp         : int  700 4500 6000 1900 8600 11000 11200 3500 28000 29000 ...\n $ literacy    : num  36 86.5 70 42 95 89 97.1 98.6 97 100 ...\n $ phones      : num  3.2 71.2 78.1 7.8 460 ...\n $ arable      : num  12.13 21.09 3.22 2.41 0 ...\n $ agriculture : num  0.38 0.232 0.101 0.096 0.04 0.038 0.095 0.239 0.004 0.038 ...\n $ klaster     : chr  \"Arenguriigid\" \"Arenevad riigid\" \"Arenevad riigid\" \"Arenguriigid\" ...\n - attr(*, \"na.action\")= 'omit' Named int [1:31] 4 5 26 48 53 59 67 75 79 81 ...\n  ..- attr(*, \"names\")= chr [1:31] \"American Samoa\" \"Andorra\" \"Bosnia & Herzegovina\" \"Cook Islands\" ..."
  },
  {
    "objectID": "mõõtmevähendus.html",
    "href": "mõõtmevähendus.html",
    "title": "18  Mõõtmevähendus",
    "section": "",
    "text": "Andmed on enamasti paigutatud kahemõõtmelistesse tabelitesse, kus vaatlused on ridades ja tunnused veergudes. Sellist tabelit võib käsitleda maatriksina, kus iga rida ja veerg on omaette arvude hulk ehk vektor. Mõõtmete vähendamine tähendab nende vektorite koondamist, mille tulemusel ridade või veergude arv andmetabelis väheneb. Selle tulemusel tekivad uued vaatlused või tunnused. Need esindavad algseid vektoreid, sest mõõtmevähenduse käigus säilitatakse eelkõige meile huvipakkuv osa hajuvusest andmetes.\n\n\n\n\n\n\nImportant\n\n\n\nMõõtmevähenduse (dimensionality reduction) käigus koondatakse hulk vaatlusi või tunnuseid väiksemasse arvu vaatlustesse või tunnustesse nii, et säilib kõige asjakohasem osa nende tunnuste hajuvusest.\n\n\nPõhjused mõõtmete vähendamiseks on seotud eelkõige andmete kirjeldamise või teiste protseduuride rakendamisega. Mõõtmete vähendamine võimaldab\n\nvalida paljude tunnuste seast välja ainult asjakohasemad;\nkoondada mitme tunnuse hajuvus ühte tunnusesse;\nvähendada vaatluste omavahelisi kaugusi tunnuste arvu vähendamise teel, et kaugused oleksid sisukamad;\nklasterdada ehk jagada vaatlused või tunnused sisulistesse rühmadesse;\nkõrvaldada tunnuste hajuvusest juhuslikku müra;\nlihtsustada andmemaatriksit ja seeläbi kiirendada arvutusi;\nkujutada üheaegselt mitut mõõdet kahemõõtmelisel joonisel.\n\nLisaks vaatluste vähendamist võimaldavale klasterdamisele (Peatükk 17) võib esitada ka meetodid, mille abil saab kokku võtta tunnuseid:\n\npeakomponentide analüüs (Peatükk 28) ja\nfaktoranalüüs (Peatükk 29)."
  },
  {
    "objectID": "korrelatsioon.html",
    "href": "korrelatsioon.html",
    "title": "19  Korrelatsioon",
    "section": "",
    "text": "Korrelatsioonanalüüs on kõige sagedamini kasutatav mõõdik seose hindamiseks kahe arvtunnuse või harvemini järjestustunnuse vahel. Kui ühe tunnuse väärtuse suurenedes kipuvad teise tunnuse väärtused keskmiselt suurenema või vähenema, siis on nende tunnuste vahel korrelatsioon.\nSelle korrelatsiooni suuna ja tugevuse saab arvutada ja esitada korrelatsioonikoefitsiendina. Kuigi selleks on erinevaid arvutuskäike, siis enamasti kasutatakse Pearsoni korrelatsioonikoefitsienti ja seda võib eeldada ka juhul, kui täpsustus arvutuskäigu kohta puudub.\n\n\n\n\n\n\nWarning\n\n\n\nKorrelatsioonikoefitsiendi väärtusel on kolm omadust, mille alusel saab teha järeldusi vastava tunnuste vahelise seose kohta:\n\nselle väärtus on vahemikus -1 ja 1;\nselle absoluutväärtus näitab seose tugevust, kus\n\nväärtus 0 näitab seose puudumist ja\nväärtus -1 või 1 näitab täielikku seost;\n\nselle märk näitab seose suunda, kus\n\npositiivne väärtus tähendab positiivset seost ehk ühe tunnuse väärtuste suurenedes suurenevad ka teise tunnuse väärtused,\nnegatiivne väärtus näitab negatiivset seost.\n\n\n\n\nHinnang korrelatsioonikordaja tugevusele oleneb konkreetsetest nähtustest, mida tunnused esindavad. Nt füüsikaliste nähtuste vahel on korrelatsioonikordajad tavaliselt kõrgemad kui ühiskondlike nähtuste puhul.\nÜldiselt võib korrelatsioonikordaja alusel seose tugevuse hindamisel lähtuda sellest, et korrelatsioonikordaja\n\nalla 0,2 näitab korrelatsiooni puudumist,\n0,2 ja 0,5 vahel näitab mõõdukat korrelatsiooni,\nüle 0,5 näitab tugevat korrelatsiooni.\n\nHarva huvitab meid üksik korrelatsioonikordaja kahe tunnuse vahel. Enamasti soovime hinnata korraga seoseid mitme tunnuse või väga paljude tunnuste vahel. Üks korrelatsioonanalüüsi kasulik rakendus on korrelatsioonimaatriksid ja nende alusel loodud seosekaardid (heatmaps), mis näitlikustavad korraga kõiki ette antud korrelatsioone.\nR keeles on korrelatsioonide leidmiseks funktsioon cor(), mis vaikimisi arvutab Pearsoni korrelatsioonikordaja.\n\n\n# Laadime laienduse tidyverse\nlibrary('tidyverse')\n# Sisestame andmed\nriigid &lt;- read.csv('andmed/countries.csv')\n# Kuvame andmetabeli ülevaate\nstr(riigid)\n\n'data.frame':   227 obs. of  10 variables:\n $ country     : chr  \"Afghanistan\" \"Albania\" \"Algeria\" \"American Samoa\" ...\n $ region      : chr  \"Asia\" \"Eastern Europe\" \"Africa\" \"Oceania\" ...\n $ population  : int  31056997 3581655 32930091 57794 71201 12127071 13477 69108 39921833 2976372 ...\n $ area        : int  647500 28748 2381740 199 468 1246700 102 443 2766890 29800 ...\n $ netmigration: num  23.06 -4.93 -0.39 -20.71 6.6 ...\n $ gdp         : int  700 4500 6000 8000 19000 1900 8600 11000 11200 3500 ...\n $ literacy    : num  36 86.5 70 97 100 42 95 89 97.1 98.6 ...\n $ phones      : num  3.2 71.2 78.1 259.5 497.2 ...\n $ arable      : num  12.13 21.09 3.22 10 2.22 ...\n $ agriculture : num  0.38 0.232 0.101 NA NA 0.096 0.04 0.038 0.095 0.239 ...\n\n# Jätame ainult valitud tunnused\nriigid &lt;- riigid[, 3:10]\n# Arvutame korrelatsioonid\nkorrelatsioonid &lt;- cor(riigid, use = 'pairwise.complete.obs')\n\n\n# Määrame käsu vastuse suurima laiuse\noptions(width = 1000)\n# Kuvame arvutatud korrelatsioonid ümardatuna kahe komakohani\nround(korrelatsioonid, 2)\n\n             population  area netmigration   gdp literacy phones arable agriculture\npopulation         1.00  0.47         0.00 -0.04    -0.04  -0.03   0.19        0.00\narea               0.47  1.00         0.05  0.07     0.04   0.05  -0.08       -0.05\nnetmigration       0.00  0.05         1.00  0.38    -0.01   0.24  -0.06       -0.12\ngdp               -0.04  0.07         0.38  1.00     0.51   0.83   0.02       -0.59\nliteracy          -0.04  0.04        -0.01  0.51     1.00   0.60   0.11       -0.61\nphones            -0.03  0.05         0.24  0.83     0.60   1.00   0.06       -0.60\narable             0.19 -0.08        -0.06  0.02     0.11   0.06   1.00       -0.03\nagriculture        0.00 -0.05        -0.12 -0.59    -0.61  -0.60  -0.03        1.00\n\n\nNäeme, et nt kirjaoskuse ja sündimuse vahel on tugev negatiivne korrelatsioon ning rahvaarv korreleerub tugevalt ainult riigi pindalaga.\nKorrelatsioonimaatriks ei pea olema sümmeetriline tunnuste suhtes, vaid ridades ja veergudes võivad olla ka erinevad tunnused.\nKorrelatsioonimaatriksi kuvamiseks joonisena saame kasutada funktsiooni heatmap(). Vaikimisi järjestatkse tunnused selliselt, et sarnaste korrelatsioonidega tunnused oleksid lähestikku.\n\nheatmap(korrelatsioonid)\n\n\n\n\nRohkem valikuid korrelatsioonimaartikis joonistamisel pakub funktsioon heatmap.2() laiendusest gplots. Lisaks legendile pakub see ka väga palju teisi võimalusi korrelatsioonide kuvamiseks.\n\nlibrary('gplots')\nheatmap.2(korrelatsioonid, col = 'bluered', \n          cellnote = round(korrelatsioonid, 2), notecol = 'black', \n          srtRow = 45, srtCol = 45)\n\n\n\n\nInteraktiivse seosekaardi tekitamiseks saame kasutada funktsiooni heatmaply() samanimelisest laiendusest.\n\nlibrary('heatmaply')\nheatmaply(korrelatsioonid)"
  },
  {
    "objectID": "seosereeglid.html#seosereeglite-leidmine",
    "href": "seosereeglid.html#seosereeglite-leidmine",
    "title": "20  Seosereeglid",
    "section": "20.1 Seosereeglite leidmine",
    "text": "20.1 Seosereeglite leidmine\nSeosereeglite analüüsimiseks R keeles peame paigaldama ja laadima laienduse arules ja reeglite kuvamiseks joonistena laienduse arulesViz.\n\n# Laadime laiendused\nlibrary('tidyverse')\nlibrary('arules') # Seosereeglite arvutamiseks\nlibrary('arulesViz') # Seosereeglite joonistamiseks\n\nSeosereeglite kasutamisel R keeles on üks võimalus sisestada andmed tekstifailina, milles igal real on ühes tehindus olevad asjad. Järgnevalt laadimegi sellisel kujul oleva toidupoe ostukorvi andmestiku Groceries. Selleks kasutame funktsiooni read.transactions() ja lisame täpsustuse format = 'basket' määramaks, et iga rida esindab ühte tehingut.\n\n\ntehingud &lt;- read.transactions('andmed/groceries.txt', format = 'basket', sep = ',')\nsummary(tehingud)\n\ntransactions as itemMatrix in sparse format with\n 9835 rows (elements/itemsets/transactions) and\n 169 columns (items) and a density of 0.02609146 \n\nmost frequent items:\n      whole milk other vegetables       rolls/buns             soda \n            2513             1903             1809             1715 \n          yogurt          (Other) \n            1372            34055 \n\nelement (itemset/transaction) length distribution:\nsizes\n   1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16 \n2159 1643 1299 1005  855  645  545  438  350  246  182  117   78   77   55   46 \n  17   18   19   20   21   22   23   24   26   27   28   29   32 \n  29   14   14    9   11    4    6    1    1    1    1    3    1 \n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  1.000   2.000   3.000   4.409   6.000  32.000 \n\nincludes extended item information - examples:\n            labels\n1 abrasive cleaner\n2 artif. sweetener\n3   baby cosmetics\n\n\nFunktsioon summary() kuvab muuhulgas tehingute ja asjade arvu, sagedasemate asjad nimetused ja sagedused ning tehingute suurused. Konkreetsete tehingute nägemiseks saame kasutada funktsiooni inspect().\n\ninspect(tehingud[1:5])\n\n    items                      \n[1] {citrus fruit,             \n     margarine,                \n     ready soups,              \n     semi-finished bread}      \n[2] {coffee,                   \n     tropical fruit,           \n     yogurt}                   \n[3] {whole milk}               \n[4] {cream cheese,             \n     meat spreads,             \n     pip fruit,                \n     yogurt}                   \n[5] {condensed milk,           \n     long life bakery product, \n     other vegetables,         \n     whole milk}               \n\n\nLisaks saame kuvada nt teatud toega tehingud. Alljärgnevalt leiame asjad, mis esinevad vähemalt 5% tehingutes.\n\neclat(tehingud, support = 0.05) %&gt;% sort %&gt;% inspect\n\nEclat\n\nparameter specification:\n tidLists support minlen maxlen            target  ext\n    FALSE    0.05      1     10 frequent itemsets TRUE\n\nalgorithmic control:\n sparse sort verbose\n      7   -2    TRUE\n\nAbsolute minimum support count: 491 \n\ncreate itemset ... \nset transactions ...[169 item(s), 9835 transaction(s)] done [0.00s].\nsorting and recoding items ... [28 item(s)] done [0.00s].\ncreating sparse bit matrix ... [28 row(s), 9835 column(s)] done [0.00s].\nwriting  ... [31 set(s)] done [0.00s].\nCreating S4 object  ... done [0.00s].\n     items                          support    count\n[1]  {whole milk}                   0.25551601 2513 \n[2]  {other vegetables}             0.19349263 1903 \n[3]  {rolls/buns}                   0.18393493 1809 \n[4]  {soda}                         0.17437722 1715 \n[5]  {yogurt}                       0.13950178 1372 \n[6]  {bottled water}                0.11052364 1087 \n[7]  {root vegetables}              0.10899847 1072 \n[8]  {tropical fruit}               0.10493137 1032 \n[9]  {shopping bags}                0.09852567  969 \n[10] {sausage}                      0.09395018  924 \n[11] {pastry}                       0.08896797  875 \n[12] {citrus fruit}                 0.08276563  814 \n[13] {bottled beer}                 0.08052872  792 \n[14] {newspapers}                   0.07981698  785 \n[15] {canned beer}                  0.07768175  764 \n[16] {pip fruit}                    0.07564820  744 \n[17] {other vegetables, whole milk} 0.07483477  736 \n[18] {fruit/vegetable juice}        0.07229283  711 \n[19] {whipped/sour cream}           0.07168277  705 \n[20] {brown bread}                  0.06487036  638 \n[21] {domestic eggs}                0.06344687  624 \n[22] {frankfurter}                  0.05897306  580 \n[23] {margarine}                    0.05856634  576 \n[24] {coffee}                       0.05805796  571 \n[25] {pork}                         0.05765125  567 \n[26] {rolls/buns, whole milk}       0.05663447  557 \n[27] {whole milk, yogurt}           0.05602440  551 \n[28] {butter}                       0.05541434  545 \n[29] {curd}                         0.05327911  524 \n[30] {beef}                         0.05246568  516 \n[31] {napkins}                      0.05236401  515 \n\n\nNäeme, et enam kui veerandis tehingutest on piim ja veidi alla viiendikus köögiviljad.\nSeosereeglid saame leida Apriori algoritmi kasutades funktsiooniga apriori(). Sealjuures peaksime määrama teatud tingimused leitavatele reeglitele:\n\nsupport ehk tugi,\nconfidece ehk kindlus,\nminlen ehk vähima asjad arvu tehingus,\nmaxlen ehk suurima asjade arvu ühes tehingus.\n\nAlljärgnevalt leiame reeglid, mis iseloomustavad vähmalt 1% kõikidest tehingutest (tugi) ja kehtivad 20% juhtudest (kindlus).\n\n# Määrame valikud\nvalikud &lt;- list(support = 0.01, confidence = 0.2)\n# Rakendame Apriori algoritmi\nreeglid &lt;- apriori(tehingud, parameter = valikud, \n                   control = list(verbose = FALSE)) %&gt;% # Peidame protseduuri kirjelduse\n  sort(by = 'confidence') # Järjestame reeglid alates kõige kõrgema kindlusega reeglist\n# Kuvame ülevaate reeglitest\nsummary(reeglid)\n\nset of 232 rules\n\nrule length distribution (lhs + rhs):sizes\n  1   2   3 \n  1 151  80 \n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  1.000   2.000   2.000   2.341   3.000   3.000 \n\nsummary of quality measures:\n    support          confidence        coverage            lift       \n Min.   :0.01007   Min.   :0.2006   Min.   :0.01729   Min.   :0.8991  \n 1st Qu.:0.01200   1st Qu.:0.2470   1st Qu.:0.03437   1st Qu.:1.4432  \n Median :0.01490   Median :0.3170   Median :0.05241   Median :1.7277  \n Mean   :0.02005   Mean   :0.3321   Mean   :0.06708   Mean   :1.7890  \n 3rd Qu.:0.02227   3rd Qu.:0.4033   3rd Qu.:0.07565   3rd Qu.:2.0762  \n Max.   :0.25552   Max.   :0.5862   Max.   :1.00000   Max.   :3.2950  \n     count       \n Min.   :  99.0  \n 1st Qu.: 118.0  \n Median : 146.5  \n Mean   : 197.2  \n 3rd Qu.: 219.0  \n Max.   :2513.0  \n\nmining info:\n     data ntransactions support confidence\n tehingud          9835    0.01        0.2\n                                                                           call\n apriori(data = tehingud, parameter = valikud, control = list(verbose = FALSE))\n\n\nNäeme, et leiti 232 reeglit keskmise toega 0.0200507 ja keskmise kindlusega 0.3321035.\n\n# Kuvame 20 esimest reeglit\ninspect(reeglid[1:20])\n\n     lhs                         rhs                   support confidence   coverage     lift count\n[1]  {citrus fruit,                                                                                \n      root vegetables}        =&gt; {other vegetables} 0.01037112  0.5862069 0.01769192 3.029608   102\n[2]  {root vegetables,                                                                             \n      tropical fruit}         =&gt; {other vegetables} 0.01230300  0.5845411 0.02104728 3.020999   121\n[3]  {curd,                                                                                        \n      yogurt}                 =&gt; {whole milk}       0.01006609  0.5823529 0.01728521 2.279125    99\n[4]  {butter,                                                                                      \n      other vegetables}       =&gt; {whole milk}       0.01148958  0.5736041 0.02003050 2.244885   113\n[5]  {root vegetables,                                                                             \n      tropical fruit}         =&gt; {whole milk}       0.01199797  0.5700483 0.02104728 2.230969   118\n[6]  {root vegetables,                                                                             \n      yogurt}                 =&gt; {whole milk}       0.01453991  0.5629921 0.02582613 2.203354   143\n[7]  {domestic eggs,                                                                               \n      other vegetables}       =&gt; {whole milk}       0.01230300  0.5525114 0.02226741 2.162336   121\n[8]  {whipped/sour cream,                                                                          \n      yogurt}                 =&gt; {whole milk}       0.01087951  0.5245098 0.02074225 2.052747   107\n[9]  {rolls/buns,                                                                                  \n      root vegetables}        =&gt; {whole milk}       0.01270971  0.5230126 0.02430097 2.046888   125\n[10] {other vegetables,                                                                            \n      pip fruit}              =&gt; {whole milk}       0.01352313  0.5175097 0.02613116 2.025351   133\n[11] {tropical fruit,                                                                              \n      yogurt}                 =&gt; {whole milk}       0.01514997  0.5173611 0.02928317 2.024770   149\n[12] {other vegetables,                                                                            \n      yogurt}                 =&gt; {whole milk}       0.02226741  0.5128806 0.04341637 2.007235   219\n[13] {other vegetables,                                                                            \n      whipped/sour cream}     =&gt; {whole milk}       0.01464159  0.5070423 0.02887646 1.984385   144\n[14] {rolls/buns,                                                                                  \n      root vegetables}        =&gt; {other vegetables} 0.01220132  0.5020921 0.02430097 2.594890   120\n[15] {root vegetables,                                                                             \n      yogurt}                 =&gt; {other vegetables} 0.01291307  0.5000000 0.02582613 2.584078   127\n[16] {fruit/vegetable juice,                                                                       \n      other vegetables}       =&gt; {whole milk}       0.01047280  0.4975845 0.02104728 1.947371   103\n[17] {butter}                 =&gt; {whole milk}       0.02755465  0.4972477 0.05541434 1.946053   271\n[18] {curd}                   =&gt; {whole milk}       0.02613116  0.4904580 0.05327911 1.919481   257\n[19] {whipped/sour cream,                                                                          \n      yogurt}                 =&gt; {other vegetables} 0.01016777  0.4901961 0.02074225 2.533410   100\n[20] {other vegetables,                                                                            \n      root vegetables}        =&gt; {whole milk}       0.02318251  0.4892704 0.04738180 1.914833   228\n\n\nKõige sagedasem on osta koos teiste toodetega köögivilju ja piima. Esimene reegel näitab, et kui ostetakse tsitruselisi ja juurvilju, siis umbes 58,62% juhtudest ostetakse ka teisi köögivilju. Selliseid tehinguid oli 102 ehk 1,03% kõikidest tehingutest.\n\n\n\n\n\n\nWarning\n\n\n\nSeosereeglite korral on olulised seose pooled. Seos A =&gt; B näitab, et kui ostetakse A, siis ostetakse ka B, mitte aga vastupidi. Nt kindlus näitab tõenäosust, et tehingus on B, kui selles on A, aga see sama kindlus ei kehti vastupidise seose kohta.\n\n\nFunktsioon plot() joonistab toe ja kindluse vahelised seosed.\n\nplot(reeglid)\n\nTo reduce overplotting, jitter is added! Use jitter = 0 to prevent jitter.\n\n\n\n\n\nLisades argumendi engine = 'htmlwidget' saame interaktiivse joonise, millel on võimalik võimalik tuvastada konkreetseid reegleid, mida punktid esindavad.\n\nplot(reeglid, engine = 'htmlwidget')\n\nTo reduce overplotting, jitter is added! Use jitter = 0 to prevent jitter.\n\n\n\n\n\n\n\nKõige intuitiivsem viis reeglite kuvamiseks on võrgustikjoonis, mis näitab korraga seoseid mitme reegli vahel.\n\nplot(reeglid, method = 'graph', limit = 20)\n\n\n\n\nSamuti saame kuvada maatriksi, milles veergudes on A ja ridades B ning nende ristumiskohtades on reeglid.\n\nplot(reeglid, method = 'grouped', limit = 20)\n\n\n\n\nLisaks saame kuvada reeglid nooltena, mille joon läbib kõiki asju A ja noole ots näitab asja B.\n\nplot(reeglid, method = 'paracoord', limit = 10)"
  },
  {
    "objectID": "seosereeglid.html#konkreetsed-asjad-reeglites",
    "href": "seosereeglid.html#konkreetsed-asjad-reeglites",
    "title": "20  Seosereeglid",
    "section": "20.2 Konkreetsed asjad reeglites",
    "text": "20.2 Konkreetsed asjad reeglites\nEelnevalt leidsime kõikvõimalikud seosereeglid ja uurisime neid, millel oli kõige kõrgem kindlus. Saame aga leida seosereeglid ka ainult meile huvipakkuvate asjade kohta.\nNt kui soovime teada, mis toodetega kaasneb jogurt (ehk jogurt on B), siis lisame funktsioonile apriori() argumendi appearance = list(default = 'lhs', rhs = 'yogurt').\n\nvalikud &lt;- list(support = 0.01, confidence = 0.1)\nreeglid &lt;- apriori(tehingud, parameter = valikud, \n                   control = list(verbose = FALSE), \n                   appearance = list(default = 'lhs', rhs = 'yogurt')) %&gt;% \n  sort(by = 'confidence')\nplot(reeglid, method = 'graph', limit = 20)\n\n\n\n\nSaame otsida seosereegleid ka teistpidi. Nt kui ostetakse pudelivett, siis mida veel ostetakse (pudelivesi on A)?\n\nreeglid &lt;- apriori(tehingud, parameter = valikud, \n                   control = list(verbose = FALSE), \n                   appearance = list(default = 'rhs', lhs = 'bottled water')) %&gt;% \n  sort(by = 'confidence')\nplot(reeglid, method = 'graph', limit = 20)\n\n\n\n\nKui seosereeglite analüüsi rakendada ostjate ostueelistuste määramiseks ja on olemas teave ka ostjate tausta kohta, siis saab hinnata ka seda, millised ostjad milliseid tooteid eelistavad.\n\n\n\n\n\nSaltz, J. S., & Stanton, J. M. (2017). An introduction to data science. SAGE Publications, Inc."
  },
  {
    "objectID": "usaldusvahemikud.html#ühe-tunnuse-usaldusvahemik",
    "href": "usaldusvahemikud.html#ühe-tunnuse-usaldusvahemik",
    "title": "21  Usaldusvahemikud",
    "section": "21.1 Ühe tunnuse usaldusvahemik",
    "text": "21.1 Ühe tunnuse usaldusvahemik\nAlustame vajalike laienduste töölauale laadimisega.\n\nlibrary('magrittr')\nlibrary('tidyverse')\nlibrary('ggplot2')\n\nJärgnevas näites kasutame andmestikku IT valdkonna töötajate töötasude kohta 2020. aastal peamiselt Saksamaal.\n\ntasu &lt;- read.csv('andmed/itsalary.csv')\nstr(tasu)\n\n'data.frame':   1177 obs. of  3 variables:\n $ gender    : chr  \"Male\" \"Male\" \"Male\" \"Male\" ...\n $ salary    : num  80000 80000 54000 62000 76000 57000 65000 56000 95000 52500 ...\n $ experience: num  5 7 4 17 5 6 5 8 15 2 ...\n\n\n\nVeerus salary on aastane brutotöötasu eurodes ilma lisatasudeta. Teisendame selle meile tuttavaks kuutöötasuks ja uurime, kuidas tasud jaotuvad.\n\ntasu %&lt;&gt;% mutate(salary = salary / 12)\nhist(tasu$salary)\n\n\n\nmean(tasu$salary)\n\n[1] 5656.305\n\n\nNäeme, et keskmine kuutöötasu on 5656 eurot. Kui tõenäoline on, et ka tegelikult oli Saksamaal 2020. aastal IT valdkonna töötajate kuutöötasu täpselt 5656 eurot? Mitte eriti. Usutavama hinnangu saaksime anda siis, kui leiame hoopis vahemiku, milles see hinnang mingi kindlusega on. Seega peaksime leidma usaldusvahemiku.\nUsaldusvahemiku leidmiseks kõige intuitiivsem viis on kasutada Korduvvalikut (bootstrapping). Selleks võtame esmalt andmetest mingil hulgal juhuslikult valimeid nii, et iga leitud valim on sama suur kui algne andmestik, aga osad väärtused (isikud) valimites korduvad ja osad on puudu (Peatükk 11). Valimi võtmiseks saame kasutada funktsiooni sample() ja selle tegevuse kordamiseks funktsiooni replicate().\n\nvalimid &lt;- replicate(1000, # Korrata järgnevat käsku 1000 korda\n                     sample(tasu$salary, # Võtta valim töötasude seast\n                            length(tasu$salary), # Valimis on sama palju väärtusi kui andmestik\n                            replace = T), # Valimis võivad vaatlused korduda\n                     simplify = FALSE) # Väljasta tulemus loeteluna\nstr(head(valimid))\n\nList of 6\n $ : num [1:1177] 5000 7750 4500 5833 4583 ...\n $ : num [1:1177] 6250 5000 3125 4400 4667 ...\n $ : num [1:1177] 3125 7708 5833 5917 4833 ...\n $ : num [1:1177] 5667 6000 4417 5833 7833 ...\n $ : num [1:1177] 6500 5667 4000 6833 4500 ...\n $ : num [1:1177] 7083 4833 6417 3833 6333 ...\n\n\nÜleval on kuvatud esimesed kuus valimit tuhandest. Näeme, et igas valimis on 1177 juhuslikku väärtust andmetes olevates töötasudest.\nJärgmiseks arvutame iga valimi keskmise väärtuse. Selleks rakendame funktsiooni mean() igal valimil eraldi. Loetelu igale osisele saame funktsiooni rakendada funktsiooniga sapply() alljärgnevalt. Vaatame valimite keskmiste jaotust histogrammilt.\n\nkeskmised &lt;- sapply(valimid, mean)\nhist(keskmised)\n\n\n\n\nHistogrammilt näeme, et suur osa valimite keskmistest jäävad väärtuste 5600 ja 5700 vahele.\nKuna usaldusvahemik oleneb sellest, kui kindlad me tahame olla, et tegelik väärtus seal asub, siis peame selle kindluse määrama. Enamasti leitakse usaldusvahemik kindlusega 95%. Taasvalikut rakendades tähendab see, et usaldusvahemiku määravad need piirid, juhul jääb 95% kõikidest leitud valimite keskmistest. Seega alumine töötasu piir peab olema selline, millest väiksemaid väärtusi on 2,5% ja ülemisest piirist suuremaid väärtusi 2,5%. Sinna vahele jääb 95% kõikide valimite alusel leitud keskmistest töötasudest. Vastavate kvantiilide leidmiseks saame kasutada funktsiooni quantile().\n\nquantile(keskmised, .025) # Alumine 2.5% piir\n\n    2.5% \n5570.367 \n\nquantile(keskmised, .975) # Ülemine 2.5% piir\n\n   97.5% \n5735.849 \n\n\nNeed kaks töötasu väärtust 5570 ja 5736 ongi 95% usaldusvahemik, mille vahele jääb suure tõenäosusega tegelik töötasu.\nAll oleval joonisel on leitud usaldusvahemik kujutatud töötasu valimijaotuse tihedusfunktsioonil. Joontena esitatud usaldusvahemiku vahele jääb 95% tihendusfunktsiooni kõvera alusest pindalast.\n\nplot(density(keskmised))\nabline(v = quantile(keskmised, .025))\nabline(v = quantile(keskmised, .975))\n\n\n\n\nEelnevate arvutuste üks mõte oli usaldusvahemiku leidmise selgitamine. Tegelikult saab korduvvaliku alusel usaldusvahemikku leida ka lühemalt, kasutades funktsioone boot() ja boot.ci() vastavast laiendusest. Sellisel juhul tuleb kasutatav mõõdik vormistada veidi keerulisemalt, käsitsi loodava funktsioonina.\n\nlibrary('boot')\n# Leiame 1000 korduvvaliku teel saadud valimi keskmised \nkeskmisedBoot &lt;- boot(tasu$salary, \n                      function(x,i) mean(x[i]), # Funktsioon keskmiste arvutamiseks\n                      1000) # Kordame valikut 1000 korda\n# Leiame, mis vahemikku jääb 95% nendest keskmistest\nboot.ci(keskmisedBoot, conf = 0.95, type = 'norm')\n\nBOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS\nBased on 1000 bootstrap replicates\n\nCALL : \nboot.ci(boot.out = keskmisedBoot, conf = 0.95, type = \"norm\")\n\nIntervals : \nLevel      Normal        \n95%   (5572, 5742 )  \nCalculations and Intervals on Original Scale\n\n\nNäeme, et leitud töötasu usaldusvahemik on sarnane varem käsitsi leitud usaldusvahemikule 5570 ja 5736.\n\n\n\n\n\n\nWarning\n\n\n\nKorduvvaliku käigus võetakse valimid juhuslikult. Seetõttu saame korduvvalikut korrates peaaegu alati veidi erineva valimi ja seega ka erineva usaldusvahemiku. See erinevus on aga piisavalt väike, et hinnngut mitte märkimisväärselt muuta."
  },
  {
    "objectID": "usaldusvahemikud.html#kahe-rühma-võrdlemine",
    "href": "usaldusvahemikud.html#kahe-rühma-võrdlemine",
    "title": "21  Usaldusvahemikud",
    "section": "21.2 Kahe rühma võrdlemine",
    "text": "21.2 Kahe rühma võrdlemine\nVõrdleme naiste ja meeste töötasude erinevust.\n\nhist(tasu$salary, freq = FALSE)\nlines(density(tasu$salary[tasu$gender == \"Female\"]), col = 'red')\nlines(density(tasu$salary[tasu$gender == \"Male\"]), col = 'blue')\n\n\n\nmean(tasu$salary[tasu$gender == \"Female\"])\n\n[1] 4902.418\n\nmean(tasu$salary[tasu$gender == \"Male\"])\n\n[1] 5799.612\n\n\nNäeme, et naiste keskmine töötasu on tunduvalt madalam kui meestel, kuigi töötasude jaotused suurel määral kattuvad. Enne järelduste tegemist tuleb aga meeles pidada, et andmestikus on ainult valim ja tegelikult, kogumis ei pruugi üldse erinevust olla. Usutavama järeldus saame teha usaldusvahemiku alusel. Leiame järgnevalt usaldusvahemiku naiste ja meeste töötasude kohta eraldi.\n\n# Naiste töötasu usaldusvahemik\nkeskmisedN &lt;- boot(tasu$salary[tasu$gender == \"Female\"], \n                   function(x,i) mean(x[i]), \n                   1000) \nboot.ci(keskmisedN, conf = 0.95, type = 'norm')\n\nBOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS\nBased on 1000 bootstrap replicates\n\nCALL : \nboot.ci(boot.out = keskmisedN, conf = 0.95, type = \"norm\")\n\nIntervals : \nLevel      Normal        \n95%   (4730, 5068 )  \nCalculations and Intervals on Original Scale\n\n# Meeste töötasu usaldusvahemik\nkeskmisedM &lt;- boot(tasu$salary[tasu$gender == \"Male\"], \n                   function(x,i) mean(x[i]), \n                   1000) \nboot.ci(keskmisedM, conf = 0.95, type = 'norm')\n\nBOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS\nBased on 1000 bootstrap replicates\n\nCALL : \nboot.ci(boot.out = keskmisedM, conf = 0.95, type = \"norm\")\n\nIntervals : \nLevel      Normal        \n95%   (5711, 5887 )  \nCalculations and Intervals on Original Scale\n\n\nNäeme, et 95% valimite korral on naiste tegelik keskmine töötasu 4730 ja 5068 euro vahel, meestel aga 5711 ja 5887 euro vahel.\nSaame selle erinevuse joonistada ka valimijaotuste tihendusfunktsioonina koos varem leitud üldise keskmise töötasu valimijaotusega.\n\nhist(keskmised, freq = FALSE, xlim = c(4500,6500))\nlines(density(keskmisedN$t), col = 'red') # Naiste tõõtasu punasega\nlines(density(keskmisedM$t), col = 'blue') # Meeste tõõtasu sinisega\n\n\n\n\nNäeme, et naiste ja meeste tööusaldusude valimijaotused peaaegu ei kattu. Võime järeldada, et naiste töötasu IT valdkonnas 2020. aastal oli madalam mitte ainult meie andmetes, vaid ka tegelikult.\n\n\n\n\n\n\nWarning\n\n\n\nUsaldusvahemikul on palju tõlgendusviise. Õige on öelda, et usaldusvahemik kehtib 95% valimite korral ja tegemist on 95% usaldusvahemikuga. Korduvvaliku alusel leitud usaldusvahemiku korral ei ole aga ka täiesti vale öelda, et need kehtivad 95% tõenäosusega või et teglik väärtus jääb usaldusvahemikku 95% tõenäosusega."
  },
  {
    "objectID": "usaldusvahemikud.html#seose-usaldusvahemik",
    "href": "usaldusvahemikud.html#seose-usaldusvahemik",
    "title": "21  Usaldusvahemikud",
    "section": "21.3 Seose usaldusvahemik",
    "text": "21.3 Seose usaldusvahemik\nKorduvvalik ei võimalda usaldusvahemikku leida mitte ainult keskväärtuse, vaid mistahes parameetri jaoks. Alloleval joonisel paistab, et töökogemuse (experience) kasvades suureneb ka keskmiselt töötasu (salary). Meid võib huvitada, kas see seos kehtib ainult meie valimis või ka tegelikkuses.\n\nggplot(tasu) + \n  aes(x = experience, y = salary) + \n  geom_point() + \n  geom_smooth() + \n  theme_minimal()\n\n`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\n\n\n\n\n\nSeost kahe tunnuse vahel saame hinnata korrelatsioonikordajaga. Leiame järgneval korrelatsiooni kahe huvipakkuva tunnuse vahel selliselt, et võtame arvesse ainult isikuid, kelle kohta ei ole kummagi tunnuse väärtuste seas puuduvaid. Selleks lisame funktsiooni cor() argumendi use = 'pairwise.complete.obs'.\n\ncor(tasu$salary, tasu$experience, use = 'pairwise.complete.obs')\n\n[1] 0.4266482\n\n\nNäeme, et meie valimis on tunnuste vahel keskmise või mõõduka tugevusega positiive seos.\nArvutame usaldusvahemiku jällegi laienduse boot funktsioone kasutades.\n\nkorrelatsioonid &lt;- boot(tasu, \n                        function(x,i) cor(x[i, 'salary'], x[i, 'experience']), \n                        1000)\nboot.ci(korrelatsioonid, type = 'norm')\n\nBOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS\nBased on 1000 bootstrap replicates\n\nCALL : \nboot.ci(boot.out = korrelatsioonid, type = \"norm\")\n\nIntervals : \nLevel      Normal        \n95%   ( 0.3711,  0.4800 )  \nCalculations and Intervals on Original Scale\n\n\nNagu näha, siis 95% valimite korral jäävad korrelatsioonid vahemikku 0.37 ja 0.48.\nJoonistame ka korrelatsioonide valimijaotuse.\n\nhist(korrelatsioonid$t, xlim = c(0,.5))\n\n\n\n\nOn selge, et 95% usaldusvahemik ei kata nullpunkti. Sellest võime järeldada, et mitte ainult meie valimis, vaid ka üldiselt, kogumis on kogemuse ja töötasu vahel positiivne seos. Usaldusvahemiku alusel võime järeldada, et korrelatsioonikordaja kogemuse ja töötasu vahel on kogumis 95% kindlusega vähemalt 0.37, aga mitte üle 0.48."
  },
  {
    "objectID": "usaldusvahemikud.html#usaldusvahemik-statistika-lähenemises",
    "href": "usaldusvahemikud.html#usaldusvahemik-statistika-lähenemises",
    "title": "21  Usaldusvahemikud",
    "section": "21.4 Usaldusvahemik statistika lähenemises",
    "text": "21.4 Usaldusvahemik statistika lähenemises\nEelnev usaldusvahemiku leidmise viis valimeid simuleerides iseloomustab hästi andmeteadust. Enne arvuteid kujunenud statistika lähenemine usalduvahemike leidmisele põhineb rohkem matekaatika teoorial.\nPaljusid nähtusi iseloomustavad väärtused järgivad jaotuses sageli normaaljaotust, aga ka sellele sarnast t-jaotust. Võime oletada, et ka kogumis on väärtused jaotunud vastavalt t-jaotusele.\n\ntjaotus &lt;- rt(1e4, length(tasu$salary)) * sd(tasu$salary) + mean(tasu$salary)\npar(mfrow = 1:2)\nhist(tasu$salary, main = \"Jaotus valimis\", 20)\nhist(tjaotus, main = \"Eeldatav jaotus kogumis\", 20)\n\n\n\n\nNäeme, et meie küsitletute seas on jaotus veidi paremale kaldu, aga üldiselt siiski sarnane sellele vastavale t-jaotusele. Kui eeldame, et kogumis ongi väärtused jaotunud nii nagu t-jaotuse korral, siis saame usaldusvahemiku leida teoreetiliselt ilma suurel hulgal valimeid tekitamata.\nNimetatud eeldusel saab usaldusvahemiku leida matemaatiliselt kasutades valemit\n\\[\\bar{x} \\pm z \\frac{s}{\\sqrt{n}}, \\]\nkus \\(\\bar{x}\\) on keskmine, \\(z\\) on t-jaotuse täiendkvantiil, \\(s\\) valimi standardviga ja \\(n\\) valimi suurus.\nKirjutame selle valemi R käskudena.\n\nz &lt;- qt(0.975, length(tasu$salary) - 1) # T-jaotuse täiendkvantiil\nviga &lt;- z * (sd(tasu$salary) / sqrt(length(tasu$salary))) # Viga keskmisest\nmean(tasu$salary) - viga # Alumine 2.5% piir\n\n[1] 5573.566\n\nmean(tasu$salary) + viga # Ülemine 2.5% piir\n\n[1] 5739.044\n\n\nNäeme, et töötasu 95% usaldusvahemik on 5574 ja 5739 euro vahel. Sama tulemuse saame ka lihtsamalt, kasutades ära funktsiooni t.test().\n\nt.test(tasu$salary)\n\n\n    One Sample t-test\n\ndata:  tasu$salary\nt = 134.13, df = 1176, p-value &lt; 2.2e-16\nalternative hypothesis: true mean is not equal to 0\n95 percent confidence interval:\n 5573.566 5739.044\nsample estimates:\nmean of x \n 5656.305 \n\n\nNeed matemaatiliselt leitud usaldusvahemik on väga sarnane varem korduvvaliku teel leitud usaldusvahemikule, mis oli 5570 ja 5736."
  },
  {
    "objectID": "linreg.html#regressioonimudel",
    "href": "linreg.html#regressioonimudel",
    "title": "22  Lineaarne regressioon",
    "section": "22.1 Regressioonimudel",
    "text": "22.1 Regressioonimudel\nMatemaatiliselt kõige lihtsam viis arvskaalal väljundtunnusega regressioonimudeli parameetreid hinnata ongi vähimruutude meetod.\n\n\n\n\n\n\nImportant\n\n\n\nLihtne vähimruutude meetod (ordinary least squares) on regressioonmudeli parameetrite leidmise viis. Selle käigus leitakse maatriksalgebra alusel selline mudeli vabaliige ja sisendtunnus(t)e kordaja(d), mille korral regressioonisirge teeks võimalikult väikse vea väljundtunnuse väärtuste seletamisel.\n\n\nEmpiiriliselt ongi regressioonimudelis põhjuslik seos seetõttu, et selle hindamisel on eesmärk võimalikult täpselt seletada just väljundtunnuse väärtusi. Lihtsustatult võib regressioonimudelist mõelda kui mistahes statistilisest mudelist. See kirjeldab lihtsalt seost sisend- ja väljundtunnuste vahel ning võimaldab selle kirjelduse alusel väljundtunnuse väärtusi prognoosida.\n\n\n\n\nflowchart LR\ni[\"Sisendtunnus(ed)\"] --&gt; m(Mudel) --&gt; o[Väljundtunnus]\n\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nRegressioonimudel määrab seose ühe või enama sisendtunnuse ja ühe väljundtunnuse vahel selliselt, et viga väljundtunnuse prognoosimisel oleks võimalikult väike. Regressioonimudelit saab kasutada\n\nseoste kirjeldamiseks iga sisendtunnuse ja väljundtunnuse vahel ning\nväljundtunnuse väärtuse prognoosimiseks teatud sisendtunnus(t)e väärtuste alusel.\n\n\n\nR keeles saab vähimruutude meetodit rakendada funktsiooniga lm() (ehk lineaarne mudel). Leiame mudeli, mis selgitab, kuidas maja pind (area) määrab maja hinna (price). Selleks tuleb funktsioonis mudel määratleda valemi kujul price ~ area.\n\nmPind &lt;- lm(price ~ area, majad)\n\nVähimruutude meetodi alusel saab arvutada ka mudeleid, milles sisendtunnus on mõõdetud nimiskaalal. Vaatame nt, kuidas lähedus suurele teele (mainroad) on seotud maja hinnaga.\n\nmTee &lt;- lm(price ~ mainroad, majad)\n\nRegressioonimudelisse saame lisada ka mitu tunnust korraga, nt mõlemad eelnevalt nimetatud sisendtunnused.\n\nmPindTee &lt;- lm(price ~ area + mainroad, majad)\n\nÜks võimalik lähenemine regressioonanalüüsile on lisada mudelisse kõik sisendtunnused, mis teoreetiliselt võiksid seletada väljundtunnuse väärtusi. Järgnevas näites lisame sisendtunnustena kõik andmetabelis olevad tunnused, va väljundtunnus.\n\nmKõik &lt;- lm(price ~ ., majad)"
  },
  {
    "objectID": "linreg.html#regressioonikordajad",
    "href": "linreg.html#regressioonikordajad",
    "title": "22  Lineaarne regressioon",
    "section": "22.2 Regressioonikordajad",
    "text": "22.2 Regressioonikordajad\n\n22.2.1 Arvtunnus\nEelnevalt hinnatud regressioonimudel maja hinnna leidmiseks pinna alusel sisaldab kahte regressioonikordajat.\n\nmPind\n\n\nCall:\nlm(formula = price ~ area, data = majad)\n\nCoefficients:\n(Intercept)         area  \n    2.10211      0.00546  \n\n\nNeist esimene on vabaliige (Intercept) ehk väljundtunnuse väärtus seal, kus sirge ristub sisendtunnuse teljega. See on maja hind juhul, kui maja pinna väärtus on null. Antud juhul näeme, et ilma pinnata maja hind oleks empiiriliselt 2.1 mln USD. Kuna kasutatud andmetes päriselt ilma pinnata majasid ei ole, siis ei ole mõtet vabaliikmele ka tähendust omistada.\n\n\n\n\n\n\nNote\n\n\n\nVähimruutude meetodil leitud regresioonimudeli arvtunnuse kordaja näitab, kui mitme ühiku võrra suureneb väljundtunnuse väärtus, kui sisendtunnuse väärtus suureneb ühe ühiku võrra.\n\n\nVabaliikmele järgneb sisendtunnuste kordaja ehk sirge tõus sisendtunnuse suurenemisel ühe ühiku võrra. See näitab, kui mitme mln USD võrra on suurem maja hind, kui pind on suurem ühe ruutmeetri võrra. Näeme, et iga ruutmeeter lisab maja hinnale 0.00546 mln USD ehk 5460 USD. See tõus on kujutatud joonisel Joonis 22.1.\nKui meid huvitab väljundtunnuse muutus sisendtunnuse mitme ühikulise kasvu korral, siis võime kordaja vastava konstandiga korrutada. Nt 1000 ruutmeetrit pinda lisab eelneva mudeli alusel maja hinnale \\(0.005 \\times 1000 = 5\\) mln USD.\n\n\n22.2.2 Nimitunnus\nKui mudelis on nimitunnused, siis on regressioonikordajate tõlgendused veidi erinevad. Üks tunnuse väärtustest on aluseks teis(t)ele, mis muudab regressioonikordajate tõlgendamise veidi keerulisemaks.\n\nmTee\n\n\nCall:\nlm(formula = price ~ mainroad, data = majad)\n\nCoefficients:\n(Intercept)  mainroadyes  \n     3.7923       0.7071  \n\n\nVabaliige näitab sellisel juhul maja hinda juhul, kui maja ei asu tee lähenduses (mainroad == 'no'), sest tunnuse kordaja on mainroadyes ehk mainroad == yes. Ehk tunnuse mainroad väärtus no on võrdlusväärtus. Tunnuse kordaja (mainroadyes) näitab, kui mitme USD võrra on sellest kallim maja, mis asub tee lähenduses. Järgneval joonisel Joonis 22.2 on vabaliige ja tunnuse kordaja esitatud vastavalt pideva ja katkendliku joonega.\n\n\n\n\n\nJoonis 22.2: Nimitunnus regressioonimudelis\n\n\n\n\nNäeme, et suurest teest eemal asuva maja (mainroad == 'no') hind on keskmiselt 3.79 mln USD. Suurel teel asuva maja väärtus on aga sellest 0.71 mln USD võrra kõrgem ehk 4.5 mln USD.\n\n\n\n\n\n\nNote\n\n\n\nVähimruutude meetodil leitud regresioonimudeli vabaliige näitab väljundtunnuse väärtust sisendtunnuse võrdlusväärtuse korral. Nimitunnuse muude väärtuste kordajad näitavad, kui mitme ühiku võrra on väljundtunnuse väärtus suurem võrreldes nimitunnuse võrdlusväärtusega.\n\n\n\n\n\n\n\n\nWarning\n\n\n\nTunnuste liik R keele objektis määrab, mil viisil hinnatakse seos tunnuste vahel. Nt kui nimitunnus on sisestatud arvudena, siis väljastab vastav R keele funktsioon regressioonikordaja, hoolimata sellest, et sellel sisulist tähendust ei ole.\n\n\n\n\n22.2.3 Arv- ja nimitunnused\nKui mudelis on mitu tunnust, siis jääb kordajate tõlgendus samaks.\n\nmPindTee\n\n\nCall:\nlm(formula = price ~ area + mainroad, data = majad)\n\nCoefficients:\n(Intercept)         area  mainroadyes  \n   2.023472     0.005383     0.126777  \n\n\nKüll aga näeme, et kordajad on erinevad võrreldes eelnevate ühe sisendtunnusega mudelitega. Põhjus on selles, et sisendtunnused on omavahel seotud ja mõjutavad seetõttu teineteise seost väljundtunnusega (vt Peatükk 14).\n\n\n\n\n\nJooniselt näeme, et iga ruutmeetriga kaasneb 0.005 mln USD võrra kõrgem hind. Suure tee lähendus (katkendlik sirge) lisab hinnale 0.127 mln USD.\nSamuti märkame, et suure tee läheduse kordaja oluliselt on viimases mudelis tunduvalt madalam kui eelnevas ilma pinnata mudelis. See tähendab, et suur osa suure tee lähendusega seletatavast hinna hajuvusest tuleneb hoopis majade pinnast.\n\n\n\n\n\n\nWarning\n\n\n\nSisendtunnuste regressioonikordajad on enamasti teineteisest sõltuvad. Mida suurem on korrelatsioon nende vahel, seda enam muutub ühe sisendtunnuse kordaja, kui lisame mudelisse või eemaldame mudelist teise."
  },
  {
    "objectID": "linreg.html#regressioonikordajate-usaldusvahemik",
    "href": "linreg.html#regressioonikordajate-usaldusvahemik",
    "title": "22  Lineaarne regressioon",
    "section": "22.3 Regressioonikordajate usaldusvahemik",
    "text": "22.3 Regressioonikordajate usaldusvahemik\nEnamasti leiame regressioonikordajad valimi alusel, mistõttu on tegemist (punkt)hinnangutega. Nii saa me olla kindlad, kas kordajad ja vastavad seosed ka üldiselt kehtivad. Regressioonikordajate kehtivust saame hinnata usaldusvahemike alusel (Peatükk 21).\nR keeles saame regressioonimudeli kordajate usaldusvahemikke kuvada funktsiooniga confint(). See funktsioon kuvab teoreetiliselt arvutatud, mitte taasvaliku alusel leitud usaldusvahemikud.\n\nmudel &lt;- lm(price ~ ., majad)\nconfint(mudel, level = .95)\n\n                                      2.5 %       97.5 %\n(Intercept)                     1.093198328  1.734167689\narea                            0.003916509  0.004839538\nbedrooms                       -0.055222319  0.113389133\nbathrooms                       0.189191185  0.451668689\nstories                         0.126458955  0.295782704\nmainroadyes                    -0.027848762  0.319337765\nguestroomyes                    0.064618599  0.388534574\nbasementyes                    -0.009793511  0.231749245\nhotwaterheatingyes             -0.207242650  0.335064880\nairconditioningyes              0.096073548  0.340068066\nparking                        -0.029901271  0.106855222\nprefareayes                     0.150685880  0.407071175\nfurnishingstatussemi-furnished -0.169204560  0.091201562\nfurnishingstatusunfurnished    -0.311617770 -0.013714692\n\n\nKordajate korral tuleb uurida, kas usaldusvahemik katab nulli või mitte.\n\nKui katab, siis me ei saa olla kindlad, et kordaja ei ole 0 ehk seos võib ka puududa.\nKui ei kata, siis võime järeldada, et seos kehtib.\n\nEelnevalt esitatud usaldusvahemikke aitab ehk paremini mõista nende uurimine joonisel.\n\n\n\n\n\nNäeme, et posiivne seos hinnaga on tunnustel stories, prefarea, guestroom, bathroom ja airconditioning. Maja hind on aga madalam, kui tunnus furnishingstatus == unfurnished.\nEnamasti kasutatakse regressioonikordajate üldistatavuse hindamiseks aga statistilist hüpoteeside testimist. Vastavate p-väärtuste kuvamiseks saab kasutada funktsiooni summary().\n\nmudel &lt;- lm(price ~ ., majad)\nsummary(mudel)\n\n\nCall:\nlm(formula = price ~ ., data = majad)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-1.18707 -0.30604 -0.02051  0.31253  0.99828 \n\nCoefficients:\n                                 Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)                     1.4136830  0.1627631   8.686 4.07e-16 ***\narea                            0.0043780  0.0002344  18.679  &lt; 2e-16 ***\nbedrooms                        0.0290834  0.0428160   0.679 0.497567    \nbathrooms                       0.3204299  0.0666516   4.808 2.57e-06 ***\nstories                         0.2111208  0.0429969   4.910 1.60e-06 ***\nmainroadyes                     0.1457445  0.0881620   1.653 0.099495 .  \nguestroomyes                    0.2265766  0.0822529   2.755 0.006286 ** \nbasementyes                     0.1109779  0.0613356   1.809 0.071538 .  \nhotwaterheatingyes              0.0639111  0.1377097   0.464 0.642960    \nairconditioningyes              0.2180708  0.0619582   3.520 0.000509 ***\nparking                         0.0384770  0.0347270   1.108 0.268880    \nprefareayes                     0.2788785  0.0651046   4.284 2.58e-05 ***\nfurnishingstatussemi-furnished -0.0390015  0.0661257  -0.590 0.555825    \nfurnishingstatusunfurnished    -0.1626662  0.0756474  -2.150 0.032441 *  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.4387 on 263 degrees of freedom\nMultiple R-squared:  0.7831,    Adjusted R-squared:  0.7724 \nF-statistic: 73.04 on 13 and 263 DF,  p-value: &lt; 2.2e-16"
  },
  {
    "objectID": "linreg.html#mudeli-jäägid",
    "href": "linreg.html#mudeli-jäägid",
    "title": "22  Lineaarne regressioon",
    "section": "22.4 Mudeli jäägid",
    "text": "22.4 Mudeli jäägid\nNagu nägime ka eelnevatest näidetest, siis regressioonimudelit iseloomustav sirge ei kata peaaegu kunagi kõiki vaatlusi.\n\n\n\n\n\nJoonis 22.3: Regressiooni jäägid\n\n\n\n\nNagu näeme, siis vähemalt enamike majade korral ei ole hind täpselt selline nagu mudeli alusel oletada võiks. Ehk alati esinevad regressiooni jäägid (residuals), mis joonisel Joonis 22.3 on esitatud punasega. Jääke saame kuvada funktsiooniga residuals(), mille argumendiks on regressioonimudel. Need jäägid saame aga arvutada ja seejärel kasutada regressioonimudeli headuse hindamiseks. Väikeste vigadega regressioonimudel on mõistagi parem kui mudel, mis teeb suuri vigasid.\nRegressioonimudeli headuse hindamiseks jääkide alusel on välja mõeldud palju erinevaid mõõdikuid, sh R-ruut, keskmine ruutviga, keskmine absoluutviga.\nJääkide alusel saame hinnata ka seda, kas regressioonimudel vastab mitmesugustele eeldustele. Üks eeldus regressioonimudeli kehtimiseks on jääkide allumine normaaljaotusele ehk nulli lähedal olevaid jääke peaks olema rohkem kui nullist palju erinevaid jääke."
  },
  {
    "objectID": "linreg.html#prognoosimine",
    "href": "linreg.html#prognoosimine",
    "title": "22  Lineaarne regressioon",
    "section": "22.5 Prognoosimine",
    "text": "22.5 Prognoosimine\nEelnevalt kasutasime regressioonimudelit, et kirjeldada mil viisil sõltuvad väljundtunnuse väärtused sisendtunnus(t)e väärtustest. Kuna teame seda sõltuvust, siis saame ka arvutada konkreetsete tunnustega maja hinna. Kui meid huvitab nt 700 ruutmeetrise maja hind, siis peaksime valima regressioonisirgel sellise hinna, mille korral pind on 700 ruutmeetrit.\n\n\n\n\n\nR keeles saame mudeli alusel prognoosimiseks kasutada funktsiooni predict() alljärgnevalt.\n\nmudel &lt;- lm(price ~ area, majad)\npredict(mudel, list(area = 700))\n\n       1 \n5.924087 \n\n\nNäeme, et 456 ruutmeetrise maja turuväärtus on keskmiselt 4.59 mln USD.\nMitme sisendtunnusega mudeli korral peame prognoosimiseks määrama mitu sisendtunnuse väärtust.\n\nmudel &lt;- lm(price ~ area + bedrooms, majad)\npredict(mudel, list(area = 678, bedrooms = 3))\n\n       1 \n5.780631 \n\n\nKolme magamistoaga 678 ruutmeetrise maja turule vastav hind on aga 5.78 mln USD."
  },
  {
    "objectID": "logreg.html#logistiline-mudel",
    "href": "logreg.html#logistiline-mudel",
    "title": "23  Logistiline regressioon",
    "section": "23.1 Logistiline mudel",
    "text": "23.1 Logistiline mudel\nBinaartunnuse korral eeldame, et selle väärtused järgivad binoomjaotust. Seetõttu peame regressioonmudeli arvutamiseks leidma lineaarse mudeli üldistatud kujul (generalized linear model ehk GLM). Üldistatud lineaarse mudeli kordajaid ei saa me aga arvutada vähimruutude meetodil, vaid peame kasutama suurima tõepära hindamist (maximum likelihood estimation ehk MLE), mille käigus leiame mudeli parameetrid, mille korral meie andmed kõige tõenäolisemad on. Nende tegevuste käigus leitakse logistiline mudel.\n\n\n\n\n\n\nImportant\n\n\n\nLogistiline mudel (logistic model) on regressioonimudel, mis seletab binaarskaalal mõõdetud väljundtunnuse väärtuseid sisendtunnus(t)e alusel.\n\n\nLogistilise mudeli arvutamiseks R keeles saame kasutada funktsiooni glm() üldistatud lineaarse mudeli leidmiseks, määrates argumendi family = binomial(link = 'logit'). Selleks peab väljundtunnusses olema sündmuse mitte toimumine ja toimumine määratud vastavalt kas väärtustega 0 ja 1 või loogilise tunnusena ehk väärtustega FALSE või TRUE.\n\nlaenud$maksevõimetu &lt;- laenud$credit == 1\ntable(laenud$default, laenud$maksevõimetu)\n\n   \n    FALSE\n  0   765\n  1   235\n\nmudel &lt;- glm(default ~ credit, data = laenud, family = binomial(link = 'logit'))\nmudel\n\n\nCall:  glm(formula = default ~ credit, family = binomial(link = \"logit\"), \n    data = laenud)\n\nCoefficients:\n (Intercept)        credit  \n-0.703935391  -0.000003078  \n\nDegrees of Freedom: 999 Total (i.e. Null);  998 Residual\nNull Deviance:      1090 \nResidual Deviance: 1066     AIC: 1070\n\n\nKuigi regressioonikordaja on sarnane vähimruutude meetodil leitule, siis logistiline mudel määrab seose tunnuste vahel erinevalt.\n\n\n\n\n\nLogistiline mudel\n\n\n\n\nNäeme, et logistine mudel ei ole graafiliselt mitte sirge, vaid kõver, mis on piiratud väljundtunnuse väärtuste 0 ja 1 vahele. See logistilise mudeli omadus ilmneb selgemalt, kui vaatame all esiatud mudelit, kus sisendtunnus eraldab väljundtunnuse väärtused selgemini.\n\n\n\n\n\nJoonis 23.1: Logistiline mudel\n\n\n\n\nJooniselt selgub ka, et me ei saa tõlgendada logistilise mudeli kordajaid nii nagu vähimruutude meetodi alusel leitud mudeli korral. Väljundtunnuse muutus sisendtunnuse muutuse korral oleneb sellest, millise konkreetse väärtuse juures me sisendtunnust vaatame."
  },
  {
    "objectID": "logreg.html#regressioonikordajad",
    "href": "logreg.html#regressioonikordajad",
    "title": "23  Logistiline regressioon",
    "section": "23.2 Regressioonikordajad",
    "text": "23.2 Regressioonikordajad\nLogistilise mudeli kordaja näitab, kui palju suureneb sisendtunnuse ühe ühikulise suurenemise korral väljundtunnuseks oleva sündmuse toimumise logaritmiline šanss. Selle saab šanssiks teisendada võttes kordaja eksponendi. Šanss (odds) on sündmuse toimumise ja mitte toimumise jagatis ning näitab seega sündmuse toimumise ja mitte toimumise suhet.\n\n\n\n\n\n\nNote\n\n\n\nLogistilise mudeli kordaja märk näitab, kas sisendtunnuse väärtuse kasvades väljundtunnuseks oleva sündmuse toimumise šanss suureneb või väheneb.\nKordaja eksponent näitab, kui mitu korda on väljundtunnuseks oleva sündmuse toimumise šanss suurem selle mitte toimumisest, kui vastav sisendtunnus on ühe ühiku võrra suurem.\n\n\nUurime, millised šansid ilmnevad, kui lisame mudelisse ka krediidisaaja tausta iseloomustavad tunnused: vanus (age), sugu (gender), haridustase (education) ja perekondlik seis (maritalstatus).\n\nmudel &lt;- glm(default ~ credit + age + gender + education + maritalstatus, data = laenud, family = binomial(link = 'logit'))\nmudel$coefficients # Kordajad\n\n         (Intercept)               credit                  age \n     -0.796736765011      -0.000002939894      -0.000311098193 \n          genderMale educationHigh school      educationOthers \n      0.321119125002       0.224516997261     -13.086064657195 \n educationUniversity  maritalstatusOthers  maritalstatusSingle \n      0.186010296421      -0.144848303107      -0.280845535283 \n\n\nLihtsuse huvides jätame praegu kõrvale kordjate usaldusvahemikud. Näeme, et üks dollar krediidi limiiti ja üks aasta vanust vähendavad maksevõimetust, sest vastavad kordajad on negatiivsed.\n\nexp(mudel$coefficients) # Kordajate eksponendid\n\n         (Intercept)               credit                  age \n      0.450797625104       0.999997060111       0.999688950193 \n          genderMale educationHigh school      educationOthers \n      1.378669805156       1.251717986945       0.000002073931 \n educationUniversity  maritalstatusOthers  maritalstatusSingle \n      1.204434661681       0.865153524259       0.755144969726 \n\n\nNende kordajate eksponendid ehk šanssid näitavad aga mõlema tunnuse korral, et nende ühe ühikulise suurenemise korral suureneb tõenäosus olla maksevõimetu vastavalt 0.9999971 ja 0.999689 korda. Kuna suurenemine \\(&lt;1\\) tähendab vähenemist, siis iga dollar krediidi limiiti ja iga aasta vanust vähendavad väga vähesel määral šanssi olla maksevõimetu.\nNimitunnuste tõlgendamiseks peame arvesse võtma nende võrdlusväärtusi.\n\nlaenud[, c('gender', 'education', 'maritalstatus')] %&gt;% sapply(unique)\n\n$gender\n[1] \"Female\" \"Male\"  \n\n$education\n[1] \"University\"      \"Graduate school\" \"High school\"     NA               \n[5] \"Others\"         \n\n$maritalstatus\n[1] \"Married\" \"Single\"  \"Others\"  NA       \n\n\nNagu näeme eelnevast, siis eksponent kordajast genderMale on \\(e^{0.3211191} = 1.3786698\\). See tähendab, et meestel on võrreldes naistega 1.38 korda suurem šanss olla maksevõimetu kui mitte.\nSarnaselt saame järeldada, et šanss olla maksevõimetu on suurem madalama haridustaseme korral ja abielus olles. Järelduste tegemisel tasub jällegi meelde tuletada valikunihet (Peatükk 10), sest võib-olla pakuti nt abielus olijatele kergemini krediiti."
  },
  {
    "objectID": "logreg.html#prognoosimine",
    "href": "logreg.html#prognoosimine",
    "title": "23  Logistiline regressioon",
    "section": "23.3 Prognoosimine",
    "text": "23.3 Prognoosimine\nLogistilise mudeli alusel on võimalik prognoosida väljundtunnuse väärtusi sisendtunnuse väärtuste alusel. Prognoos on sellisel juhul väärtus vahemikus 0 kuni 1 (vt Joonis 23.1) ja saadud prognoosi võib tõlgendada sündmuse toimumise tõenäosusena vastvate sisendtunnuste väärtuste korral. Tõenäosuste prognoosimiseks üldistatud lineaarse mudeli korral peame funktsiooni predict() lisama argumendi type = 'response'.\n\nmudel &lt;- glm(default ~ age + gender + education, data = laenud, family = binomial(link = 'logit'))\ntõenäosus &lt;- predict(mudel, list(age = 23, gender = 'Female', education = 'University'), type = 'response')\ntõenäosus\n\n        1 \n0.2403401 \n\n\nNäeme, et 23 aastasel ülikooliharidusega naise tõenäosus olla maksevõimetu on 0.24 ehk 24%.\nSageli on vajalik prognoos aga algsel binaarskaalal ehk määrata mitte sündmuse toimumise tõenäosus, vaid konkreetsemalt, kas sündmus mingite sisendtunnuste väärtuste korral toimub või mitte. Sellisel juhul tuleb valida tõenäosuse lävend (threshold), millest alates määratakse sündmus toimunuks. Selliste prognooside täpsuse hindamiseks saame tekitada tabeli, mis näitab prognooside õigsust empiirilise sündmuse toimumise suhtes.\nMudeli prognoose olemasolevate vaatluste kohta näitab funktsioon fitted(). Kuvame need prognoosid histogrammil.\n\n\nWarning: Removed 2 rows containing missing values (`geom_bar()`).\n\n\n\n\n\nPrognooside sagedused\n\n\n\n\nKõikide andmetes olevate tunnustega mudel prognoosib kõikidele isikutele tõenäosuse olla maksevõimetu alla 0.5. Seega võiksime tõenäosuse lävendiks võtta nt 0.4 ja uurida, kui suur osa maksevõimetutest isikutest prognoositakse õigesti. Selleks saame kasutada veatabelit.\n\ntable(fitted(mudel) &gt; 0.4, mudel$model$default, \n      dnn = c('Prognoos', 'Tegelik'))\n\n        Tegelik\nPrognoos   0   1\n   FALSE 732 226\n   TRUE   13   9\n\n\nTabelist selgub, et tõenäosuse lävendi 0.4 korral tuvastab mudel õigesti ainult 9 maksevõimetut, samas kui 226 tegelikult maksevõimetut isikut mudel selliseks ei pea. See näitab, et mudel ei ole maksevõimetuse prognoosimisel eriti täpne. Kasutatud andmed laenusaajate kohta ei ole piisavad selleks, et eristada maksevõimetuid teistest.\nTeisendame veatabelis olevad väärtused osakaaludeks ja ümardame kahe komakohani.\n\ntable(fitted(mudel) &gt; 0.4, mudel$y, \n      dnn = c('Prognoos', 'Tegelik')) %&gt;% \n  prop.table %&gt;% round(2)\n\n        Tegelik\nPrognoos    0    1\n   FALSE 0.75 0.23\n   TRUE  0.01 0.01\n\n\nNäeme, et mudel määras õige maksevõimetuse 0.76 ehk 76% juhtudest.\nLisaks kasutatud veatabelile on klassifitseerimise täpsuse hindamiseks loodud veel palju mitmesuguseid mõõdikuid."
  },
  {
    "objectID": "otsusepuu.html",
    "href": "otsusepuu.html",
    "title": "24  Otsusepuu",
    "section": "",
    "text": "Otsusepuu kujutab endast joonist, mis ilmestab otsuste hargnevust järgmiste otsusteni ja lõpuks mingi tulemuseni. Otsusepuud saab kasutada mitmesuguste otsustuseid hõlmavate probleemide lahendamisel, aga ka vaatluste jaotamiseks andmestikus. Vaatlused saab järk-järgult jaotada sisendtunnuste alusel nii, et ühes jaotuses on ainult sama väljundtunnuse väärtusega vaatlused.\n\n\n\n\n\n\nImportant\n\n\n\nAndmeanalüüsis on otsusepuu (decision tree) statistiline mudel, mis seisneb teatud reeglite hierarhias. Need reeglid määravad, kuidas jõuda väljundtunnuse väärtusteni jagades vaatlusi järk-järgult sisendtunnuste väärtuste alusel.\n\n\nSisend- ja väljundtunnused võivad otsusepuul olla kas nimi- või arvtunnused. Nimiskaalal väljundtunnuse korral valitakse sõlmedes üks konkreetne väärtus, arvskaala korral aga vaatluste keskmine väärtus. Seega oleneb otsusepuu poolt lahendatav ülesanne väljundtunnuse skaalast:\n\nnimiskaalal väljundtunnuse korral on tegemist klassifitseerimisega,\narvskaalal väljundtunnuse puhul rakendatakse aga sisuliselt regressiooni.\n\nOtsusepuu koosneb\n\notsusesõlmedest, milles sisendtunnus jaotab vaatlused kaheks;\n\nharudest sõlmede vahel;\n\nlõppsõlmedest, millega hargnemine lõppeb ja millest igaühes on teatud osa vaatlustest.\n\nSageli näitlikusatakse otsusepuud 1912. aastal uppunud reisilalaeva Titanic reisijate pääsemise näitel. Vaatame siin analoogset näidet parvlaev Estonia õnnetuse kohta aastal 1994.\n\nestonia &lt;- read.csv('andmed/estoniapassengers.csv')\nstr(estonia)\n\n'data.frame':   989 obs. of  8 variables:\n $ passengerid: int  1 2 3 4 5 6 7 8 9 10 ...\n $ country    : chr  \"Sweden\" \"Estonia\" \"Estonia\" \"Sweden\" ...\n $ firstname  : chr  \"ARVID KALLE\" \"LEA\" \"AIRI\" \"JURI\" ...\n $ lastname   : chr  \"AADLI\" \"AALISTE\" \"AAVASTE\" \"AAVIK\" ...\n $ sex        : chr  \"M\" \"F\" \"F\" \"M\" ...\n $ age        : int  62 22 21 53 55 71 60 18 30 63 ...\n $ category   : chr  \"P\" \"C\" \"C\" \"C\" ...\n $ survived   : int  0 0 0 0 0 0 0 0 0 0 ...\n\n\nOtsusepuu saame arvutada funktsiooni rpart() abil samanimelisest laiendusest. Uurime pääsemist (survival), võttes aluseks reisija soo (sex), vanuse (age) ja selle, kas tegemist oli reisija või meeskonnaliikmega (category).\n\nlibrary('rpart')\npuu &lt;- rpart(survived ~ sex + age + category, estonia)\npuu\n\nn= 989 \n\nnode), split, n, deviance, yval\n      * denotes terminal node\n\n1) root 989 118.02220 0.13852380  \n  2) age&gt;=43.5 507  26.45365 0.05522682 *\n  3) age&lt; 43.5 482  84.35062 0.22614110  \n    6) sex=F 212  18.91981 0.09905660 *\n    7) sex=M 270  59.31852 0.32592590 *\n\n\nNagu üleval näha, siis funktsiooni rpart() tulemuse sisestamisel kuvatakse puu liigendatud loeteluna. Sama teabe saab vormistada ilmekamalt joonisena kasutades funktsiooni rpart.plot() sama nimega laiendusest.\n\nlibrary('rpart.plot')\nrpart.plot(puu)\n\n\n\n\nJoonis 24.1: Lihtne otsusepuu\n\n\n\n\nSõlmedes on murdarvuna esitatud väljundtunnuse mingi väärtuse tõenäosus. Protsendina on esitatud eelnevas sõlmes olevale tingimusele vastavate või mitte vastavate vaatluste osakaal. Tingimustele vastavad vaatlused hargnevad vasakule ja mitte vastavad vaatlused hargnevad paremale.\nJoonisel Joonis 24.1 esitatud näites on algses otsusesõlmes 100% vaatlustest, kellest 0.14 puhul oli tunnuse survived väärtuseks 1 ehk 14% kõikidest pardal olnutest pääsesid. Tingimusele age &gt;= 44 vastavaid ehk vanuses 44 aastat või vanemaid oli pardal 51% ja nendest pääses 0.055 ehk 5,5%. Lõppsõlmede võrdluses kõige suurem pääsemise tõenäosus 33% oli alla 44-aastastel meestel (ei vastanud tingimusele sex = F). Viimased moodustasid pardal olnutest 27%.\nSageli on arvutatud otsusepuu liiga lihtne, mida võib öelda ka eelneva näite kohta. Sellisel juhul saame täpsustada argumendi control abil muuhulgas järgnevaid parameetreid:\n\nväikseim vaatluste arv harus (minsplit);\nväikseim vaatluste arv lõppsõlmes (minbucket).\nkeerukus (cp), mille puhul väiksem arv näitab suuremat keerukust;\n\n\npuu &lt;- rpart(survived ~ sex + age + category, estonia, \n             control = list(minsplit = 20, \n                            minbucket = 10, \n                            cp = 0.005))\nrpart.plot(puu)\n\n\n\n\nJoonis 24.2: Keerukam otsusepuu\n\n\n\n\nKuna otsusepuu on statistiline mudel, siis saame seda kasutada prognoosimiseks. R keeles saame prognoosida kasutades funktsiooni predict(). Nt 23-aastase naissoost reisija pääsemise tõenäosuse saame leida alljärgnevalt. Kuigi tunnus category prognoosi ei mõjuta nagu näeme jooniselt Joonis 24.2, peame selle siiski täpsustama.\n\npredict(puu, list(sex = 'F', age = 23, category = 'P'))\n\n        1 \n0.1351351 \n\n\nNäeme, et nimetatud tunnustega pardal viibija pääsemise tõenäosus oli umbes 0.14. Sama tulemuse saame tegelikult lugeda ka ilma prognoosimata jooniselt Joonis 24.2.\nSaame otsusepuud kasutada ka mitme klassiga nimitunnuse seletamiseks. Käesoleva andmetabeli alusel võiksime kirjeldada nt reisijate päritoluriiki (country).\n\nlibrary('rpart')\npuu &lt;- rpart(country ~ sex + age + category, estonia)\nrpart.plot(puu)\n\n\n\n\nJoonis 24.3: Mitut klassi prognoosiv otsusepuu\n\n\n\n\nMitme klassiga väljundtunnuse korral kuvatakse otsusepuu sõlmedes vastavalt legendis esitatud järjestusele eraldi iga klassi tõenäosus. Sõlme värv vastab kõige suurema tõenäosusega (osakaaluga) klassile ja klassid, mis üheski sõlmes ei domineeri, on legendis märkega “(unused)”. Näeme, et kui pardal viibija oli meeskonnaliige (category = C), siis oli ta 88% juhtudest pärit Eestist. Kui isik ei olnud meeskonnaliige (mitte category = C) ja oli 42-aastane või vanem (mitte age &lt; 42), siis oli ta 85% tõenäosusega pärit Rootsist ja ainult 10% juhtudest Eestist.\nOtsusepuu iga hargnemine oleneb sellest, mis sisendtunnus ja millised selle sisendtunnuse väärtused vaatluste jaotamisel aluseks võetakse. Igas sõlmes valitakse selline sisendtunnus ja selle väärtus või lävend, mis jagaksid vaatlused väljundtunnuse väärtuste osas võimalikult selgelt kaheks. Või siis teistipidi, hargnemise tulemusel peaks vähenema andmetes olev entroopia ehk korratus. Eesmärk on jõuda selliste harudeni, milles oleksid võimalikult sarnase väljundtunnuse väärtusega vaatlused. Nt joonisel Joonis 24.1 esitatud otsusepuu alusel võime öelda, et kõige selgemini jaotab reisijad pääsenuteks ja mitte pääsenuteks nende vanus ning lävend on sealjuures 44 eluaastat.\nOtsusepuul on palju eeliseid teiste meetodite ees:\n\notsusepuu on mudelina lihtsasti tõlgendatav ja arusaadav igaühele,\nerinevalt paljudest teistest mudelitest ei sea otsusepuu piiranguid kasutavate tunnuste mõõtmisskaalale,\npuuduvad väärtused saab enamike algoritmide korral määratleda eraldi tunnuse väärtusena,\nerindid on tuvastatavad ega mõjuta ülejäänud mudelit,\ninteraktsioonid on puu ülesehituses ja neid ei pea eraldi määratlema.\n\nOtsusepuu puuduseks on selle tundlikkus andmetes oleva müra suhtes. See tähendab, et otsusepuu kirjeldab liiga täpselt selle aluseks olevaid andmeid ega sobi seega prognoosimiseks. Seetõttu kasutatakse prognoosimiseks hoopis korraga suurel hulgal juhuslikke otsusepuusid ehk juhumetsa (random forest)."
  },
  {
    "objectID": "lähinaabrid.html",
    "href": "lähinaabrid.html",
    "title": "25  Lähinaabrid",
    "section": "",
    "text": "Vaatluse lähimad naabrid on sellised vaatlused, mis valitud tunnuse väärtuste mõttes on meid huvitavale vaatlusele kõige sarnasemad ehk asuvad sellele kõige lähemal. Läheduse määrab statistiline kaugus (Peatükk 16), mistõttu sarnasuse aluseks olevad tunnused peavad olema mõõdetud arvskaalal. Lähinaabrite meetodil ei ole muid eeldusi, aga tuleb arvestada, et liiga suure arvu tunnuste alusel kauguse mõõtmisega kaasnevad ka suured kaugused. Selle tulemusel ei pruugi kaugused enam vaatluste sarnasust hästi iseloomustada (curse of dimensionality).\n\n\n\n\n\n\nImportant\n\n\n\nLähinaabrid (k-nearest neighbors) tähendab igale vaatlusele kõige sarnasemate vaatluse valimist tunnuste ruumis lähtudes statistilisest kaugusest. Sealjuures peab olema eelnevalt määratud lähimate vaatluste arv \\(k\\). Vaatluste võrdlemisel lähimate naabritega saame prognoosida selliste tunnuste väärtusi, mida me ei kasutanud kauguste arvutamisel.\n\n\nLähinaabrite meetodit võib niisiis käsitleda ka statistilise mudeli või vähemalt algoritmina, milles sisendtunnusteks on kauguse arvutamisel aluseks olevad tunnused. Kui ei ole teada mõni vaatluse väljundtunnuse väärtus, siis selle saab tuletada lähimate naabrite vastava tunnuse väärtuste alusel. Sealjuures on prognoosimisel tegemist klassifitseerimisega nimiskaalal väljundtunnuse korral ja regressiooniga kui väljundtunnus on arvskaalal.\nLähinaabrite meetodi rakendamine prognoosimiseks koosneb alljärgnevatest sammudest.\n\nValime lähimate naabrite arvu \\(k\\). Kõige sobivama \\(k\\) leidmiseks saame kogu tegevust erinevate \\(k\\) väärtustega korrata ja valida sellise \\(k\\), mis annab kõige täpsema prognoosi.\nArvutame kõikide vaatluste vahel Eukleidilise kauguse tunnuste ruumis.\nMäärame igale vaatlusele arvu \\(k\\) lähimad vaatlused.\nNimiskaalal väljundtunnuse korral määrame igale vaatlustele naabrite seas kõige sagedasema nimitunnuse väärtuse. Arvskaalal väljundtunnuse puhul on prognoos aga naabrite väärtuste nt aritmeetiline keskmine.\n\nLähinaabrite meetodi alusel prognoosimise puuduseks on prognooside sõltuvus arvust \\(k\\). Samuti on meetod arvutuslikult kulukas, sest iga vaatluse kohta tuleb kõik kaugused teistest vaatlustest eraldi leida.\nKasutame järgnevas näites andmeid iirise taimede erinevate osade suuruste ja liigi kohta. Vaatame esimesi ridu ja loetleme liikide esinemissagedused.\n\nhead(iris)\n\n    Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n33           5.2         4.1          1.5         0.1     setosa\n84           6.0         2.7          5.1         1.6 versicolor\n70           5.6         2.5          3.9         1.1 versicolor\n74           6.1         2.8          4.7         1.2       &lt;NA&gt;\n42           4.5         2.3          1.3         0.3     setosa\n111          6.5         3.2          5.1         2.0  virginica\n\ntable(iris$Species, useNA = 'ifany')\n\n\n    setosa versicolor  virginica       &lt;NA&gt; \n        44         43         43         20 \n\n\nAndmetabelis on õietupe (sepal) ja õiekrooni (petal) pikkused ja laiused ning liik (Species). Sagedustabelist ilmneb, et 20 taime puhul on liik teadmata.\nUurime seost õietupe suuruste ja liigi vahel.\n\nlibrary('ggplot2')\nggplot(iris) + aes(x = Sepal.Length, y = Sepal.Width, color = Species) + \n  geom_point() +\n  theme_minimal()\n\n\n\n\nJoonis 25.1: Hajuvusjoonis õietupe mõõtmete kohta.\n\n\n\n\nNäeme, et õietupe mõõtmete alusel on võimalik teatud juhtudel tuletada liik. Kasutame laiendusest cccd funktsiooni nng(), et leida ja joonistada iga punkti üks lähim naaber (\\(k = 1\\)).\n\nlibrary('cccd')\nlnJoonis &lt;- iris[, 1:2] %&gt;% as.matrix %&gt;% nng(k = 1)\npar(mar = rep(0,4))\nplot(lnJoonis, \n     edge.arrow.size = .5, \n     vertex.size = 5, vertex.label = NA, \n     vertex.color = iris$Species)\n\n\n\n\nJoonis 25.2: Iirise taimede lähimad naabrid \\(k = 1\\) korral.\n\n\n\n\nJoonisel Joonis 25.2 on valgega tähistatud need taimed, mille liik on teadmata. Määrame selle liigi lähima naabri liigi alusel, kasutades funktsiooni knn laiendusest class. Selleks peame funktsiooni argumentidena andma sisendtunnuste väärtused eraldi teada olevate ja teadmata liikidega ridade kohta. Samuti peame andma liigid nende ridade kohta, kus see on teada.\n\nlibrary('class')\nln &lt;- knn(train = iris[!is.na(iris$Species), 1:2], # Teada liigiga read\n          test = iris[is.na(iris$Species), 1:2], # Teadmata liigiga read\n          cl = iris[!is.na(iris$Species), 'Species'], # Teada liigid\n          k = 1) # Naabrite arv\nln\n\n [1] versicolor virginica  setosa     versicolor versicolor virginica \n [7] setosa     virginica  virginica  setosa     setosa     virginica \n[13] setosa     setosa     virginica  versicolor virginica  versicolor\n[19] virginica  virginica \nLevels: setosa versicolor virginica\n\n\nFunktsioon knn väljastab prognoosid ridade kohta, mille korral liik oli teadmata. Saame nendega asendada puuduvad väärtused.\n\niris[is.na(iris$Species), 'Species'] &lt;- as.character(ln)\n\nKuvame joonisel Joonis 25.1 esitatud seose uuesti, et näha ka prognoositud liike.\n\nggplot(iris) + aes(x = Sepal.Length, y = Sepal.Width, color = Species) + \n  geom_point() +\n  theme_minimal()\n\n\n\n\nJoonis 25.3: Lähimate naabrite alusel asendatud liikidega hajuvusjoonis õietupe mõõtmete kohta.\n\n\n\n\nVõrdle tulemust joonistega Joonis 25.1 ja Joonis 25.2."
  },
  {
    "objectID": "hierarhiline.html#klastrite-leidmine",
    "href": "hierarhiline.html#klastrite-leidmine",
    "title": "26  Hierarhiline klasterdamine",
    "section": "26.1 Klastrite leidmine",
    "text": "26.1 Klastrite leidmine\nJärgnevalt uurime erinevate riikide elanike seas valitseivaid väärtushinnanguid. Maailma Väärtusuuringu käigus on küsitletud sadu tuhandeid inimesi erinevates maailma piirkondades. Selle tulemuseks on kultuurilised kaardid, milles on riikide asukoht kahel teljel: traditsioonilised või sekulaarsed väärtused ning ellu jäämise või eneseväljenduse väärtustamine1. Riigid on nendel kaartidel määratud kultuurilistesse rühmadesse tunnetuslikult. Vaatame, kas ja kui erinevad rühmad saame lähenedes hoopis statistiliselt, kasutades hierarhilist klasterdamist.1 Vaata kaarte uuringu kodulehelt.\nSisestame andmetabeli, milles on uuringusse kaasatud riikide elanike väärtushinnangute kahe telje keskmised väärtused. Kuigi hierarhilist klasterdamist saab rakendada ka suure tunnuste arvu korral, siis antud näites kasutame klasterdamise joonisel ilmestamiseks ainult kahte tunnust.\n\nlibrary('magrittr')\nwvs &lt;- read.csv('andmed/wvsmap.csv')\nrownames(wvs) &lt;- wvs$country\nwvs$country &lt;- NULL\nhead(wvs)\n\n             survexp   tradsec\nAlgeria    0.5142540 0.4864377\nAzerbaijan 0.3182427 0.5271867\nArgentina  0.8269262 0.6181080\nAustralia  1.2300503 0.8725773\nBahrain    0.5005984 0.5478684\nArmenia    0.3812617 0.4294143\n\n\nKa hierarhilisel klasterdamisel peaksime viima väärtused võrreldavale skaalale Antud juhul on kõik väärtushinnangud mõõdetud samal skaalal, seega ei ole standardiseerimine vajalik. Võime seda siiski teha, et lihtsamini hinnata riikide paiknemist keskmise suhtes.\n\nwvs[] %&lt;&gt;% lapply(scale) %&gt;% as.data.frame\n\nJoonistame nö kultuurilise kaardi, mis iseloomustab riikide paiknemist väärtushinnangute ruumis.\n\nlibrary('ggplot2')\nlibrary('ggrepel')\nSeos &lt;- ggplot(wvs) + \n  aes(x = survexp, y = tradsec, label = rownames(wvs)) + \n  labs(x = \"Ellu jäämine või eneseväljendus\", \n       y = \"Traditsioonilisus või sekulaarsus\") + \n  geom_point() + \n  geom_label_repel(size = 2) + \n  theme_minimal()\nSeos\n\nWarning: ggrepel: 32 unlabeled data points (too many overlaps). Consider\nincreasing max.overlaps\n\n\n\n\n\nHierarhilist klasterdamist R keeles saab rakendada sammhaaval. Esmalt leiame funktsiooni dist() kasutades kauguste maatriksi, milles on Eukleidilised kaugused kõikide riikide vahel. Seda tuleb teha ilma puuduvate väärtusteta. Seejärel laseme funktsioonil hclust() tuletada klasterduspuu Wardi ühenduse alusel. Lõpuks võime saadud puu teisendada puujoonise objektiks funktsiooniga as.dendrogram().\n\nkaugused &lt;- dist(na.omit(wvs), method = 'euclidean')\npuu &lt;- hclust(kaugused, method = 'ward.D2')\npuujoonis &lt;- as.dendrogram(puu)\nplot(puujoonis, type = 'triangle')\n\n\n\n\nSaame joonistada ka konkreetse haru, kui lõikame puud teatud kõrgusel. Nt Eesti on vasakult 4. harus, kui lõikame puud kõrgusel 3.\n\ncut(puujoonis, h = 3)$lower[[4]] %&gt;% plot\n\n\n\n\nVertikaalse joone kõrgus näitab kaugust järgmisest vaatlusest või klastrist. Kui jätta andmed standardiseerimata, siis selle kauguse skaala ja ühikud on ühend klasterdamise aluseks olevate tunnuste skaaladest ja ühikutest."
  },
  {
    "objectID": "hierarhiline.html#ühendamise-viisid",
    "href": "hierarhiline.html#ühendamise-viisid",
    "title": "26  Hierarhiline klasterdamine",
    "section": "26.2 Ühendamise viisid",
    "text": "26.2 Ühendamise viisid\nKahe objekti korral on kauguste määramine lihtne, sest mõlemad objektid on esitatavad konkreetsete punktidena tunnuste ruumis. Kuidas mõõta aga kaugust mitmest objektist koosneva klastri ja mõne objekti vahel? Sellisel juhul tuleb otsustada, mis punkt esindab klastrit ja selleks on palju võimalusi. Kui soovime teada kaugust \\(d\\) objekte \\(i\\) ja \\(j\\) sisaldava klastri \\(L\\) ja kõikide teiste klastrite \\(K\\) vahel, siis saame kasutada muuhulgas ühte alljärgnevatest ühendamise viisidest (linkage method):\n\nüksikühendus (single linkage): \\(d_{L,k} = min(d_{i,K}, d_{j,K})\\);\ntäisühendus (complete linkage): \\(d_{L,k} = max(d_{I,K}, d_{J,K})\\);\nkeskmine ühendus (average linkage): \\(d_{L,k} = \\sum_{i \\in L} \\sum_{k \\in K} d_{ik} / (n_{L}n_k)\\);\nWardi ühendus (Ward’s method): võrdleme klastritesisest ja klastritevahelist ruutkaugusi.\n\nUurime, kuidas erinevad käesolevate andmete näitel saadud klastripuud erinevate ühedamise viiside korral.\n\npar(mfrow = c(1,4), mar = c(0,4,2,0))\nfor (i in c('single', 'complete', 'average', 'ward.D2')) {\n  dist(wvs) %&gt;% hclust(method = i) %&gt;% plot(main = i, cex = .5)\n}\n\n\n\n\nÜksikühenduse korral kipuvad klastritesse lisanduma objektid järjest ahelana ja selle tulemuseks on enamasti suured ja mitte kuigi ühtsed klastrid. Täisühenduse korral tekivad vastupidiselt väikesed klastrid, mis on sarnased lähedal asuvate klastritega. Keskmine ühendus on kesktee nende vahel. Kuigi Wardi ühendus ei ole vaistlikult mõistetav, annab see enamasti kõige loomulikumad klastrid."
  },
  {
    "objectID": "hierarhiline.html#klastrite-arv-ja-puujoonis",
    "href": "hierarhiline.html#klastrite-arv-ja-puujoonis",
    "title": "26  Hierarhiline klasterdamine",
    "section": "26.3 Klastrite arv ja puujoonis",
    "text": "26.3 Klastrite arv ja puujoonis\nTähtsaim hierarhilise klasterdamise eelis on selle tulemusel tekkiv puujoonis, mis näitlikustab klastrite järk-järgulist moodustumist ja hierarhilist ülesehitust. Klastripuud teatud kõrgusel lõigates jääb iga objekt konkreetsesse klastrisse ja nii saab puujoonist kasutada ka konkreetsete klastrite määramiseks objektidele. Vastava kõrguse määramine on paljuski tunnetuslik, aga soovitus on lõigata klastripuu sellisel kõrgusel, kus harud on pikimad.\nKlastrite määramiseks on kaks võimalust: lõigata puu teatud kõrgusel või teatud klastrite arvu juures. Saame vaadata, millised klastrid tekivad, kui lõikame puu nt kõrgusel 0,5 või selliselt, et klastreid oleks kuus.\n\nplot(puujoonis)\nrect.hclust(puu, h = .5, border = 'red')\nrect.hclust(puu, k = 6, border = 'blue')\n\n\n\n\nKlastrid saame puu alusel määrata igale vaatlusele funktsiooniga cutree(). Argumendiga h saame määrata soovitud puu lõikamise kõrguse ja argumenti k kasutades määrame klastrite arvu. Tulemuse saame sisestada andmetesse eraldi veeruna.\n\nklastridH &lt;- cutree(puu, h = .5)\nklastridK &lt;- cutree(puu, k = 6)\nwvs$klaster &lt;- klastridK\nhead(wvs)\n\n              survexp    tradsec klaster\nAlgeria    -0.5534204 -0.7420832       1\nAzerbaijan -1.2414307 -0.5850448       1\nArgentina   0.5440756 -0.2346523       2\nAustralia   1.9590629  0.7460210       3\nBahrain    -0.6013524 -0.5053418       1\nArmenia    -1.0202307 -0.9618397       1\n\n\nKlastrite iseloomustamiseks on palju võimalusi (Peatükk 17). Antud andmete korral võiksime eristada klastreid nö kultuurilisel kaardil.\n\nSeos + \n  aes(color = as.factor(klastridK)) + \n  labs(color = \"Klaster\")\n\nWarning: ggrepel: 35 unlabeled data points (too many overlaps). Consider\nincreasing max.overlaps\n\n\n\n\n\nKlasterdamine on loominguline, sest klastritele peame tähenduse määrama ise. Nt klastris 6 on Põhjamaad, samas kui klaster 1 iseloomustab traditsioonilisi ühiskondi, kus väärtushinnangud on seotud hakkama saamisega."
  },
  {
    "objectID": "kkeskmised.html#klastrite-leidmine",
    "href": "kkeskmised.html#klastrite-leidmine",
    "title": "27  K-keskmised",
    "section": "27.1 Klastrite leidmine",
    "text": "27.1 Klastrite leidmine\nAlljärgnevas klasterdamise näites kasutame enne 1983. aastat tootmises olnud autode mudelite andmeid. Üritame jaotada autod klastritesse mitmesuguseid mõõtmeid ja teisi suurusi iseloomustavate tunnuste alusel. Sisestame klasterdamiseks kasutatavad arvtunnused lihtsuse huvides eraldi objekti.\n\nlibrary('magrittr')\nautod &lt;- read.csv('andmed/vehicles1983.csv')\nstr(autod)\n\n'data.frame':   392 obs. of  9 variables:\n $ mpg         : num  18 15 18 16 17 15 14 14 14 15 ...\n $ cylinders   : int  8 8 8 8 8 8 8 8 8 8 ...\n $ displacement: num  307 350 318 304 302 429 454 440 455 390 ...\n $ horsepower  : int  130 165 150 150 140 198 220 215 225 190 ...\n $ weight      : int  3504 3693 3436 3433 3449 4341 4354 4312 4425 3850 ...\n $ acceleration: num  12 11.5 11 12 10.5 10 9 8.5 10 8.5 ...\n $ year        : int  70 70 70 70 70 70 70 70 70 70 ...\n $ origin      : chr  \"American\" \"American\" \"American\" \"American\" ...\n $ name        : chr  \"chevrolet chevelle malibu\" \"buick skylark 320\" \"plymouth satellite\" \"amc rebel sst\" ...\n\nautotunnused &lt;- autod[, 1:7]\n\nArvtunnused mõõdavad erinevaid nähtusi ja on nii ka väga erinevatel skaaladel. Seetõttu on vajalik need väärtused enne igasuguste kauguste mõõtmist tunnuste ruumis ühtlasele skaalale viia. Samuti ei saa me mõõta kaugusi, kui mõnede vaatluste asukoht tunnuste ruumis on teadmata. Seega tuleb sellised vaatlused välja arvata.\n\nhead(autotunnused)\n\n  mpg cylinders displacement horsepower weight acceleration year\n1  18         8          307        130   3504         12.0   70\n2  15         8          350        165   3693         11.5   70\n3  18         8          318        150   3436         11.0   70\n4  16         8          304        150   3433         12.0   70\n5  17         8          302        140   3449         10.5   70\n6  15         8          429        198   4341         10.0   70\n\nautotunnused %&lt;&gt;% scale %&gt;% na.omit\nhead(autotunnused) %&gt;% round\n\n     mpg cylinders displacement horsepower weight acceleration year\n[1,]  -1         1            1          1      1           -1   -2\n[2,]  -1         1            1          2      1           -1   -2\n[3,]  -1         1            1          1      1           -2   -2\n[4,]  -1         1            1          1      1           -1   -2\n[5,]  -1         1            1          1      1           -2   -2\n[6,]  -1         1            2          2      2           -2   -2\n\n\nSeoseid arvtunnuste vahel saame ilmestada paariviisiliste hajuvusjoonistega.\n\npairs(autotunnused, pch = 20, cex = .2, oma = c(2,2,2,2))\n\n\n\n\nKuigi tunnuste paariviisilisel uurimisel ei ilmne klastreid, võivad need siiski olla peidus mitme tunnuse hajuvuses. Paljude tunnuste hajuvust saame enamasti suurel määral ilmestada kahe peakomponendiga.\n\npeakomponendid &lt;- prcomp(autotunnused)\nplot(peakomponendid$x[, 1:2], pch = 20)\n\n\n\n\nSaame jooniselt eristada vähemalt kolm punktikogumikku. Seega võiks nende tunnuste alusel autod jaotada kolmeks sisemiselt sarnaseks rühmaks. R keeles saame k-kesmiste alusel klastrid arvutada funktsiooniga kmeans(), mille argumendi centers väärtuseks peame sisestama soovitud klastrite arvu (või iga soovitud klastri algsed keskpunktid). Leiame alustuseks kolm klastrit.\n\nkkesk &lt;- kmeans(autotunnused, centers = 3)\nkkesk\n\nK-means clustering with 3 clusters of sizes 138, 154, 100\n\nCluster means:\n         mpg  cylinders displacement horsepower     weight acceleration\n1  1.0950451 -0.8374221   -0.8335268 -0.7870762 -0.8530516    0.4273365\n2 -0.2548908 -0.2043414   -0.1960231 -0.2407849 -0.1142129    0.2808791\n3 -1.1186304  1.4703282    1.4521425  1.4569738  1.3530991   -1.0222782\n        year\n1  0.8041935\n2 -0.3276197\n3 -0.6052528\n\nClustering vector:\n  [1] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 2 2 2 2 2 2 2 2\n [38] 3 3 3 3 3 3 3 2 2 2 2 2 2 1 2 1 1 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 2 3 3 3\n [75] 3 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 2 2 2 2 2 1 3 3 3 3 2 2 2 2 2\n[112] 2 2 2 3 3 1 2 2 2 3 2 2 3 2 2 2 1 2 1 2 2 2 2 3 3 3 3 3 1 1 2 1 1 1 2 2 2\n[149] 2 1 2 2 2 2 3 3 3 3 2 2 2 2 2 3 3 1 2 2 2 2 1 2 2 1 2 2 2 2 2 1 1 1 2 1 1\n[186] 3 3 3 3 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 2 2 3 2 2 2 3 3 3 3 1 1 1 1 1 3 2 3\n[223] 3 2 2 2 2 3 3 3 3 1 2 1 2 1 1 1 1 2 2 2 1 1 1 1 1 2 3 3 2 2 2 1 2 2 2 2 2\n[260] 2 3 3 3 3 1 1 1 1 2 2 2 1 2 2 2 2 1 1 2 2 2 2 2 3 3 3 3 3 3 3 3 1 1 1 1 2\n[297] 3 1 2 1 1 1 1 1 2 2 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n[334] 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 1 1 1 1 1 1 1 1\n[371] 1 1 1 1 1 1 1 1 1 1 2 1 1 2 1 1 1 1 1 1 1 1\n\nWithin cluster sum of squares by cluster:\n[1] 295.6675 421.0669 211.1070\n (between_SS / total_SS =  66.1 %)\n\nAvailable components:\n\n[1] \"cluster\"      \"centers\"      \"totss\"        \"withinss\"     \"tot.withinss\"\n[6] \"betweenss\"    \"size\"         \"iter\"         \"ifault\"      \n\n\nFunktsioon väljastab mitmesuguseid parameetreid klasterdamise protsessi ja tulemuste kohta. Igale vaatlusele saame määrata andmetabelisse klastri, kasutades funktsiooni kmeans() tulemuse osist cluster. Nt kuna sisestasime eelnevalt klasterdamise tulemuse objekti kkesk, siis saame iga vaatluse klastri kätte käsuga kkesk$cluster.\n\nautod$klaster &lt;- kkesk$cluster\nhead(autod)\n\n  mpg cylinders displacement horsepower weight acceleration year   origin\n1  18         8          307        130   3504         12.0   70 American\n2  15         8          350        165   3693         11.5   70 American\n3  18         8          318        150   3436         11.0   70 American\n4  16         8          304        150   3433         12.0   70 American\n5  17         8          302        140   3449         10.5   70 American\n6  15         8          429        198   4341         10.0   70 American\n                       name klaster\n1 chevrolet chevelle malibu       3\n2         buick skylark 320       3\n3        plymouth satellite       3\n4             amc rebel sst       3\n5               ford torino       3\n6          ford galaxie 500       3\n\n\n\n\n\n\n\n\nWarning\n\n\n\nFunktsioon kmeans() määrab klastri numbri juhuslikult, mistõttu võib samal klastril olla igal järgmisel klastrite leidmisel erinev number."
  },
  {
    "objectID": "kkeskmised.html#klastrite-arv",
    "href": "kkeskmised.html#klastrite-arv",
    "title": "27  K-keskmised",
    "section": "27.2 Klastrite arv",
    "text": "27.2 Klastrite arv\nKuna k-keskmiste korral leitakse sobivamad klastrid vaatluste kogumi korduva tükeldamise teel, siis ei ole selle tulemuseks klastrite hierarhiat, mida saaks kujutada puujoonisel. Nii ei saa kasutada puujoonist ka klastrite valimiseks.\nKõige sobivama klastrite arvu määramiseks saame aga kasutada nn Gap mõõdikut (Gap statistic). Selle mõõdiku väärtus iseloomustab, kui palju väiksemad on klastrisisesed kaugused teatud klastrite arvu korral olemasolevate andmete korral võrreldes ühtlase jaotusega andmetega. Kui klastrite lisamine annab väiksemad klastrisisesed kaugused, siis peaksime kasutama rohkem klastreid ja vastupidi. Sealjuures peame arvesse võtma ka mõõdiku usaldusvahemikke ja valima suurema klastrite arvu ainult juhul, kui mõõdiku vastavad usaldusvahemikud ei kattu mõõdiku usaldusvahemikega väiksema arvu klastrite korral.\nSaame seda näitlikustada joonisega, mille saab tekitada funktsiooniga clusGap laiendusest cluster alljärgnevalt. Et teada saada klasterdamise tulemus erinevate klastrite arvuga, tuleb klasterdamist korrata ja selleks tekitame funktsiooni nimega kmFun().\n\nlibrary('cluster')\nkmFun &lt;- function(x, k) kmeans(x, k, nstart = 10)\nkmG &lt;- clusGap(autotunnused, kmFun, K.max = 10)\nplot(kmG)\n\n\n\n\nAntud joonisel on kujutatud, kui ühtsed klastrid me erineval arvul klastrite leidmisel saame. Peame joonise abil välja selgitama, millise klastrite arvu juures nende lisamine enam ühtsemaid klastreid ei anna. Näeme, et viie klastri kasutamine ei anna väiksemaid klastrisiseseid kaugusi kui nelja klastri korral. Seega on nende andmete klasterdamiseks sobilik kasutada hoopis nelja klastrit.\n\nkkesk &lt;- kmeans(autotunnused, centers = 4)\nautod$klaster &lt;- kkesk$cluster"
  },
  {
    "objectID": "kkeskmised.html#klastrite-esitamine",
    "href": "kkeskmised.html#klastrite-esitamine",
    "title": "27  K-keskmised",
    "section": "27.3 Klastrite esitamine",
    "text": "27.3 Klastrite esitamine\nKlastrite hierarhia asemel kujutatakse k-keskmiste alusel moodustunud klastreid enamasti hajuvusjoonisel, kus telgedel on kaks tunnuste peakomponenti ja klastrid on kujutatud erinevate värvidega.\n\nplot(peakomponendid$x[, 1:2], pch = 20, col = autod$klaster)\n\n\n\n\nNäeme, et esitatud kahe mõõtme alusel suutis algoritm üsna usutavalt vaatlused klastritesse jagada.\nVaatluse klastri määrab k-keskmise meetodi korral kõige lähem klastri keskpunkt, mis selgus korduva vaatluste jaotamis tulemusel nagu eelnevalt kirjeldatud. Funktsiooni kmeans() poolt väljastatud teabe seas on ka need klasterdamiseks kasutatud tunnuste keskmised saadud klastrite lõikes.\n\nkkesk$centers\n\n         mpg  cylinders displacement horsepower     weight acceleration\n1 -1.2389554  1.4820530    1.6560424  1.8158112  1.4504539   -1.3279887\n2 -0.2368393 -0.2460167   -0.2289452 -0.2463542 -0.1422559    0.2558054\n3  1.1085960 -0.8455407   -0.8409902 -0.8052580 -0.8641792    0.4500535\n4 -0.9035789  1.4310756    1.1415616  0.8931515  1.1805005   -0.4972196\n        year\n1 -1.1177572\n2 -0.3333457\n3  0.8058547\n4  0.1530746\n\n\nNeed tunnuste keskmised väärtused klastrite lõikes toovad enamasti ilmekalt esile klastrite eripärad.\nKlastritele iseloomustamiseks on veel võimalusi esitatud peatükis Peatükk 17."
  },
  {
    "objectID": "peakomponendid.html",
    "href": "peakomponendid.html",
    "title": "28  Peakomponentide analüüs",
    "section": "",
    "text": "29 Peakomponentide joonis\nKahte esimest peakomponenti saame kujutada erilisel peakomponentide hajuvusjoonisel (biplot), millel on esitatud ühtaegu vaatlused ja tunnused.\npar(mar = c(4,4,2,4))\nbiplot(peakomp)"
  },
  {
    "objectID": "peakomponendid.html#peakomponentide-tähendus",
    "href": "peakomponendid.html#peakomponentide-tähendus",
    "title": "28  Peakomponentide analüüs",
    "section": "28.1 Peakomponentide tähendus",
    "text": "28.1 Peakomponentide tähendus\nPeakomponentide analüüsi eesmärk on niisiis võtta kokku algsete tunnuste ühine hajuvus väiksema arvu uue tunnusena. Täpsemalt on eesmärk leida algsete tunnuste standardiseeritud lineaarsed kombinatsioonid, mis seletaksid võimalikult suurt osa hajuvusest andmetes. Iga lineaarne kombinatsioon esindab ühte viisi, kuidas teisendada algsed tunnused uuteks tunnusteks. Mõnel juhul piisab meile ainult paarist sellisest lineaarsest kombinatsioonist, aga sõltuvalt analüüsi probleemist võime kasutada ka mitut.\nIga lineaarne kombinatsioon on peakomponent, mis võtab kokku kordumatu osa andmetes esinevast hajuvusest. Peakomponente võib esitada kujul \\[\\xi_j = b_{j1}x_1 + b_{j2}x_2+ ... a_{jp}x_p,\\] kus \\(b_{jp}\\) on tunnuse \\(x_p\\) kaal \\(j\\)ndas peakomponendis \\(\\xi_j\\) . Nii võib peakomponente mõista sisuliselt tunnuste kaalude kogumitena. Peakomponentide järjestus või järjekorranumber on sealjuures tähtis: esimene peakomponent seletab võimalikult suure osa hajuvusest andmetes ja iga järgnev eelnevate poolt selemata jäänud osa.\nSuurim võimalik peakomponentide arv on \\(min(p, n-1)\\), kus \\(p\\) on tunnuste ja \\(n\\) vaatluste arv. Kuna enamasti \\(p &gt; n\\) , siis leitakse tavaliselt nii palju peakomponente kui oli algseid tunnuseid. Kõik peakomponendid kokku sisaldavad seega kogu hajuvust nende aluseks olevates andmetes selliselt, et võimalikult suur osa hajuvusest on koondatud esimestesse peakomponentidesse. Seega kui valime ainult esimesed peakomponendid, siis läheb kaduma küll osa hajuvusest, aga see kadu on võimalikult väike."
  },
  {
    "objectID": "peakomponendid.html#peakomponentide-leidmine",
    "href": "peakomponendid.html#peakomponentide-leidmine",
    "title": "28  Peakomponentide analüüs",
    "section": "28.2 Peakomponentide leidmine",
    "text": "28.2 Peakomponentide leidmine\nOn mitu viisi, kuidas mõtestada peakomponentide leidmist. Kõige loomulikum lähenemine on kujutada vaatlusi andmepilvena tunnuste ruumis. Mitme tunnuse hajuvuse saame kokku võtta, kui tõmbame sellest andmepilvena järjest läbi jooni, millest igaüks esindab ühte peakomponenti. Alustame sealjuures esimesest peakomponendist, mis peaks võtma kokku võimalikult suure osa hajuvusest andmepilves. Esimene peakomponent arvutatakse seega nii, et see\n\njärgiks ja esindaks suurimat hajuvust andmepilves ja\non sirgena võimalikult lähedal kõikidele andmepunktidele arvestades täisnurkset (ortogonaalset) kaugust.\n\nNäeme jooniselt, et kuulitõuke ja kettaheite soorituste vahel on positiivne korrelatsioon. Seega saame vähemal osaliselt nende kahe tunnuse hajuvuse kokku võtta peakomponendiga, mida näitab punane joon.\n\n\n\n\n\nSelliselt on esimese peakomponendi leidmine sarnane vähimruutude meetodile (Peatükk 22). Erinevalt vähimruutude meetodil leitud regressioonsirgest esimene peakomponent aga\n\nseletab kõikide tunnuste hajuvust võrdväärselt ja mitte ainult tagajärgse tunnuse hajuvust,\nei sõltu otseselt ruuthälvetest.\n\nSuurima hajuvuse tuvastamiseks teisendatakse andmepilv (andmemaatriks) uuele koordinaattasandile. See hõlmab enamasti alljärgnevaid samme:\n\nandmepilv keskmistatakse,\nkoordinaatteljed teisendatakse samale skaalale,\nkoordinaatteljed pööratakse vastavusse peakomponentidega.\n\nSealjuures toimub viimasel sammul telgede pööramine nii, et esimene peakomponent seletab võimalikult suure osa hajuvusest andmepilves ja iga järgnev peakomponent on lihtsalt täisnurkne (ortogonaalne) eelneva suhtes.\nEelnevalt kirjeldatud samme näitlikustab alljärgnev joonis.\n\n\n\n\n\nSeega sõltuvad leitud peakomponendid andmepilve asukohast ja hajuvusest telgedel.\n\n\n\n\n\n\nWarning\n\n\n\nPeakomponendide analüüsil tuleb silmas pidada algsete tunnuste keskmisi väärtuseid ja standardhälbeid.\n\nTunnused peaksid olema keskmistatud ehk igast tunnuse väärtusest tuleb lahutada kogu tunnuse keskmine väärtus.\nTunnused võib skaleerida ehk iga tunnuse väärtused võib jagada läbi tunnuse standardhälbega. Kui tunnused on mõõdetud samal skaalal, siis võib olla parem seda mitte teha.\n\n\n\nMatemaatiliselt arvutatakse peakomponendid kas korrelatsiooni-, kovariatsiooni või andmemaatriksi dekomponeerimise alusel. Selle tulemusel leitakse andmete\n\nskaleerimist kirjeldavad omaväärtused (eigenvalues) ehk iga peakomponendi kordajad ja\npööramist kirjeldavad omavektorid (eigenvectors) ehk iga peakomponendi pool seletatud hajuvus.\n\nR keeles saame peakomponentide leidmiseks kasutada funktsiooni prcomp(). Tunnused keskmistatakse vaikimisi (center = TRUE), aga enamasti peaksime lisama ka argumendi scale = TRUE, et lisaks sellele tunnuse väärtused ka skaleerida.\n\npeakomp &lt;- prcomp(kv, scale = TRUE)"
  },
  {
    "objectID": "peakomponendid.html#eeldused",
    "href": "peakomponendid.html#eeldused",
    "title": "28  Peakomponentide analüüs",
    "section": "28.3 Eeldused",
    "text": "28.3 Eeldused\nKõige olulisem peakomponentide analüüsi eeldus puudutab tunnuste mõõteskaalasid: ühist hajuvust saab leida võtta ainult pideval või vähemalt arvskaalal mõõdetud tunnuste korral. Nimi ja järjestustunnusete alusel saab leida peakomponendid, kui need eelnevalt pidevateks tunnusteks teisendada.\nTunnuste koondamiseks ühise hajuvuse alusel peab see ühine hajuvus andmetes olemas olema. Seega peab tunnuste vahel esineva piisav lineaarne korrelatsioon.\nKümnevõistluse võistlusalade vahel esinevad üldiselt ootuspärased ja sageli tugevad korrelatsioonid.\n\nlibrary('gplots')\n\n\nAttaching package: 'gplots'\n\n\nThe following object is masked from 'package:stats':\n\n    lowess\n\ncor(kv) %&gt;% heatmap.2(col = 'bluered', margins = c(8,8))\n\n\n\n\nKui vaatluste seas esineb erindeid, siis võivad need märkimisväärselt mõjutada peakomponentide aluseks olevat andmepilve teisendamist."
  },
  {
    "objectID": "peakomponendid.html#peakomponentide-arv",
    "href": "peakomponendid.html#peakomponentide-arv",
    "title": "28  Peakomponentide analüüs",
    "section": "28.4 Peakomponentide arv",
    "text": "28.4 Peakomponentide arv\nKuigi enamasti leitakse analüüsi käigus peakomponente sama palju kui oli nende aluseks olevaid tunnuseid, siis on asjakohased tavaliselt ainult esimesed nendest. Mitut esimest peakomponenti tõlgendada või edasises analüüsis kasutada, sõltub sellest, kui mitut on vaja analüüsi probleemi lahendamiseks[^Nt vaatluste klasterdamise tulemuse näitlikustamiseks tunnuste alusel kahemõõtmelisel joonisel piisab kahest peakomponendist.].\n\n\n\n\n\n\nTip\n\n\n\nSobiva arvu komponentide määramisel võib lähtuda alljärgnevatest tingimustest.\n\nMäära kõige madalam hajuvus andmetes, mida peakomponendid seletama peaksid ja vali nii palju peakomponente kui on selleks vajalik.\nKasuta peakomponende, mille omaväärtus on vähemalt üks.\nLeia omaväärtuse joonisel nö õlg ja vali peakomponendid enne seda.\n\n\n\nPeakomponentide poolt seletatud hajuvust saab joonisel kujutada mitmel viisl.\n\npar(bty = 'n', mfrow = c(1,3))\nplot(peakomp$sdev^2 * 100/length(peakomp$sdev), type = 'b', ylim = c(0,100), \n     xlab = \"Peakomponent\", ylab = \"Komponendi poolt seletatud hajuvus, %\")\nplot(cumsum(peakomp$sdev^2 * 100/length(peakomp$sdev)), type = 'b', ylim = c(0,100), \n     xlab = \"Peakomponent\", ylab = \"Seletatud hajuvus kumulatiivselt, %\")\nplot(peakomp$sdev^2, type = 'p', \n     xlab = \"Peakomponent\", ylab = \"Omaväärtus\")\nabline(h = 1)\n\n\n\n\nNäeme nt, et esimene peakomponent üksi seletab 35% kogu hajuvusest ja 80% hajuvuse seletamiseks on vaja vähemalt viite peakomponenti. Kõige parempoolsel, omaväärtuse joonisel (scree plot) näeme, et nö õlg on pärast neljandat peakomponenti, nii et antud andmete korral võiksimegi piirduda nelja peakomponendiga."
  },
  {
    "objectID": "peakomponendid.html#tõlgendamine",
    "href": "peakomponendid.html#tõlgendamine",
    "title": "28  Peakomponentide analüüs",
    "section": "28.5 Tõlgendamine",
    "text": "28.5 Tõlgendamine\n\n28.5.1 Seletatud hajuvus\nOsakaal koguhajuvusest andmetes, mille \\(j\\)ndas peakomponent seletab on arvutatav omaväärtuste \\(\\lambda\\) alusel: see on vastava omaväärtuse osa omaväärtuste summast ehk \\(\\lambda_j / \\Sigma^p_{j=1} \\lambda\\).\nPeakomponentide omaväärtused saame R keeles, kui võtame peakomponentide standardhälbed ruutu.\n\npeakomp$sdev^2 %&gt;% round(2)\n\n [1] 3.54 1.97 1.42 0.90 0.56 0.53 0.43 0.37 0.16 0.11\n\n\nNäeme, et esimene peakomponent esindab umbes 4 tunnuse hajuvust.\nKuna omaväärtuste summa \\(\\Sigma^p_{j=1} \\lambda\\) on võrdne tunnuste arvuga, siis peakomponendi omaväärtus näitab, kui mitme algse tunnuse hajuvust või kui mitut algset tunnust vastav peakomponent esindab. Seega saame iga peakomponendi poolt seletatud hajuvuse osakaalu, kui jagame vastava omaväärtuse tunnuste arvuga.\n\n(peakomp$sdev^2 / ncol(kv)) %&gt;% round(2)\n\n [1] 0.35 0.20 0.14 0.09 0.06 0.05 0.04 0.04 0.02 0.01\n\n\nNäeme, et esimene peakomponent seletab 35% hajuvusest andmepilves ja kaks esimest peakomponenti üle poole. Sama tulemuse saame ka peakomponendi objekti kokkuvõttest funktsiooni summary() abil.\n\nsummary(peakomp)\n\nImportance of components:\n                          PC1    PC2    PC3     PC4     PC5     PC6     PC7\nStandard deviation     1.8827 1.4036 1.1924 0.95052 0.75075 0.72679 0.65792\nProportion of Variance 0.3545 0.1970 0.1422 0.09035 0.05636 0.05282 0.04329\nCumulative Proportion  0.3545 0.5515 0.6936 0.78398 0.84035 0.89317 0.93645\n                           PC8     PC9    PC10\nStandard deviation     0.60482 0.40435 0.32580\nProportion of Variance 0.03658 0.01635 0.01061\nCumulative Proportion  0.97304 0.98939 1.00000\n\n\nSeletatud hajuvusest lähtudes saame leida ka, kui suure osa hajuvusest seletavad teatud arv esimesi peakomponente. Sisuliselt näitab seletatud hajuvus, kui suur osa andmetes olevast teabest jääb alles, kui võtame algsed tunnused kokku teatud arvul peakomponentidena.\n\n\n28.5.2 Kordajad\nPeakomponendid tuletatakse tunnustest ja nii on igal tunnusel igale peakomponendile. Teisisõnu, iga tunnus laadib igat peakomponenti ja sedalaadimist mõõdab vastav kordaja või laadung (loading). Neid võib mõista ka kui tunnuste kaale. Kordajaid saab kasutada peakomponentide tõlgendamiseks, et anda neile sisuline tähendus.\nR keeles kuvatakse kordajaid, kui sisestame käsureale lihstalt peakomponendi objekti või uurime selle objekti osist rotation.\n\npeakomp$rotation %&gt;% round(2)\n\n                PC1   PC2   PC3   PC4   PC5   PC6   PC7   PC8   PC9  PC10\nrun100m       -0.42  0.18 -0.21 -0.08 -0.27  0.06  0.05 -0.64 -0.50 -0.02\nrun400m       -0.39  0.35  0.19 -0.12 -0.24  0.23  0.22  0.21  0.28  0.63\nrun1500m      -0.11  0.34  0.66  0.06  0.20  0.27  0.15  0.15 -0.30 -0.44\nrun110mhurdle -0.38  0.17 -0.04 -0.12  0.42 -0.75  0.25  0.07  0.04 -0.04\nlongjump      -0.42  0.23 -0.13 -0.01 -0.18  0.01 -0.64  0.14  0.36 -0.40\nhighjump      -0.33 -0.34  0.01 -0.11  0.67  0.35 -0.33 -0.07 -0.10  0.27\npolevault     -0.10  0.23 -0.52  0.64  0.17  0.20  0.17  0.34 -0.19  0.00\nshotput       -0.33 -0.44 -0.02  0.14 -0.04  0.22  0.51 -0.18  0.45 -0.35\ndiscus        -0.29 -0.48 -0.01 -0.21 -0.34 -0.08  0.02  0.57 -0.44 -0.05\njaveline      -0.15 -0.24  0.44  0.69 -0.16 -0.30 -0.24 -0.15 -0.03  0.23\n\n\nNäeme, et esimene peakomponent iseloomustab kõikide alade soorituste nõrkust, sest kõik kordajad on negatiivsed. Seega on iseloomustab esimene komponent võistleja üldist võimekust või kui arvestada negatiivseid kordajaid, siis võimetust. Teine komponent kirjeldab sooritust jooksudel, aga on negatiivselt seotud viskealadega (shotput, discus, javeline).\nNeid kordajaid saame kasutada selleks, et leida peakomponentide väärtused iga vaatluse jaoks. Kui korrutame iga kordaja sellele vastava tunnuse väärtustega, siis saame peakomponentide skoorid. Need on peakomponente esindavad uued tunnused, mis näitavad peakomponendi väärtust iga 28 võistleja kohta.\n\npeakomp$x %&gt;% round(2)\n\n              PC1   PC2   PC3   PC4   PC5   PC6   PC7   PC8   PC9  PC10\nSebrle      -3.65 -1.50  0.22  1.74  0.13 -0.29 -0.44  0.52  0.79  0.19\nClay        -3.60 -0.85 -0.32  1.16 -0.93 -0.82 -1.26 -0.29 -0.77 -0.08\nKarpov      -4.20 -0.42 -0.35 -1.70 -0.69  0.32  0.40  0.45  0.07  0.23\nMacey       -1.90 -1.34  1.24 -1.09  0.59  1.08 -0.22  0.21  0.08 -0.40\nWarners     -1.90  1.70 -0.89 -0.50 -0.15 -0.28 -0.03 -0.05  0.21  0.09\nZsivoczky   -0.70 -1.25  1.02  0.53  0.52  1.31 -0.18 -0.21 -0.31  0.32\nHernu       -0.69  0.51  0.73 -0.17  0.90  0.26  0.55  0.61 -0.21  0.08\nNool        -0.18  1.74 -0.99  1.97 -0.77  0.53 -0.07  0.36 -0.09  0.05\nBernard     -1.57 -0.13  0.11 -1.64  0.87  0.11 -0.46 -0.75 -0.02  0.07\nSchwarzl     0.09  1.45 -0.72  0.49  0.61 -0.30 -0.15  0.68  0.01 -0.47\nPogorelov   -0.26 -0.61 -1.75 -0.23  1.30 -0.09  0.16  0.20  0.15 -0.47\nSchoenbeck   0.12  0.29 -0.55  1.00 -0.36 -0.79  0.42  0.18 -0.11 -0.61\nBarras       0.29 -0.38  1.65  0.61  0.13 -0.60  0.71  0.42  0.17  0.05\nSmith       -0.47 -1.11  1.55 -1.10 -0.71 -1.48  1.51 -0.14 -0.51  0.07\nAveryanov   -0.22  1.71 -0.51 -0.29  0.22  0.18  0.34 -1.38 -0.38 -0.61\nOjaniemi    -0.12  0.78  0.19  0.10 -0.85  0.91 -0.32 -1.43  0.59 -0.26\nSmirnov      0.63  1.05  1.22  0.32 -0.10  0.37  0.09 -0.16 -0.64  0.25\nQi           0.73  0.18  1.00 -0.34 -0.26 -0.13 -1.08  0.49 -0.29  0.22\nDrews        0.42  3.08 -0.86 -0.55  0.47 -0.67  0.24  0.44 -0.06  0.29\nParkhomenko  1.31 -1.83  0.72  1.67  0.97  0.39  0.87 -0.77  0.21  0.21\nTerek        0.89 -0.26 -2.34  0.25 -0.41  1.52  1.31  0.69 -0.21  0.22\nGomez        0.64  1.08  1.51 -0.17 -0.56 -0.67  0.46 -0.19  1.15 -0.03\nTuri         1.80 -0.19 -0.81  0.37  1.78 -1.12 -0.54 -0.69 -0.15  0.53\nLorenzo      2.58  1.53  1.61 -0.08 -0.80  0.88 -0.34 -0.05 -0.14  0.15\nKarlivans    2.32  0.19  0.14 -1.17  0.42  0.30 -1.13  0.93  0.32 -0.09\nKorkizoglou  1.46 -1.79 -2.95 -0.89 -1.03 -0.31 -0.13 -0.63  0.30  0.54\nUldal        2.88 -0.13  0.52  0.04 -0.74 -0.46 -0.54  0.20  0.04  0.03\nCasarsa      3.30 -3.49 -0.38 -0.35 -0.54 -0.16 -0.19  0.36 -0.18 -0.57\n\n\nEsimese peakomponendi skoore uurides näeme, et esimesed võistlejad on keskmisest märkimisväärselt võimekamad. Teise peakomponendi skoorid näitavad aga, et esimesed võistlejad on jooksualades keskmisest nõrgemad, aga paremad viskealadel.\nSealjuures tuleb arvestada tunnuste sisu. Mõne tunnuse kõrgem väärtus võib peakomponendi tähendusega hästi sobida, samas kui teise tunnuse korral sobiks paremini madalam väärtus. Sellisel juhul võib peakomponentide tõlgendamise lihtsustamiseks vahetada osade tunnuste märk, nt korrutades nende väärtused väärtusega \\(-1\\).\n\n\n\n\n\n\nWarning\n\n\n\nEsimese peakomponendi suund uuel koordinaatteljestikul on juhuslik. Seetõttu on igal peakomponentide arvutamisel kordajate absoluutväärtused küll samad, aga positiivsed märgid võivad järgmisel arvutamisel olla negatiivsed ja vastupidi."
  },
  {
    "objectID": "faktoranalüüs.html#faktormudel",
    "href": "faktoranalüüs.html#faktormudel",
    "title": "29  Faktoranalüüs",
    "section": "29.1 Faktormudel",
    "text": "29.1 Faktormudel\nFaktoranalüüsi käsitluses laadivad tunnuseid faktorid ehk mingid varjatud tunnused. Seega saame faktormudeli abil selgitada iga tunnuse väärtusi faktorite kordajate lineaarsete kombinatsioonidena:\n\\[x_j = q_{jl} F_l + U_j +\\mu_j,\\] kus\n\n\\(x_j\\) on tunnus \\(j\\),\n\\(q_{jl}\\) on \\(j\\)nda tunnuse \\(l\\)nda faktori kordaja,\n\\(F_l\\) on \\(l\\)ndas faktor,\n\\(U_j\\) on ainult \\(j\\)ndale tunnusele omane (unikaalne) hajuvus ja\n\n\\(\\mu_j\\) on tunnuse \\(x_j\\) keskmine väärtus.\n\nEnne faktoranalüüsi kajastavad tunnuste väärtused ainult tunnustele omast hajuvust \\(U_j\\) koos tunnuse keskmisega \\(\\mu_j\\). Faktoranalüüsi tulemusel eraldatakse sellest faktor \\(q_{jl} F_l\\), mida saame seejärel kirjeldada. Faktorite arvutamiseks kasutatakse tunnustevahelisi korrelatsioone, millest faktorite tuletamiseks on mitu viisi.\nKuigi R keeles on funktsioon factanal(), siis palju rohkem võimalusi pakub funktsioon fa() laiendusest psych.\n\nlibrary('psych')\nfaktorid &lt;- fa(surm, nfactors = 7, rotate = 'none')\n\nWarning in fa.stats(r = r, f = f, phi = phi, n.obs = n.obs, np.obs = np.obs, :\nThe estimated weights for the factor scores are probably incorrect.  Try a\ndifferent factor score estimation method.\n\n\nWarning in fac(r = r, nfactors = nfactors, n.obs = n.obs, rotate = rotate, : An\nultra-Heywood case was detected.  Examine the results carefully"
  },
  {
    "objectID": "faktoranalüüs.html#faktorite-arv",
    "href": "faktoranalüüs.html#faktorite-arv",
    "title": "29  Faktoranalüüs",
    "section": "29.2 Faktorite arv",
    "text": "29.2 Faktorite arv\nSobiva arvu faktorite määramisel võib jällegi kasutada samasid põhimõtteid, mida peakomponentide analüüsi korral. Kuna faktoranalüüs on mõneti loomingulisem, siis võib vabamalt läheneda ka faktorite valikule. Näiteks võib lähtuda faktorite kordajatest või unikaalsusest. Kui mõnel tunnusel on väga kõrge unikaalsus, siis faktorite lisamine võib aidata sellist tunnust lisanduva faktori abil seletada.\nSamuti saab välja selgitada sobiva faktorite arv funktsiooni fa.parallel() abil. Lisaks joonisele nimetatakse sellisel juhul sobivaim faktorite arv ka käsureal.\n\nfa.parallel(surm)\n\nWarning in fa.stats(r = r, f = f, phi = phi, n.obs = n.obs, np.obs = np.obs, :\nThe estimated weights for the factor scores are probably incorrect.  Try a\ndifferent factor score estimation method.\n\n\n\n\n\nParallel analysis suggests that the number of factors =  7  and the number of components =  6 \n\n\nJoonisele järgnevast sõnumist saame järeldada, et sobivaim faktorite arv ette antud andmete analüüsimiseks on 7."
  },
  {
    "objectID": "faktoranalüüs.html#pööramine",
    "href": "faktoranalüüs.html#pööramine",
    "title": "29  Faktoranalüüs",
    "section": "29.3 Pööramine",
    "text": "29.3 Pööramine\nFaktoranalüüsi eesmärgiks on enamasti saada sellised faktorid, millest igaüks seletaks võimalikult täpselt konkreetse tunnuse väärtusi nii, et iga tunnus saaks kokkuvõtteks seletatud. Selleks pööratakse algset faktorikordajate maatriksit nii, et faktorid oleksid teineteisest erinevad. Kuna pööramiseks on palju erinevaid viise, millest igaüks annab enamasti erineva tulemuse, siis toob see analüüsi erapoolikust. Teisalt lihtsustab pööramine tavaliselt faktorite tõlgendamist.\nEnamasti rakendatakse ühte kolmest alljärgnevast pööramisest. Sealjuures tasub tähele panna, et faktorite täisnurksust säilitatavate pööramistega kaasnevad eripärasemad faktorid, aga faktorid ise ei ole nii palju seotud konkreetsete tunnustega.\n\nVarimax pööramise korral maksimeeritakse kordajate ruutude hajuvust faktorite siseselt. Faktorite vahel puudub korrelatsioon. Selle tulemusel on igal faktor seotud võimalikult väheste tunnustega.\nOblimin pööramisel maksimeeritakse samuti kordajate ruutude hajuvust faktorite siseselt, aga selliselt, et faktorite vahel võib olla ka korrelatsioon. Võrreldes varimax pööramisega on tulemuseks küll mitte nii selgelt eristuvad faktorid, aga faktorite siseselt eristuvad selgemalt tunnused.\nQuartimax pööramise eesmärk on maksimeerida faktori kordajate ruutude hajuvust erinevalt eelnevatest hoopis tunnuste siseselt. Selle tulemusel on iga tunnus seotud võimalikult väheste faktoritega.\n\nSoovitud pööramise saame faktorite arvutamisel täpsustada argumendiga rotate. Näiteks tavapäraselt kasutatavat Varimax pööramist 7 faktori leidmiseks saame rakendada alljärgnevalt.\n\nfaktorid &lt;- fa(surm, nfactors = 7, rotate = 'varimax')\n\nWarning in fa.stats(r = r, f = f, phi = phi, n.obs = n.obs, np.obs = np.obs, :\nThe estimated weights for the factor scores are probably incorrect.  Try a\ndifferent factor score estimation method.\n\n\nWarning in fac(r = r, nfactors = nfactors, n.obs = n.obs, rotate = rotate, : An\nultra-Heywood case was detected.  Examine the results carefully"
  },
  {
    "objectID": "faktoranalüüs.html#eeldused",
    "href": "faktoranalüüs.html#eeldused",
    "title": "29  Faktoranalüüs",
    "section": "29.4 Eeldused",
    "text": "29.4 Eeldused\nÜldiselt kehtivad faktoranalüüsil samad eeldused, mis peakomponentide analüüsi puhul. Veelgi olulisem on aga veenduda selles, et tunnuste vaheline jagatud hajuvus on piisav selleks, et\n\nandmepilv ei ole sfääriline (sphericity) ja\nandmetabel sobib faktoranalüüsiks (sampling adequacy).\n\nNende kahe eelduse testimiseks saab kasutada vastavalt funktsioone cortest.bartlett() ja KMO() laiendusest psych.\nVeendumaks, et andmepilv ei ole sfääriline, saame testida, kas andmetes esinevad korrelatsioonid on üldistatavad. Selleks saame kasutada Bartletti testi korrelatsioonimaatriksi hindamiseks.\n\nkorrel &lt;- cor(surm, use = 'pairwise.complete.obs')\ncortest.bartlett(korrel, n = nrow(surm))\n\n$chisq\n[1] 6618.6\n\n$p.value\n[1] 0\n\n$df\n[1] 465\n\n\nKuna saadud p-väärtus on madalam kui \\(\\alpha = 0.05\\), siis võime järeldada, et andmetes esinevad korrelatsioonid on piisavalt suured.\nAndmetabeli sobivus faktoranalüüsiks seisneb sellest, et kasutatavad tunnused on üldse seletatavad faktorite poolt ja ei ole seotud ainult enda faktoriga ega unikaalsed. Seda saame hinnata KMO mõõdiku abil (Kaiser-Meyer-Olkin measure). Mõõdiku väärtus on vahemikus \\(0...1\\), kus kõrgem väärtus näitab, et suurem osa hajuvusest on tingitud faktoritest.\n\nKMO(surm)\n\nKaiser-Meyer-Olkin factor adequacy\nCall: KMO(r = surm)\nOverall MSA =  0.24\nMSA for each item = \n             Covid.19.Deaths      Cardiovascular.diseases \n                        0.08                         0.19 \n        Respiratory.diseases              Kidney.diseases \n                        0.05                         0.08 \n          Neonatal.disorders                   Meningitis \n                        0.32                         0.62 \n                     Malaria       Interpersonal.violence \n                        0.24                         0.05 \n                    HIV.AIDS                 Tuberculosis \n                        0.13                         0.29 \n          Maternal.disorders Lower.respiratory.infections \n                        0.55                         0.21 \n       Alcohol.use.disorders           Diarrheal.diseases \n                        0.20                         0.30 \n                   Poisoning     Nutritional.deficiencies \n                        0.74                         0.70 \n         Alzheimer.s.disease          Parkinson.s.disease \n                        0.26                         0.71 \n             Acute.hepatitis           Digestive.diseases \n                        0.83                         0.09 \n              Liver.diseases  Protein.energy.malnutrition \n                        0.12                         0.81 \n                   Neoplasms                   Fire..heat \n                        0.27                         0.68 \n                    Drowning           Drug.use.disorders \n                        0.22                         0.12 \n               Road.injuries                Heat.and.cold \n                        0.05                         0.71 \n                   Self.harm       Conflict.and.terrorism \n                        0.05                         0.02 \n                    Diabetes \n                        0.05 \n\n\nNäeme, et esineb palju surmapõhjuseid, mille korral KMO mõõdiku väärtus on \\(&lt;0.6\\). Seega need tunnused ei ole faktoritega seletatavad ega sobi seega faktoranalüüsi jaoks."
  },
  {
    "objectID": "faktoranalüüs.html#tõlgendamine",
    "href": "faktoranalüüs.html#tõlgendamine",
    "title": "29  Faktoranalüüs",
    "section": "29.5 Tõlgendamine",
    "text": "29.5 Tõlgendamine\nLähtudes faktormudelist näitavad faktorite kordajad iga faktori mõju tunnusele. Nii on need kordajad tähenduselt mingil määral sarnased regressioonmudeli kordajatele, kus kordaja märk näitab seose suunda ja absoluutväärtus seose tugevust. Sageli võetakse arvesse ainult neid kordajaid mille väärtus on kõrgem kui nt 0,3 või 0,5 selleks, et iga faktor oleks selgemini seotud konkreetsete tunnustega või vastupidi.\nKordajad saame kätte faktori objekti osisest loadings. Sealjuures tuleks faktorite järjestamisel lähtuda seletatud hajuvusest, mitte veeru päises olevast numbrist.\n\nfaktorid &lt;- fa(surm, nfactors = 7, rotate = 'oblimin')\n\nLoading required namespace: GPArotation\n\n\nWarning in fac(r = r, nfactors = nfactors, n.obs = n.obs, rotate = rotate, : I\nam sorry, to do these rotations requires the GPArotation package to be\ninstalled\n\n\nWarning in fa.stats(r = r, f = f, phi = phi, n.obs = n.obs, np.obs = np.obs, :\nThe estimated weights for the factor scores are probably incorrect.  Try a\ndifferent factor score estimation method.\n\n\nWarning in fac(r = r, nfactors = nfactors, n.obs = n.obs, rotate = rotate, : An\nultra-Heywood case was detected.  Examine the results carefully\n\nfaktorid$loadings\n\n\nLoadings:\n                             MR1    MR2    MR3    MR4    MR5    MR6    MR7   \nCovid.19.Deaths              -0.386                             -0.283  0.325\nCardiovascular.diseases      -0.632  0.283  0.282 -0.434 -0.233 -0.275 -0.272\nRespiratory.diseases         -0.241        -0.106        -0.211  0.458 -0.162\nKidney.diseases              -0.229  0.277 -0.645  0.228  0.177              \nNeonatal.disorders            0.922 -0.110                                   \nMeningitis                    0.889 -0.258                                   \nMalaria                       0.732 -0.255                                   \nInterpersonal.violence        0.144  0.302 -0.305  0.235  0.337 -0.166       \nHIV.AIDS                      0.499                       0.192              \nTuberculosis                  0.839                                          \nMaternal.disorders            0.891 -0.138                                   \nLower.respiratory.infections  0.681 -0.227 -0.101  0.194         0.180       \nAlcohol.use.disorders        -0.251  0.376  0.381  0.194  0.460              \nDiarrheal.diseases            0.855 -0.212                                   \nPoisoning                     0.762  0.165  0.319 -0.177                     \nNutritional.deficiencies      0.748 -0.165         0.194  0.197              \nAlzheimer.s.disease          -0.719 -0.445  0.147  0.231                0.100\nParkinson.s.disease          -0.799 -0.426         0.195         0.201       \nAcute.hepatitis               0.621               -0.128 -0.324  0.156       \nDigestive.diseases                   0.525  0.187  0.765 -0.296              \nLiver.diseases                0.200  0.676  0.147  0.460 -0.353              \nProtein.energy.malnutrition   0.742 -0.173         0.191  0.208              \nNeoplasms                    -0.808 -0.361  0.164  0.162  0.109  0.213       \nFire..heat                    0.496  0.314        -0.396  0.176  0.106  0.118\nDrowning                      0.230  0.506 -0.263 -0.145         0.291 -0.248\nDrug.use.disorders           -0.257         0.150 -0.187         0.285  0.317\nRoad.injuries                 0.200  0.346 -0.263 -0.352         0.170  0.532\nHeat.and.cold                        0.383  0.782         0.278              \nSelf.harm                    -0.170  0.248  0.211         0.286  0.429       \nConflict.and.terrorism        0.121               -0.233 -0.165              \nDiabetes                     -0.125  0.256 -0.639         0.180        -0.250\n\n                  MR1   MR2   MR3   MR4   MR5   MR6   MR7\nSS loadings    10.257 2.740 2.225 1.841 1.191 0.972 0.797\nProportion Var  0.331 0.088 0.072 0.059 0.038 0.031 0.026\nCumulative Var  0.331 0.419 0.491 0.550 0.589 0.620 0.646\n\n\nKordajate alusel saame muuhulgas anda faktoritele tähenduse.\n\nEsimene faktor võiks iseloomustada arsiabi kättesaamatust, kuna suurendab eelkõige nakkushaiguste ja lihtsamini ravitavate surmapõhjuste esinemist, vähendades samal ajal vanadusega seotud haigustesse suremist.\nTeine faktor suurendab muuhulgas õnnetustega seotud surmapõhjusi ja vähendab vanadusega seotud surmapõhjuste esinemist, nii et see võiks iseloomustada elukeskkonna ohtlikkust. Samas ei ole see iseloomustus päris täpne, sest kõige suurem on selle faktori mõju hoopis suremusel maksahaiguste tõttu.\nKolmas faktor suurendab kuumast ja külmast keskkonnast tingitud surmasid ja (alkoholi) mürgitust, aga vähendab suremist maksahaiguste ja diabeedi tõttu.\n\nÜks viis faktorite kordajaid joonistada on kasutada seosekaarti.\n\nlibrary('gplots')\nheatmap.2(faktorid$loadings, col = 'bluered', margins = c(4,12))\n\n\n\n\nTeine võimalus on kuvada tunnused ja faktorid ning nende vahelised seosed joontena, millel on kordajad.\n\nfa.diagram(faktorid)\n\n\n\n\nSarnaselt peakomponentide analüüsile saame ka faktoranalüüsis leida igale vaatlusele nende paiknemise faktori skaalal ehk faktorskoorid (factor scores).\n\nhead(faktorid$scores)\n\n                           MR1        MR2        MR3        MR4        MR5\nAfghanistan          1.2837410 -0.1114036 -0.8188728 -1.7174264 -1.3218726\nAlbania             -0.9621016 -1.0332814  0.5246546 -1.5734375 -0.8608276\nAlgeria             -0.3205165  0.3941513  0.2469887 -1.8875429 -1.4263518\nAndorra             -0.3191040 -1.6884350 -1.9617702  1.0227512  1.6965491\nAngola               1.7674327 -0.1049126  0.1219444  0.3027988 -0.1638401\nAntigua and Barbuda -0.2872706  0.1574415 -1.9210794  0.5530720  2.1891926\n                           MR6        MR7\nAfghanistan          0.7131453  0.7246590\nAlbania             -1.1414748 -0.9942366\nAlgeria             -0.6594341 -0.1066433\nAndorra              0.8659360  3.5498961\nAngola               0.1329637  0.7311467\nAntigua and Barbuda  0.1021627  0.5483677\n\n\nVõttes aluseks eelneva faktorite iseloomustuse, võime öelda nt, et Afganistaanis ja Angolas on keskmisest kõrgem arstiabi kättesaamatus ehk halvem arstiabi kättesaadavus.\nIga tunnuse kohta saame arvutada unikaalsuse (uniqueness), mis näitab faktorite poolt seletamata jäänud osa tunnuse hajuvusest. Kommunaliteet (communality) on selle pöördväärtus ja näitab seega, kui suur osa tunnuse hajuvusest on seletatav faktoritega.\n\nsort(faktorid$uniqueness)\n\n          Digestive.diseases      Cardiovascular.diseases \n                -0.001210907                  0.048529385 \n         Parkinson.s.disease                    Neoplasms \n                 0.099186554                  0.105436732 \n                  Meningitis           Neonatal.disorders \n                 0.127442251                  0.132623516 \n              Liver.diseases                Heat.and.cold \n                 0.140368041                  0.152130049 \n          Maternal.disorders          Alzheimer.s.disease \n                 0.180847557                  0.190689824 \n          Diarrheal.diseases                    Poisoning \n                 0.205641250                  0.248135643 \n                Tuberculosis                Road.injuries \n                 0.260812244                  0.328503356 \n    Nutritional.deficiencies  Protein.energy.malnutrition \n                 0.330606990                  0.331549171 \n             Kidney.diseases                      Malaria \n                 0.368355321                  0.386910786 \n       Alcohol.use.disorders Lower.respiratory.infections \n                 0.399582764                  0.400298334 \n                    Diabetes                   Fire..heat \n                 0.412819988                  0.440951462 \n                    Drowning              Acute.hepatitis \n                 0.446291963                  0.468876556 \n      Interpersonal.violence                    Self.harm \n                 0.591559198                  0.596473265 \n        Respiratory.diseases              Covid.19.Deaths \n                 0.641325972                  0.644943281 \n          Drug.use.disorders                     HIV.AIDS \n                 0.691896473                  0.708052925 \n      Conflict.and.terrorism \n                 0.897567476 \n\n\nNäeme, et kõige vähem seletavad faktorid surmasid terrorismi ja sarnaste konfliktide tõttu (Conflict.and.terrorism). Kõige paremini seletavad faktorid aga seedimisega seotud surmapõhjuste esinemist (Digestive.diseases).\nTunnuse keerukuse (complexity) saab leida samuti iga tunnuse kohta ja see näitab faktorite arvu, mis antud tunnust mõjutavad.\n\nsort(faktorid$complexity)\n\n          Neonatal.disorders           Maternal.disorders \n                    1.039504                     1.066057 \n                Tuberculosis           Diarrheal.diseases \n                    1.100237                     1.173406 \n                  Meningitis                      Malaria \n                    1.210875                     1.289432 \n                    HIV.AIDS     Nutritional.deficiencies \n                    1.346614                     1.416843 \n Protein.energy.malnutrition                    Poisoning \n                    1.455460                     1.620001 \nLower.respiratory.infections              Acute.hepatitis \n                    1.634290                     1.760045 \n               Heat.and.cold                    Neoplasms \n                    1.790406                     1.791195 \n         Parkinson.s.disease                     Diabetes \n                    1.832446                     1.952125 \n         Alzheimer.s.disease              Kidney.diseases \n                    2.116485                     2.149664 \n          Digestive.diseases         Respiratory.diseases \n                    2.340790                     2.569134 \n      Conflict.and.terrorism               Liver.diseases \n                    2.679955                     2.721305 \n             Covid.19.Deaths                   Fire..heat \n                    3.159435                     3.245938 \n                   Self.harm                     Drowning \n                    3.447885                     3.617551 \n               Road.injuries        Alcohol.use.disorders \n                    3.860604                     3.943862 \n     Cardiovascular.diseases           Drug.use.disorders \n                    4.073304                     4.165440 \n      Interpersonal.violence \n                    4.903432 \n\n\nNäeme, et kui vastsündinu surmade (Neonatal.disorders) seletamiseks piisab ühest faktorist, siis isikutevaheline vägivald (Interpersonal.violence) on seotud peaaegu viie faktoriga.\nKahte faktorit ja vaatluste paiknemist nende suhtes saame korraga kujutada hajuvusjoonisel.\n\nbiplot(faktorid$scores[, 1:2],  loadings(faktorid), cex = .5)"
  },
  {
    "objectID": "tekstikaeve.html#korpus",
    "href": "tekstikaeve.html#korpus",
    "title": "30  Tekstikaeve",
    "section": "30.1 Korpus",
    "text": "30.1 Korpus\nUuritavat dokumenti või ka mitme sellise dokumendi kogumit nimetatakse korpuseks (corpus). Laienduse quanteda funktsioonide kasutamiseks tuleks dokumente sisaldava vektor eelnevalt korpusena vormistatud objektiks teisendada funktsiooniga corpus().\n\nkorpus &lt;- corpus(dokumendid)\nkorpus\n\nCorpus consisting of 12 documents.\nandmed/cmp/irl_2007.pdf :\n\"Terve pere – Terve mõistus – Terve Eesti Isamaa ja Res Publi...\"\n\nandmed/cmp/irl_2011.pdf :\n\"Esileht » IRL-i programm 2011-2015 IRL-i programm 2011-2015 ...\"\n\nandmed/cmp/keskerakond_2007.pdf :\n\"                                                            ...\"\n\nandmed/cmp/keskerakond_2011.pdf :\n\"           Vastu võetud Eesti Keskerakonna volikogu istungil...\"\n\nandmed/cmp/rahvaliit_2007.pdf :\n\"ERL     valimisplatvorm                             2007.aas...\"\n\nandmed/cmp/rahvaliit_2011.pdf :\n\"EESTIMAIST LEIBA JA TÖÖD! EESTIMAA RAHVALIIDU PLATVORM 2011....\"\n\n[ reached max_ndoc ... 6 more documents ]\n\n\nKorpuses olevatele dokumentidele võime määrata hilisemaks analüüsimiseks dokumentide nimed, aga ka muud tunnused. Antud juhul võikisme määrata igale dokumendile erakonna nimetuse ja aastaarvu.\n\n# Täpsustame dokumentide nimetused\nerakonnad &lt;- c('irl', 'kesk', 'rahvaliit', 'reform', 'rohe', 'sde')\nnames(korpus) &lt;- paste(rep(erakonnad, each = 2), c(2007, 2011))\nnames(korpus)\n\n [1] \"irl 2007\"       \"irl 2011\"       \"kesk 2007\"      \"kesk 2011\"     \n [5] \"rahvaliit 2007\" \"rahvaliit 2011\" \"reform 2007\"    \"reform 2011\"   \n [9] \"rohe 2007\"      \"rohe 2011\"      \"sde 2007\"       \"sde 2011\"      \n\n# Määrame dokumentidele erakonna tunnuse\nkorpus$erakond &lt;- rep(erakonnad, each = 2)\nkorpus$erakond\n\n [1] \"irl\"       \"irl\"       \"kesk\"      \"kesk\"      \"rahvaliit\" \"rahvaliit\"\n [7] \"reform\"    \"reform\"    \"rohe\"      \"rohe\"      \"sde\"       \"sde\"      \n\n# Määrame dokumentidele aasta tunnuse\nkorpus$aasta &lt;- c(2007, 2011)\nkorpus$aasta\n\n [1] 2007 2011 2007 2011 2007 2011 2007 2011 2007 2011 2007 2011"
  },
  {
    "objectID": "tekstikaeve.html#sõnestamine",
    "href": "tekstikaeve.html#sõnestamine",
    "title": "30  Tekstikaeve",
    "section": "30.2 Sõnestamine",
    "text": "30.2 Sõnestamine\nPaljude teksti kvantitaiivse analüüsimise protseduurid põhinevad sõnade sagedustel. Tihti on aga sõna liiga kitsas mõiste uuritava üksuse kirjeldamiseks, mistõttu on tekstikaeves analüüsi ühikuks tegelikult sõne (token). Sõne võib sisaldda ka rohkem kui ühte üksteisele piisavalt sagedasti järgnevat sõna. Sõnede uurimiseks tuleb esmalt korpuses esinevad dokumendid teisendada sõnede loeteludeks. Seda tegevust võib nimetada sõnestamiseks (tokenization). Sõnestada saame funktsiooniga tokens(), mille rakendamisel võime dokumentidest ühtlasi eemaldada ka kirjavahemärgid, sümbolid, arvud ja tühikud.\n\nsõned &lt;- tokens(korpus, \n                remove_punct = TRUE, \n                remove_symbols = TRUE, \n                remove_numbers = TRUE)\n\nKuna suupärasem on rääkida sõnede asemel siiski sõnadest, siis edaspidi peame mõiste “sõna” all silmas tegelikult sõnesid.\nEt mitte eristada sõnu suur- ja väiketähtede alusel, võiksime muuta kõik suurtähend väiketähtedeks.\n\nsõned %&lt;&gt;% tokens_tolower\nsõned\n\nTokens consisting of 12 documents and 2 docvars.\nirl 2007 :\n [1] \"terve\"              \"pere\"               \"terve\"             \n [4] \"mõistus\"            \"terve\"              \"eesti\"             \n [7] \"isamaa\"             \"ja\"                 \"res\"               \n[10] \"publica\"            \"liidu\"              \"valitsemisprogramm\"\n[ ... and 6,585 more ]\n\nirl 2011 :\n [1] \"esileht\"            \"irl-i\"              \"programm\"          \n [4] \"2011-2015\"          \"irl-i\"              \"programm\"          \n [7] \"2011-2015\"          \"irl-i\"              \"sammu\"             \n[10] \"eestile\"            \"valitsemisprogramm\" \"2011-2015\"         \n[ ... and 4,966 more ]\n\nkesk 2007 :\n [1] \"vastu\"           \"võetud\"          \"eesti\"           \"keskerakonna\"   \n [5] \"volikogu\"        \"istungil\"        \"jaanuaril\"       \"a\"              \n [9] \"tallimas\"        \"eesti\"           \"keskerakonna\"    \"valimisplatvorm\"\n[ ... and 4,369 more ]\n\nkesk 2011 :\n [1] \"vastu\"           \"võetud\"          \"eesti\"           \"keskerakonna\"   \n [5] \"volikogu\"        \"istungil\"        \"jaanuar\"         \"eesti\"          \n [9] \"inimkeskseks\"    \"eesti\"           \"keskerakonna\"    \"valimisplatvorm\"\n[ ... and 4,816 more ]\n\nrahvaliit 2007 :\n [1] \"erl\"             \"valimisplatvorm\" \"aasta\"           \"riigikogu\"      \n [5] \"valimistel\"      \"võrdsete\"        \"võimaluste\"      \"eesti\"          \n [9] \"rahvaliidu\"      \"platvorm\"        \"aasta\"           \"riigikogu\"      \n[ ... and 1,695 more ]\n\nrahvaliit 2011 :\n [1] \"eestimaist\"    \"leiba\"         \"ja\"            \"tööd\"         \n [5] \"eestimaa\"      \"rahvaliidu\"    \"platvorm\"      \"aasta\"        \n [9] \"riigikogu\"     \"valimisteks\"   \"presidendi\"    \"otsevalimised\"\n[ ... and 2,952 more ]\n\n[ reached max_ndoc ... 6 more documents ]\n\n\nLisaks eelnevale võime eemaldada ka sõnad, milles on alla 2 tähemärgi.\n\nsõned %&lt;&gt;% tokens_select(min_nchar = 2)\nsõned\n\nTokens consisting of 12 documents and 2 docvars.\nirl 2007 :\n [1] \"terve\"              \"pere\"               \"terve\"             \n [4] \"mõistus\"            \"terve\"              \"eesti\"             \n [7] \"isamaa\"             \"ja\"                 \"res\"               \n[10] \"publica\"            \"liidu\"              \"valitsemisprogramm\"\n[ ... and 6,581 more ]\n\nirl 2011 :\n [1] \"esileht\"            \"irl-i\"              \"programm\"          \n [4] \"2011-2015\"          \"irl-i\"              \"programm\"          \n [7] \"2011-2015\"          \"irl-i\"              \"sammu\"             \n[10] \"eestile\"            \"valitsemisprogramm\" \"2011-2015\"         \n[ ... and 4,966 more ]\n\nkesk 2007 :\n [1] \"vastu\"           \"võetud\"          \"eesti\"           \"keskerakonna\"   \n [5] \"volikogu\"        \"istungil\"        \"jaanuaril\"       \"tallimas\"       \n [9] \"eesti\"           \"keskerakonna\"    \"valimisplatvorm\" \"riigikogu\"      \n[ ... and 4,319 more ]\n\nkesk 2011 :\n [1] \"vastu\"           \"võetud\"          \"eesti\"           \"keskerakonna\"   \n [5] \"volikogu\"        \"istungil\"        \"jaanuar\"         \"eesti\"          \n [9] \"inimkeskseks\"    \"eesti\"           \"keskerakonna\"    \"valimisplatvorm\"\n[ ... and 4,799 more ]\n\nrahvaliit 2007 :\n [1] \"erl\"             \"valimisplatvorm\" \"aasta\"           \"riigikogu\"      \n [5] \"valimistel\"      \"võrdsete\"        \"võimaluste\"      \"eesti\"          \n [9] \"rahvaliidu\"      \"platvorm\"        \"aasta\"           \"riigikogu\"      \n[ ... and 1,676 more ]\n\nrahvaliit 2011 :\n [1] \"eestimaist\"    \"leiba\"         \"ja\"            \"tööd\"         \n [5] \"eestimaa\"      \"rahvaliidu\"    \"platvorm\"      \"aasta\"        \n [9] \"riigikogu\"     \"valimisteks\"   \"presidendi\"    \"otsevalimised\"\n[ ... and 2,949 more ]\n\n[ reached max_ndoc ... 6 more documents ]\n\n\nPaljud tekstis sageli esinevad sõnad ei ole sisulised ega võimalda dokumenti temaatiliselt iseloomustada ega teistest tekstidest eristada. Sellised sõnad on nt sidesõnad ja asesõnad. Dokumentide analüüsimisel on need sõnad müra, mis raskendavad mustrite ja seoste leidmist. Tekstikaeves nimetatakse taolisi sõnu stoppsõnadeks (stopwords). Stoppsõnad saame sõnedest eemaldada funktsiooniga tokens_remove(). Inglisekeelsete stoppsõnad saame eemaldada argumendiga pattern = stopwords('en'). Eesti keele stoppsõnu aga vastavas funktsioonis ei ole, mistõttu peame need käsitsi arvutisse laadima1, R töölauale sisestama ja seejärel vastava funktsiooni argumendina määrama.1 Eesti keele stoppsõnad on alla laetavad Tartu Ülikooli raamatukogust.\n\nstoppsõnad &lt;- readLines('andmed/stoppsõnad.txt')\nsõned %&lt;&gt;% tokens_remove(stoppsõnad)\nsõned\n\nTokens consisting of 12 documents and 2 docvars.\nirl 2007 :\n [1] \"terve\"              \"pere\"               \"terve\"             \n [4] \"mõistus\"            \"terve\"              \"eesti\"             \n [7] \"isamaa\"             \"res\"                \"publica\"           \n[10] \"liidu\"              \"valitsemisprogramm\" \"2007–2011\"         \n[ ... and 4,937 more ]\n\nirl 2011 :\n [1] \"esileht\"            \"irl-i\"              \"programm\"          \n [4] \"2011-2015\"          \"irl-i\"              \"programm\"          \n [7] \"2011-2015\"          \"irl-i\"              \"sammu\"             \n[10] \"eestile\"            \"valitsemisprogramm\" \"2011-2015\"         \n[ ... and 3,654 more ]\n\nkesk 2007 :\n [1] \"võetud\"          \"eesti\"           \"keskerakonna\"    \"volikogu\"       \n [5] \"istungil\"        \"jaanuaril\"       \"tallimas\"        \"eesti\"          \n [9] \"keskerakonna\"    \"valimisplatvorm\" \"riigikogu\"       \"xi\"             \n[ ... and 3,477 more ]\n\nkesk 2011 :\n [1] \"võetud\"          \"eesti\"           \"keskerakonna\"    \"volikogu\"       \n [5] \"istungil\"        \"jaanuar\"         \"eesti\"           \"inimkeskseks\"   \n [9] \"eesti\"           \"keskerakonna\"    \"valimisplatvorm\" \"riigikogu\"      \n[ ... and 3,668 more ]\n\nrahvaliit 2007 :\n [1] \"erl\"             \"valimisplatvorm\" \"aasta\"           \"riigikogu\"      \n [5] \"valimistel\"      \"võrdsete\"        \"võimaluste\"      \"eesti\"          \n [9] \"rahvaliidu\"      \"platvorm\"        \"aasta\"           \"riigikogu\"      \n[ ... and 1,346 more ]\n\nrahvaliit 2011 :\n [1] \"eestimaist\"    \"leiba\"         \"tööd\"          \"eestimaa\"     \n [5] \"rahvaliidu\"    \"platvorm\"      \"aasta\"         \"riigikogu\"    \n [9] \"valimisteks\"   \"presidendi\"    \"otsevalimised\" \"riigikogu\"    \n[ ... and 2,264 more ]\n\n[ reached max_ndoc ... 6 more documents ]\n\n\nÜks ja sama sõna võib esineda mitmel erineval kujul, nt ainsuses ja mitmuses, eessõnadega ja eessõnadeta. Tegusõnadel on paljudes keeltes pöörded. Eesti keeles esinevad nimisõnad veel ka erinevates käänetes. Enne sõnede analüüsimist need seetõttu algvormistatakse (lemmatizing) ehk sõnad asendatakse nende algvormidega (lemmadega). Ingliskeelsete sõnede puhul saame kasutada funktsiooni tokens_wordstem(). Eestikeelsete sõnade algvormid koos kõikvõimalike vormidega ei ole paraku avalikult leitavad, mistõttu uuritavat korpust me algvormistada ei saa2.2 Vajadusel saab dokumendid enne R töölauale sisestamist lemmatiseerida Tartu Ülikooli poolt pakutava lemmatiseerijaga.\nVõiksime arvesse võtta ka asjaolu, et teatud nähtused esitatakse rohkem kui ühe sõnana. Rohkem kui ühest sõnast koosnevad väljendid on sõnaühendid (collocations, n-grams). Dokumentides esinevate sõnade järjestuse alusel saame sõnaühendid leida funktsiooniga textstat_collocations(), milles saame määrata mh leitavate sõnaühendite väikseima sageduse (min_count = 20) ja vähina sõnade arvu, mille ühendeid otsime (size = 2).\n\nsõnaühendid &lt;- textstat_collocations(sõned, min_count = 20, size = 2)\nsõnaühendid\n\n              collocation count count_nested length   lambda         z\n1           euroopa liidu   122            0      2 8.172183 27.295814\n2  kohalike omavalitsuste    44            0      2 7.700018 26.528901\n3   kohaliku omavalitsuse    44            0      2 8.257329 24.637951\n4         aasta riigikogu    25            0      2 6.771280 22.077919\n5        seame eesmärgiks    25            0      2 7.152740 21.286942\n6             eesti keele    84            0      2 5.580524 20.071027\n7          keele kultuuri    21            0      2 5.513795 19.952996\n8    riigikogu valimistel    20            0      2 7.893078 19.759353\n9       puuetega inimeste    22            0      2 5.970381 19.397187\n10        avaliku sektori    22            0      2 7.643146 19.225379\n11            eesti rahva    23            0      2 2.803082 11.567095\n12            eesti riigi    26            0      2 1.411430  6.885797\n13         euroopa liidus    25            0      2 9.358914  6.546880\n14          toetame eesti    20            0      2 1.011082  4.407667\n\n\nFunktsioon tokens_compound() asendab korpuses eraldi sõnandena esinevad sõnad neile vastavate sõnaühenditega.\n\nsõned &lt;- tokens_compound(sõned, sõnaühendid)"
  },
  {
    "objectID": "tekstikaeve.html#maatriksid",
    "href": "tekstikaeve.html#maatriksid",
    "title": "30  Tekstikaeve",
    "section": "30.3 Maatriksid",
    "text": "30.3 Maatriksid\nSõnestatud korpuse alusel saame küll lihtsasti leida nt sõnade sagedused, aga huvitavamad mustrid ilmnevad sõnade ja dokumentide vaheliste seoste uurimisel. Selleks on vajalik korpus teisendada sageduste maatriksiks. Sellistes maatriksites nimetatkse sõnau sageli hoopis terminiteks (term). Nii võib eristada teistest ka harva esinevaid termineid (sparse terms), mis moodustavad tavaliselt suurema osa kõikidest terminitest.\nDokumendi-termini maatriksis (document-feature matrix) on ridades dokumendid ja veergudes kõik korpuses esinevad terminid. Lahtrites on seega vähemalt vaikimisi iga termini esinemissagedus igas dokumendis.\n\ndokMat &lt;- dfm(sõned)\ndokMat\n\nDocument-feature matrix of: 12 documents, 18,510 features (84.92% sparse) and 2 docvars.\n                features\ndocs             terve pere mõistus eesti isamaa res publica liidu\n  irl 2007          16    7       3   110      2   2       2     3\n  irl 2011           1    2       0    74      7   7       7     4\n  kesk 2007          1    3       0    48      0   0       0     0\n  kesk 2011          1    2       0    79      1   1       1     3\n  rahvaliit 2007     0    0       0    36      0   0       0     0\n  rahvaliit 2011     0    2       0    29      0   0       0     0\n                features\ndocs             valitsemisprogramm 2007–2011\n  irl 2007                        1         1\n  irl 2011                        1         0\n  kesk 2007                       0         0\n  kesk 2011                       0         0\n  rahvaliit 2007                  0         0\n  rahvaliit 2011                  0         0\n[ reached max_ndoc ... 6 more documents, reached max_nfeat ... 18,500 more features ]\n\n\nTerminite maatriksis (feature co-occurrence matrix) on ridades ja ka veergudes terminid. Lahtrites on nende terminite koos esinemised. Dokumentide uurimisel saame otsida sõnade koos esinemisi kas\n\nsõnade vahel lähtudes nende lähedusest või\nmitme dokumendi vahel sõnade koos esinemise alusel.\n\nSealjuures on esimene lähenemine sobilikum üksikute pikkade dokumentide korral, viimane eeldab aga palju dokumente.\nKasutades argumente context = 'document', window = 5, loendame kui mitu korda esineb iga sõnade paar teineteisest kuni viie sõna kaugusel.\n\ntermMat &lt;- fcm(sõned, context = 'window', window = 5)\ntermMat\n\nFeature co-occurrence matrix of: 18,510 by 18,510 features.\n                    features\nfeatures             terve pere mõistus eesti isamaa res publica liidu\n  terve                  8    7       5    25      2   2       1     1\n  pere                   0    0       1     6      1   0       0     0\n  mõistus                0    0       0     1      1   1       1     0\n  eesti                  0    0       0   222      4   4       4     5\n  isamaa                 0    0       0     0      0  10      10     7\n  res                    0    0       0     0      0   0      10     7\n  publica                0    0       0     0      0   0       0     7\n  liidu                  0    0       0     0      0   0       0     4\n  valitsemisprogramm     0    0       0     0      0   0       0     0\n  2007–2011              0    0       0     0      0   0       0     0\n                    features\nfeatures             valitsemisprogramm 2007–2011\n  terve                               0         0\n  pere                                0         0\n  mõistus                             0         0\n  eesti                               2         1\n  isamaa                              2         1\n  res                                 2         1\n  publica                             2         1\n  liidu                               2         1\n  valitsemisprogramm                  0         1\n  2007–2011                           0         0\n[ reached max_feat ... 18,500 more features, reached max_nfeat ... 18,500 more features ]\n\n\nArgumendi context = 'document' korral näitavad saadud sagedused, kui mitmes dokumendis esineb vastav sõnade paar korraga.\n\ntermMat &lt;- fcm(sõned, context = 'document')\ntermMat\n\nFeature co-occurrence matrix of: 18,510 by 18,510 features.\n                    features\nfeatures             terve pere mõistus eesti isamaa res publica liidu\n  terve                129  137      48  3182     40  40      40    55\n  pere                   0   36      21  2894     30  30      30    41\n  mõistus                0    0       3   330      6   6       6     9\n  eesti                  0    0       0 61047    817 817     817  1144\n  isamaa                 0    0       0     0     22  54      54    37\n  res                    0    0       0     0      0  22      54    37\n  publica                0    0       0     0      0   0      22    37\n  liidu                  0    0       0     0      0   0       0    13\n  valitsemisprogramm     0    0       0     0      0   0       0     0\n  2007–2011              0    0       0     0      0   0       0     0\n                    features\nfeatures             valitsemisprogramm 2007–2011\n  terve                              17        22\n  pere                                9        11\n  mõistus                             3         3\n  eesti                             184       328\n  isamaa                              9         2\n  res                                 9         2\n  publica                             9         2\n  liidu                               7         3\n  valitsemisprogramm                  0         1\n  2007–2011                           0         1\n[ reached max_feat ... 18,500 more features, reached max_nfeat ... 18,500 more features ]"
  },
  {
    "objectID": "tekstikaeve.html#sõnade-sagedused",
    "href": "tekstikaeve.html#sõnade-sagedused",
    "title": "30  Tekstikaeve",
    "section": "30.4 Sõnade sagedused",
    "text": "30.4 Sõnade sagedused\nKõige lihtsam viis dokumentide kirjeldamiseks on lugeda kokku sõnad. Alustuseks võime võrrelda dokumente kõikide sõnade, kordumatute sõnade (type) ja ka lausete arvu alusel.\n\nntoken(korpus) # Sõnade arv kokku\n\n      irl 2007       irl 2011      kesk 2007      kesk 2011 rahvaliit 2007 \n          8080           6012           5746           6488           1982 \nrahvaliit 2011    reform 2007    reform 2011      rohe 2007      rohe 2011 \n          3477           8784          15171           3038           5993 \n      sde 2007       sde 2011 \n         13312           9908 \n\nntype(korpus) # Kordumatute sõnade arv\n\n      irl 2007       irl 2011      kesk 2007      kesk 2011 rahvaliit 2007 \n          3721           2916           2661           2827           1151 \nrahvaliit 2011    reform 2007    reform 2011      rohe 2007      rohe 2011 \n          1880           3758           6038           1671           2900 \n      sde 2007       sde 2011 \n          4544           4426 \n\nnsentence(korpus) # Lausete arv\n\n      irl 2007       irl 2011      kesk 2007      kesk 2011 rahvaliit 2007 \n           786            546            477            659            102 \nrahvaliit 2011    reform 2007    reform 2011      rohe 2007      rohe 2011 \n           205            326           1100             98            447 \n      sde 2007       sde 2011 \n           684            347 \n\n\nÜlevaate tekstide sisust annavad sõnade sagedused (bag-of-words, word frequencies), mis näitavad lihtsalt kui mitu korda sõna esineb. Kõige sagedamini esinevad sõnad annavad lihtsa ülevaate korpuse sisust.\n\nsage &lt;- textstat_frequency(dokMat, n = 10)\nsage\n\n          feature frequency rank docfreq group\n1           eesti      1000    1      12   all\n2         toetame       340    2      12   all\n3           riigi       296    3      12   all\n4          tagame       170    4      11   all\n5            riik       158    5      11   all\n6           loome       139    6      12   all\n7             aeg       129    7       6   all\n8        inimeste       129    7      12   all\n9  reformierakond       126    9       2   all\n10  euroopa_liidu       122   10      12   all\n\n\nNeid sagedusi saame samuti uurida mingi korpuses esineva igat dokumenti esindava tunnuse lõikes.\n\nsageDok &lt;- textstat_frequency(dokMat, groups = korpus$erakond, n = 3)\nsageDok\n\n          feature frequency rank docfreq     group\n1           eesti       184    1       2       irl\n2         toetame        83    2       2       irl\n3           riigi        49    3       2       irl\n4           eesti       127    1       2      kesk\n5         toetame        48    2       2      kesk\n6           riigi        47    3       2      kesk\n7       rahvaliit       104    1       2 rahvaliit\n8           eesti        65    2       2 rahvaliit\n9            riik        22    3       2 rahvaliit\n10          eesti       356    1       2    reform\n11 reformierakond       126    2       2    reform\n12          riigi        82    3       2    reform\n13            aeg       119    1       1      rohe\n14          eesti        75    2       2      rohe\n15        soovime        24    3       2      rohe\n16          eesti       193    1       2       sde\n17        toetame       128    2       2       sde\n18          riigi        79    3       2       sde\n\n\nSõnade sagedusi kujutatakse sageli sõnapilvena (word cloud). Sõnapilve suuruse saame määrata nt argumentidega min_count või max_words.\n\ntextplot_wordcloud(dokMat, min_size = 1, max_words = 100)\n\n\n\n\nKa sõnapilvel saame esitada sagedused mingi tunnuse kuni kaheksa rühma võrdluses. Kui sama sõna esineb enam kui kahes rühmas, siis määratakse selle värv rühma järgi, milles see sõna kõige sagedasem on.\n\ndokMatErak &lt;- dfm_group(dokMat, groups = korpus$erakond)\ntextplot_wordcloud(dokMatErak, min_size = 1, max_words = 50, comparison = TRUE)\n\n\n\n\nSaame valitud sõnade esinemist kujutada ka asukoha järgi tekstis, uurides sõnade konteksti (keyword in context, kwic). Kontekst on antud juhul dokumendid.\n\ntextplot_xray(kwic(sõned, pattern = \"Eesti\"))"
  },
  {
    "objectID": "tekstikaeve.html#sõnasus",
    "href": "tekstikaeve.html#sõnasus",
    "title": "30  Tekstikaeve",
    "section": "30.5 Sõnasus",
    "text": "30.5 Sõnasus\nKonkreetseid dokumente saame temaatiliselt iseloomustada selle alusel, kuidas need erinevad sõnade esinemise poolest teistest dokumentidest. Seda erinemist võib nimetada sõnasuseks (keyness). Sõnasuse arvutamisel leitakse valitud mõõdiku alusel, millised sõnad esinevad valitud dokumendis sagedamini ja harvemini kui teistes dokumentides. Mõõdiku saame määrata argumendiga measure ja dokumendi määrada argumendi target abil. Tulemuse võime kuvada tulpjoonisel, määrates esitatavate sõnade arvu (n).\n\nsõnasus &lt;-  textstat_keyness(dokMat, target = 'rohe 2007', measure = 'chi2')\ntextplot_keyness(sõnasus, n = 10)"
  },
  {
    "objectID": "tekstikaeve.html#tf-idf",
    "href": "tekstikaeve.html#tf-idf",
    "title": "30  Tekstikaeve",
    "section": "30.6 TF-IDF",
    "text": "30.6 TF-IDF\nLisaks sõnasusele hinnatakse sagli dokumendis esineva sõna tähtsust igas dokumendis. Seda esindavat mõõdikut nimetatakse lühendiga tf-idf (term frequency - inverse document frequency). See arvutatakse ühe termini \\(t\\) suhtelise sageduse ja dokumendi pöördsageduse korrutis.\n\\[\\text{tf-idf} (t) = \\text{tf} (t) \\times \\text{idf} (t),\\]\nkus suhteline sõnade sagedus (term frequency) on sõna osakaal kõikidest sõnadest dokumendis:\n\\[\\text{tf} (t) = \\frac{\\text{termini t sagedus dokumendis}}{\\text{kõikide sõnade arv dokumendis}}\\]\nja dokumendi pöördsagedus (inverse document frequency) on sõna tähtsus terves korpuses:\n\\[\\text{idf} (t) = ln \\frac{\\text{dokumentide arv}}{\\text{terminit t sisaldavate dokumentide arv}}.\\]\nMõõdiku väärtus on seda kõrgem, mida sagedamini esineb termin dokumendis, aga mida harvemini teistes dokumentides. Mõni tavaline sõna võib olla küll dokumendis sage, aga kui see on sage ka teistes dokumentides, siis ei iseloomusta see sõna hästi just vaatlusalust dokumenti. Selleks on vajalik, et see sõna teistes dokumentides sage ei oleks. Niisiis näitab tf-idf sõna tähtsust dokumendi kontekstis, arvestades sealjuures ka sõna üldist tähtsust.\n\ntfidf &lt;- dfm_tfidf(dokMat)\ntfidf\n\nDocument-feature matrix of: 12 documents, 18,510 features (84.92% sparse) and 2 docvars.\n                features\ndocs                 terve      pere  mõistus eesti  isamaa     res publica\n  irl 2007       3.7453313 0.5542687 3.237544     0 1.20412 1.20412 1.20412\n  irl 2011       0.2340832 0.1583625 0            0 4.21442 4.21442 4.21442\n  kesk 2007      0.2340832 0.2375437 0            0 0       0       0      \n  kesk 2011      0.2340832 0.1583625 0            0 0.60206 0.60206 0.60206\n  rahvaliit 2007 0         0         0            0 0       0       0      \n  rahvaliit 2011 0         0.1583625 0            0 0       0       0      \n                features\ndocs                liidu valitsemisprogramm 2007–2011\n  irl 2007       1.140634          0.7781513 0.7781513\n  irl 2011       1.520845          0.7781513 0        \n  kesk 2007      0                 0         0        \n  kesk 2011      1.140634          0         0        \n  rahvaliit 2007 0                 0         0        \n  rahvaliit 2011 0                 0         0        \n[ reached max_ndoc ... 6 more documents, reached max_nfeat ... 18,500 more features ]"
  },
  {
    "objectID": "tekstikaeve.html#sõnade-võrgustik",
    "href": "tekstikaeve.html#sõnade-võrgustik",
    "title": "30  Tekstikaeve",
    "section": "30.7 Sõnade võrgustik",
    "text": "30.7 Sõnade võrgustik\nSeosed sõnade vahel tulevad kõige ilmekamalt esile võrgustikjoonisel. Et kuvatud sõnade arv ei oleks liiga suur ja joonis seega liiga kirju, peaksime esmalt tegema sõnade seast valiku. Kohane on valida nt kõige sagedasemad sõnad. Seda saame teha taaskord funktsiooniga topfeatures(), mille tulemuseks saadud sageduste nimetused saame valida terminite maatriksist funktsiooniga fcm_select().\n\nsagedased &lt;- fcm_select(termMat, names(topfeatures(dokMat, 20)))\n\nSeejärel saame vähendatud terminite maatriksis esinevad seosed kujutada võrgustikuna funktsiooni textplot_network() abil. Nii joonistatud võrgustikul on näitavad jooned sõnade vahel nende koos esinemisi vastavalt sellele, kuidas see on määratud terminite maatriksis.\n\ntextplot_network(sagedased, min_freq = .5, edge_alpha = 0.2, edge_size = 2)"
  },
  {
    "objectID": "tekstikaeve.html#klasterdamine",
    "href": "tekstikaeve.html#klasterdamine",
    "title": "30  Tekstikaeve",
    "section": "30.8 Klasterdamine",
    "text": "30.8 Klasterdamine\nMõnikord võib olla vajalik dokumentide rühmitamine. Selleks saame kasuada hierarhilist klasterdamist. Dokumentide vahelised paariviisilised kaugused saame arvutada nt sõnade sageduste alusel, millisel juhul on samu sõnu sama sagedasti kasutavad dokumendid on üksteisele lähedal. Dokumendi termine maatriksi alusel saame dokumentide läheduse leida funktsiooniga textstat_dist(). Leitud kauguste alusel saame arvutada ja joonistada klastripuu nii nagu iga teise kauguste maatriksi alusel.\n\nkaugused &lt;- textstat_dist(dokMat) %&gt;% as.dist\npuu &lt;- hclust(kaugused, method = 'ward.D2') %&gt;% as.dendrogram\nplot(puu, type = 'triangle')"
  },
  {
    "objectID": "tekstikaeve.html#keelekasutus",
    "href": "tekstikaeve.html#keelekasutus",
    "title": "30  Tekstikaeve",
    "section": "30.9 Keelekasutus",
    "text": "30.9 Keelekasutus\nKeelekasutust dokumentides saab mõõta mitmest küljest. Dokumendi loetavust saame hinnata tähemärkide, kõikide sõnade, keeruliste sõnade, silpide ja lausete arvu ja pikkuse ning nende omavaheliste suhete alusel. Võimalusi nende tegurite kombineerimiseks on väga palju, aga eestikeelsete tekstide korral on sobilik kasutada mõõdikuid, mis ei võta aluseks sõnade tähendusi ega silpide arvu. Võime võrrelda tekste näiteks keskmise lause pikkuse alusel sõnades.\n\nloetavus &lt;- textstat_readability(korpus, measure = 'meanSentenceLength')\nloetavus\n\n         document meanSentenceLength\n1        irl 2007           8.764631\n2        irl 2011           9.463370\n3       kesk 2007          10.136842\n4       kesk 2011           7.884146\n5  rahvaliit 2007          17.382353\n6  rahvaliit 2011          14.731707\n7     reform 2007          23.042945\n8     reform 2011          11.973636\n9       rohe 2007          27.459184\n10      rohe 2011          11.646532\n11       sde 2007          12.226608\n12       sde 2011          25.066282\n\n\nKeelelise mitmekesisuse mõõtmiseks on samuti suur valik mõõdikuid, millest paljud lähtuvad ühel või teisel viisil kõikide sõnade ja kordumatute sõnade suhtest. Neist võib-olla kõige lihtsam TTR (type-token ratio) on lihtsalt kordumatute sõnade ja kõikide sõnade arvu suhe.\n\nmitmekesisus &lt;- textstat_lexdiv(dokMat, measure = 'TTR')\nmitmekesisus\n\n         document       TTR\n1        irl 2007 0.6447853\n2        irl 2011 0.6627430\n3       kesk 2007 0.6637656\n4       kesk 2011 0.6575607\n5  rahvaliit 2007 0.7205993\n6  rahvaliit 2011 0.7211155\n7     reform 2007 0.6008327\n8     reform 2011 0.5465092\n9       rohe 2007 0.7638743\n10      rohe 2011 0.7116410\n11       sde 2007 0.6466465\n12       sde 2011 0.6174171\n\n\nSaadud mõõdiku väärtuste alusel saame teha kokkuvõtteid ka dokumentidega seotud tunnuste lõikes. Nt võime leida iga erakonna programmide keskmise keelelise mitmekesisuse.\n\naggregate(mitmekesisus$TTR, list(korpus$erakond), mean)\n\n    Group.1         x\n1       irl 0.6537641\n2      kesk 0.6606631\n3 rahvaliit 0.7208574\n4    reform 0.5736710\n5      rohe 0.7377576\n6       sde 0.6320318\n\n\nLisaks keerukusele on levinud ka meelestatuse (sentiment) analüüs. Selle käigus määratakse igale sõnale, kas see väljendab negatiivset või positiivset emotsiooni. Selle määratluse alusel saame hinnata iga dokumendile meelestatuse. See protseduur on arusaadaval põhjusel väga levinud nt sotsiaalmeedia sõnumite uurimisel. Paraku ei ole eesti keele korpuse kohta veel olemas sõnastikku, milles oleks määratud iga sõna meelsus. Seetõttu antud dokumentides me meelestatust uurida ei saa."
  },
  {
    "objectID": "tekstikaeve.html#teemad",
    "href": "tekstikaeve.html#teemad",
    "title": "30  Tekstikaeve",
    "section": "30.10 Teemad",
    "text": "30.10 Teemad\nKeerulisemad tekstikaeve protseduurid võimaldavad luua teemade mudeleid (topic models). Üks selline protseduur on LDA (Latent Dirichlet Allocation). See võimaldab dokumendi-termini maatriksist leida ette antud arvul teemadega seotud märksõnad ja määrata igale dokumendile kõige sobivama teema, mida need märksõnad esindavad. Teemade paremaks eristamiseks on mõistlik kasutada TF-IDF maatriksit.\n\nlibrary('seededlda')\nteemad &lt;- textmodel_lda(tfidf, k = 6)\nterms(teemad)\n\n      topic1               topic2            topic3                      \n [1,] \"rahvaliit\"          \"reformierakond\"  \"sde\"                       \n [2,] \"programmiettepanek\" \"aeg\"             \"sotsidest\"                 \n [3,] \"üldkoosolekule\"     \"reformierakonna\" \"visioon\"                   \n [4,] \"saavutasime\"        \"eli\"             \"sotsiaaldemokraadid\"       \n [5,] \"2003-2007\"          \"jätkab\"          \"aasta_riigikogu_valimistel\"\n [6,] \"suurendarne\"        \"viib\"            \"sotsiaaldemokraatide\"      \n [7,] \"rahvaliidu\"         \"kavandab\"        \"tänane\"                    \n [8,] \"soovime\"            \"muudab\"          \"maavolikogu\"               \n [9,] \"kroonini\"           \"toetab\"          \"ca\"                        \n[10,] \"tõstsime\"           \"arendab\"         \"olukord\"                   \n      topic4               topic5              topic6        \n [1,] \"terve\"              \"reformierakond\"    \"irl\"         \n [2,] \"soovib\"             \"reformierakonna\"   \"irli\"        \n [3,] \"jätkame\"            \"eelarvevõimaluste\" \"2011–2015\"   \n [4,] \"ca\"                 \"tekkel\"            \"keskerakond\" \n [5,] \"tegevuskava\"        \"muuhulgas\"         \"õnne\"        \n [6,] \"seisame\"            \"struktuurseid\"     \"eli\"         \n [7,] \"töötajate\"          \"lähtuvad\"          \"üksuste\"     \n [8,] \"omavalitsusüksuste\" \"põhimõtetest\"      \"koduomanike\" \n [9,] \"rakendab\"           \"omandi\"            \"keskerakonna\"\n[10,] \"taastame\"           \"odavaima\"          \"isamaa\"      \n\ntopics(teemad)\n\n      irl 2007       irl 2011      kesk 2007      kesk 2011 rahvaliit 2007 \n        topic4         topic4         topic4         topic4         topic4 \nrahvaliit 2011    reform 2007    reform 2011      rohe 2007      rohe 2011 \n        topic4         topic4         topic5         topic1         topic4 \n      sde 2007       sde 2011 \n        topic4         topic4 \nLevels: topic1 topic2 topic3 topic4 topic5 topic6"
  },
  {
    "objectID": "maakaardid.html",
    "href": "maakaardid.html",
    "title": "31  Maakaardid",
    "section": "",
    "text": "32 Ruumiline autokorrelatsioon\nKujundite korral saame uurida ruumilist autokorrelatsiooni naabrite vahel. Selleks on esmalt vaja leida iga kujundi naabrid.\nlibrary('spdep')\n\nLoading required package: spData\n\n\nTo access larger datasets in this package, install the spDataLarge\npackage with: `install.packages('spDataLarge',\nrepos='https://nowosad.github.io/drat/', type='source')`\n\nnaabrid &lt;- poly2nb(ov)\nplot(st_geometry(ov))\nplot(naabrid, ov %&gt;% st_centroid %&gt;% st_coordinates, add = TRUE, col = 'red')\n\nWarning: st_centroid assumes attributes are constant over geometries\nKõige sagedasem ruumilise autokorrelatsiooni mõõdik on Morani I (Moran’s I), mille saame arvutada ka nö kohalikult, iga kujundi kohta eraldi. Arvutame, mil määral on omavalitsuste rahvaarv sarnane naaberomvalitsuste omaga.\nkaalud &lt;- nb2listw(naabrid, style = 'W', zero.policy = TRUE)\nmorani &lt;- localmoran(ov$rahvaarv, listw = kaalud, zero.policy = TRUE)\nov$morani &lt;- morani[, 'Ii']\ntm_shape(ov) + tm_polygons(col = 'morani')\n\nVariable(s) \"morani\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\nNäeme, et kui Tallinnal on võrreldes naaberomavalitsustega sarnane rahvaarv, siis Tartul erinev.\nLisaks saame võrrelda rahvaarvu omavalitsustes ka selle mediaanväärtusega.\nov$mediaanid &lt;- attributes(morani)$quadr$median\ntm_shape(ov) + tm_polygons(col = 'mediaanid', palette = 'div')\nAntud juhul näitab legendis esimene väärtus omavalitsuse enda rahvaarvu võrreldes mediaaniga ja teine väärtus naaberomavalitsuste rahvaarvu võrreldes mediaaniga. Nt väärtus High-Low näitab, et antud omavalitsuses on küll mediaanist kõrgem rahvaarv, aga selle naabrite rahvaarv on mediaanist madalam."
  },
  {
    "objectID": "maakaardid.html#raster",
    "href": "maakaardid.html#raster",
    "title": "31  Maakaardid",
    "section": "31.1 Raster",
    "text": "31.1 Raster\nJärgnevalt uurime rahvaarvu ruutkilomeetril ehk rahvastiku tihendust Eestis. Sellised andmed on sageli vormistatud andmetabelina, kus iga ruutkilomeeter on andmetabelis eraldi real. Kaardiruudud paiknevad sealjuures järjesttikku.\n\nlibrary('magrittr')\nrahvaarv &lt;- read.csv('andmed/rahvaarvraster.csv')\nhead(rahvaarv)\n\n        x       y arv06 arv11 arv18\n1 5032000 3925000     0     0     0\n2 5031000 3926000     0     0     0\n3 5032000 3926000     0     0     0\n4 5102000 3926000     0     0     0\n5 5103000 3926000     0     0     0\n6 5104000 3926000     0     0     2\n\n\nAndmetabelina esitatud rasterkaardi alusel on tunnuseid kasutades arvutuste tegemine lihtne. Vaatlusaluste andmete korral saame arvutada nt rahvaarvu muutuse aastate 2006 ja 2018 võrdluses iga ruutkilomeetri kohta. Samuti saame ruutude põhjal rahvastiku tihedust kirjeldada.\n\nrahvaarv$muutus &lt;- rahvaarv$arv18 - rahvaarv$arv06\nsummary(rahvaarv)\n\n       x                 y               arv06              arv11         \n Min.   :5007000   Min.   :3925000   Min.   :    0.00   Min.   :    0.00  \n 1st Qu.:5150000   1st Qu.:4002000   1st Qu.:    0.00   1st Qu.:    0.00  \n Median :5217000   Median :4044000   Median :    0.00   Median :    0.00  \n Mean   :5208866   Mean   :4048577   Mean   :   29.27   Mean   :   28.43  \n 3rd Qu.:5278000   3rd Qu.:4094000   3rd Qu.:    6.00   3rd Qu.:    6.00  \n Max.   :5367000   Max.   :4185000   Max.   :18404.00   Max.   :17375.00  \n     arv18              muutus         \n Min.   :    0.00   Min.   :-4612.000  \n 1st Qu.:    0.00   1st Qu.:    0.000  \n Median :    2.00   Median :    0.000  \n Mean   :   29.38   Mean   :    0.114  \n 3rd Qu.:    6.00   3rd Qu.:    2.000  \n Max.   :16861.00   Max.   : 5749.000  \n\n\nNäeme, et kõige suurema tihedusega ruutkilomeetril elas Eestis 2018. aastal peaaegu 17 tuhat inimest. Aastate 2006 ja 2018 võrdluses kasvas neljandikus ruutudest rahvaarv vähemalt 2 inimese võrra.\nRuudustikku esndavat andmetabelit saame joonistada kasutades ggplot käsku koos funktsiooniga geom_raster().\n\nlibrary('ggplot2')\nggplot(rahvaarv) + aes(x = x, y = y, fill = arv18) + \n  coord_fixed() + \n  geom_raster() + \n  labs(fill = \"Rahvaarv\") + \n  scale_fill_distiller(trans = 'log', labels = round, \n                       palette = 'Spectral', na.value = 'gray95') + \n  theme_void()\n\nWarning: Transformation introduced infinite values in discrete y-axis\n\n\nWarning: Raster pixels are placed at uneven horizontal intervals and will be shifted\nℹ Consider using `geom_tile()` instead.\n\n\n\n\n\nMõnikord on maakaardid salvestatud pildina, nt .tif faililaiendiga. Sellised kaardid saame R keskkonda sisestada funktsiooniga raster ja seejärel kuvada tm_shape() käsuga.\n\nlibrary('raster')\narv18 &lt;- raster('andmed/rahvaarvraster18.tif')\nlibrary('tmap')\ntm_shape(arv18) + tm_raster(style = 'quantile')\n\n\n\n\nTeine võimalus on teisendada rasterkaardid andmetabeliks, mis võimaldab teha arvutusi ja kasutada joonistamiseks funktsiooni gglot2() nii nagu eelnevalt näidatud.\n\narv18 %&lt;&gt;% rasterToPoints %&gt;% as.data.frame\nhead(arv18)\n\n        x       y rahvaarvraster18\n1 5231000 4185000                0\n2 5243000 4172000                0\n3 5243000 4171000                0\n4 5245000 4170000                0\n5 5332000 4170000                0\n6 5333000 4170000              202\n\n\nKuna rasterkaardid on sisuliselt pildid, siis enamasti on ühel rasterkaardil ainult üks kiht (raster band). Seetõttu saame rasterkaardil korraga esitada ainult ühe tunnuse väärtused, milleks antud juhul on rahvaarv aastal 2018."
  },
  {
    "objectID": "maakaardid.html#punktid",
    "href": "maakaardid.html#punktid",
    "title": "31  Maakaardid",
    "section": "31.2 Punktid",
    "text": "31.2 Punktid\nPunktide kujutamise näitena uurime süütegusid Eestis. Käsitleme ainult vandalismijuhtumeid.\n\nteod &lt;- read.csv('andmed/süüteod.csv')\nteod &lt;- teod[grep('vandalism', teod$sündmus), ]\nteod$aasta &lt;- format(as.Date(teod$kuupäev), '%Y') %&gt;% as.numeric\nteod$nädalapäev &lt;- strftime(teod$kuupäev, '%A')\nteod$kahjusumma %&lt;&gt;% as.factor\nstr(teod)\n\n'data.frame':   7969 obs. of  8 variables:\n $ lon       : num  536750 622250 540250 550250 542750 ...\n $ lat       : num  6581250 6405750 6584250 6589250 6588750 ...\n $ kuupäev   : chr  \"2022-11-19\" \"2022-11-19\" \"2022-11-18\" \"2022-11-14\" ...\n $ nädalapäev: chr  \"Saturday\" \"Saturday\" \"Friday\" \"Monday\" ...\n $ sündmus   : chr  \"vandalism\" \"vandalism\" \"vandalism\" \"vandalism\" ...\n $ koht      : chr  \"avalik_koht,tanav_valjak\" \"avalik_koht\" \"avalik_koht,tanav_valjak\" \"avalik_koht,uhissoiduk\" ...\n $ kahjusumma: Factor w/ 4 levels \"0-499\",\"500-4999\",..: NA 1 1 1 NA 1 1 1 1 2 ...\n $ aasta     : num  2022 2022 2022 2022 2022 ...\n\n\nNäeme, et andmetabeli esimestes veergudes on koordinaadid. Saame kujutada vaatlused nende koordinaatide alusel hajuvusjoonisel, mille tulemuseks ongi maakaart süütegude asukohtadega.\n\nplot(teod[, 1:2])\n\n\n\n\nKoordinaatidega andmetabeli saame teisendada nö ruumiliseks andmetabeliks, määrates koordinaate sisaldavad veerud ja koordinaatsüsteemi.\n\nlibrary('sf')\n\nLinking to GEOS 3.12.0, GDAL 3.7.1, PROJ 9.2.1; sf_use_s2() is TRUE\n\nteodSf &lt;- st_as_sf(teod, coords = c('lon', 'lat'), crs = st_crs(3301))\nteodSf\n\nSimple feature collection with 7969 features and 6 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 396499.5 ymin: 6387500 xmax: 738749.5 ymax: 6613500\nProjected CRS: Estonian Coordinate System of 1997\nFirst 10 features:\n       kuupäev nädalapäev                           sündmus\n21  2022-11-19   Saturday                         vandalism\n25  2022-11-19   Saturday                         vandalism\n36  2022-11-18     Friday                         vandalism\n63  2022-11-14     Monday                         vandalism\n71  2022-11-13     Sunday                         vandalism\n112 2022-11-10   Thursday vandalism,avaliku_korra_rikkumine\n113 2022-11-10   Thursday vandalism,avaliku_korra_rikkumine\n114 2022-11-10   Thursday                         vandalism\n121 2022-11-09  Wednesday                         vandalism\n128 2022-11-08    Tuesday                         vandalism\n                        koht kahjusumma aasta                 geometry\n21  avalik_koht,tanav_valjak       &lt;NA&gt;  2022 POINT (536749.5 6581250)\n25               avalik_koht      0-499  2022 POINT (622249.5 6405750)\n36  avalik_koht,tanav_valjak      0-499  2022 POINT (540249.5 6584250)\n63    avalik_koht,uhissoiduk      0-499  2022 POINT (550249.5 6589250)\n71       avalik_koht,kauplus       &lt;NA&gt;  2022 POINT (542749.5 6588750)\n112 avalik_koht,tanav_valjak      0-499  2022 POINT (546749.5 6591750)\n113 avalik_koht,tanav_valjak      0-499  2022 POINT (546749.5 6591750)\n114 avalik_koht,tanav_valjak      0-499  2022 POINT (541749.5 6589250)\n121 avalik_koht,tanav_valjak      0-499  2022 POINT (597499.5 6606500)\n128  avalik_koht,bussipeatus   500-4999  2022 POINT (550249.5 6590250)\n\n\nSelliste objektide joonistamiseks saame kasutada ggplot() käsku funktsiooniga geom_sf().\n\nlibrary('ggplot2')\nggplot(teodSf) + \n  geom_sf(aes(color = kahjusumma), alpha = .2) + \n  facet_wrap(~aasta) + \n  theme_void()\n\n\n\n\nTeine võimalus on kasutada käsku tm_shape() ja sellega seotud funktsioone.\n\nlibrary('tmap')\ntm_shape(teodSf) + \n  tm_dots(col = 'kahjusumma', size = .5, alpha = .2) + \n  tm_facets(by = 'aasta')"
  },
  {
    "objectID": "maakaardid.html#punktide-analüüs",
    "href": "maakaardid.html#punktide-analüüs",
    "title": "31  Maakaardid",
    "section": "31.3 Punktide analüüs",
    "text": "31.3 Punktide analüüs\nPunktide paiknemise alusel saame teha ka mitmesuguseid arvutusi. Selleks saame kasutada funktsioone laiendusest spatstat. Esmalt peame esmalt määrama kujundi, mille sees punktid teoreetiliselt olla võivad. See on nn aken. Sisestame Shapefile vormingus Eesti omavalitsuste piiride andmed, ühendame omavaitsused ja lihtsustame kaarti. Seejärel saame teisendada andmetabeli punktmustri (point pattern) objektiks, mida saab kasutada arvutustes.\n\nlibrary('sf')\nov &lt;- st_read('andmed/omavalitsus')\n\nReading layer `omavalitsus_20221101' from data source \n  `/home/jrl/projects/andmeanalyys/andmed/omavalitsus' using driver `ESRI Shapefile'\nSimple feature collection with 79 features and 5 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 369032.1 ymin: 6377141 xmax: 739152.8 ymax: 6634019\nProjected CRS: Estonian Coordinate System of 1997\n\naken &lt;- st_union(ov, is.coverage = TRUE)\nlibrary('spatstat')\naken %&lt;&gt;% as.ppp\nteodPt &lt;- as.ppp(teod, W = aken)\nplot(teodPt, main = NULL, use.marks = FALSE, pch = 20)\n\n\n\n\nKuna paljud punktid kattuvad, siis lihtsalt nende kuvamine ei anna tegelikku arusaama sellest, kui palju punkte mingil alal asub. Selle näitamiseks saame jagada kaardi mingite vahedega ruutudeks ja loendada punktide arvud nendel ruutudel (siinkohal pigem ristkülikutel).\n\nruudud &lt;- quadratcount(teodPt, 5, 5)\nplot(ruudud)\nplot(teodPt, add = TRUE)\n\nPlotting the first column of marks\n\n\nWarning in default.charmap(ntypes, chars): Too many types to display every type\nas a different character\n\n\nPlotting the first column of marks\n\n\nWarning in default.charmap(ntypes, chars): Too many types to display every type\nas a different character\n\n\nWarning in plot.ppp(teodPt, add = TRUE): 114 illegal points also plotted\n\n\n\n\n\nNäeme, et ülekaalukalt kõige enam juhtumeid toimus kaardiruudus, kus asus Tallinn.\nTeine viis punktide paiknemist ilmekamalt näidata on arvutada ja kuvada punktide tihedus ruumis.\n\ntihedus &lt;- density(teodPt)\nplot(tihedus, main = NULL, box = FALSE, ribbon = FALSE)\n\n\n\npersp(tihedus, main = NULL, box = FALSE, axes = FALSE, theta = -25, phi = 45)\n\n\n\n\nMitmesuguseid arvutusi punktide jaotumise kohta saame teha iga punkti lähima naabri kauguse alusel.\n\nlähinaaber &lt;- nndist(teodPt)\nsummary(lähinaaber)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n    0.0     0.0     0.0   152.6     0.0 23021.7 \n\n\nNäeme, et keskmiselt on vandalismijuhtumid toimunud 151 meetri kaugusel lähimast teisest sellisest juhtumist. Lähimast juhtumist kõige suurem kaugus oli 23 km.\nLähima naabri kaugust saame uurida ka andmetabelis olevate tunnuste lõikes.\n\naggregate(lähinaaber, list(teodPt$marks$nädalapäev), mean)\n\n    Group.1         x\n1    Friday 173.83051\n2    Monday 145.67459\n3  Saturday 150.35675\n4    Sunday 202.68934\n5  Thursday 145.27492\n6   Tuesday  86.37345\n7 Wednesday 153.01107\n\n\nNäeme, et keskmselt kõige kaugemal lähimast juhtumist esines vandalism pühapäeviti."
  },
  {
    "objectID": "maakaardid.html#kujundid",
    "href": "maakaardid.html#kujundid",
    "title": "31  Maakaardid",
    "section": "31.4 Kujundid",
    "text": "31.4 Kujundid\nKujundite näitena uurime omavalitsuste piire Eestis1. Selleks laadime alla Shapefile vormingus andmed ja sisestame vastavas kaustas olevad failid R keskkonda.1 Eesti maakondade, omavalitsuste ja asustusüksuste piirid on kättesaadavad Maa-amet Geoportaalis.\n\nlibrary('sf')\nlist.files('andmed/omavalitsus')\n\n[1] \"omavalitsus_20221101.dbf\" \"omavalitsus_20221101.prj\"\n[3] \"omavalitsus_20221101.shp\" \"omavalitsus_20221101.shx\"\n\nov &lt;- st_read('andmed/omavalitsus')\n\nReading layer `omavalitsus_20221101' from data source \n  `/home/jrl/projects/andmeanalyys/andmed/omavalitsus' using driver `ESRI Shapefile'\nSimple feature collection with 79 features and 5 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 369032.1 ymin: 6377141 xmax: 739152.8 ymax: 6634019\nProjected CRS: Estonian Coordinate System of 1997\n\nov\n\nSimple feature collection with 79 features and 5 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 369032.1 ymin: 6377141 xmax: 739152.8 ymax: 6634019\nProjected CRS: Estonian Coordinate System of 1997\nFirst 10 features:\n           ONIMI OKOOD            MNIMI MKOOD TYYP\n1     Ruhnu vald  0689    Saare maakond  0074    1\n2      Muhu vald  0478    Saare maakond  0074    1\n3    Viimsi vald  0890    Harju maakond  0037    1\n4  Saaremaa vald  0714    Saare maakond  0074    1\n5   Hiiumaa vald  0205     Hiiu maakond  0039    1\n6     Kihnu vald  0303    Pärnu maakond  0068    1\n7    Vormsi vald  0907    Lääne maakond  0056    1\n8  Viljandi linn  0897 Viljandi maakond  0084    4\n9        Tallinn  0784    Harju maakond  0037    4\n10    Jõhvi vald  0251 Ida-Viru maakond  0045    1\n                         geometry\n1  MULTIPOLYGON (((455182.4 64...\n2  MULTIPOLYGON (((463065.2 64...\n3  MULTIPOLYGON (((555043.2 66...\n4  MULTIPOLYGON (((457728.1 64...\n5  MULTIPOLYGON (((441870.5 65...\n6  MULTIPOLYGON (((499129.7 64...\n7  MULTIPOLYGON (((458323.2 65...\n8  MULTIPOLYGON (((591276.3 64...\n9  MULTIPOLYGON (((546579.5 65...\n10 MULTIPOLYGON (((686165.8 65...\n\n\nNäeme, et tulemuseks on andmetabel, mille iga rida esindab ühte omavalitsust. Igale real asuval kujundil on piire tähistavad punktid, millele annab tähenduse koordinaatsüsteem.\nKui soovime kujutada ainult kujundite piirie, siis võime andmetabelist eraldada geomeetria ja joonistada ainult selle.\n\nplot(st_geometry(ov))\n\n\n\n\nMida keerulisemad on kujundid, seda kauem võtab aega nende joonistamine. Väiksemõõtmeliste jooniste korral ei ole kujundite suur täpsus tähtis, mistõttu võime neid lihtsustada. Selleks saame kasutada funktsiooni st_simplify, mille argumendi dTolerance erinevaid väärtusi proovides saame kujundeid lihtsustada nii, et need liiga lihtsaks ei muutuks.\n\nst_simplify(ov, dTolerance = 5000) %&gt;% st_geometry %&gt;% plot\n\n\n\nov &lt;- st_simplify(ov, dTolerance = 500)\n\nEt kujutada mingit nähtust omavalitsuse piirides, saame lisada vastava tunnuse andmetabelisse. Selle näiteks sisestame rahvaarvu Statistikaameti tabelist RLV701.\n\nrahvaarv &lt;- read.csv('andmed/rahvaarv.csv')\ntail(rahvaarv)\n\n                                           koht rahvaarv\n180                 Antsla linn asustusüksusena     1249\n181 Antsla vald, va Antsla linn asustusüksusena     2973\n182                                  Rõuge vald     4877\n183                                Setomaa vald     2849\n184                                   Võru linn    11865\n185                                   Võru vald    10367\n\n\nAndmetabelite ühendamiseks saame kasutada funktsiooni merge(). Kui ühendamise aluseks olevate tunnuste nimed tabelites erinevad, siis peame vastavad nimetused määratlema.\n\nov &lt;- merge(ov, rahvaarv, by.x = 'ONIMI', by.y = 'koht', all.x = TRUE)\nov\n\nSimple feature collection with 79 features and 6 fields\nGeometry type: GEOMETRY\nDimension:     XY\nBounding box:  xmin: 369556.3 ymin: 6377146 xmax: 738987.7 ymax: 6616089\nProjected CRS: Estonian Coordinate System of 1997\nFirst 10 features:\n              ONIMI OKOOD              MNIMI MKOOD TYYP rahvaarv\n1    Alutaguse vald  0130   Ida-Viru maakond  0045    1     4167\n2        Anija vald  0141      Harju maakond  0037    1     6262\n3       Antsla vald  0142       Võru maakond  0087    1     4222\n4         Elva vald  0171      Tartu maakond  0079    1    14707\n5  Häädemeeste vald  0214      Pärnu maakond  0068    1     4616\n6     Haapsalu linn  0184      Lääne maakond  0056    4    13132\n7      Haljala vald  0191 Lääne-Viru maakond  0060    1     4090\n8        Harku vald  0198      Harju maakond  0037    1    16380\n9      Hiiumaa vald  0205       Hiiu maakond  0039    1     8497\n10       Järva vald  0255      Järva maakond  0052    1     8632\n                         geometry\n1  MULTIPOLYGON (((716763.6 65...\n2  POLYGON ((566437.1 6578876,...\n3  POLYGON ((640691.4 6417407,...\n4  POLYGON ((624749.4 6473469,...\n5  POLYGON ((520984.7 6414970,...\n6  MULTIPOLYGON (((464366.3 65...\n7  POLYGON ((603455.3 6604360,...\n8  MULTIPOLYGON (((532139.7 65...\n9  MULTIPOLYGON (((451826.4 65...\n10 POLYGON ((582706 6553611, 5...\n\n\nKujunditega saame paljusid funktsioone rakendades teha kõikvõimalikke tehteid. Saame arvutada näiteks omavalitsuste pindalad ruutkilomeetrites ja selle alusel inimeste arvu ruutkilomeetril. Kuna vaikimisi on antud koordinaatsüsteem meetrites, siis peame ruutmeetrid teisednama ruutkilomeetriteks.\n\nov$pindala &lt;- as.vector(st_area(ov)) / 1e6\nov$tihedus &lt;- ov$rahvaarv / ov$pindala\n\nLisatud tunnust saame kujutada tm_shape käsu abil.\n\nlibrary('tmap')\ntm_shape(ov) + tm_polygons(col = 'tihedus', style = 'quantile')\n\n\n\n\nSaame korraga kujutada ka erineval kujul andmeid. Selleks peavad kahe andmetabeli koordinaatsüsteemid on olema samad. Seejärel saame lisada objektid mõlemast andmetabelist korraga tm_shape käsu järele.\n\ntm_shape(ov) + tm_polygons(col = 'tihedus', style = 'quantile') + \n  tm_shape(teodSf) + tm_dots(alpha = .5)"
  },
  {
    "objectID": "maakaardid.html#liikuvad-kaardid",
    "href": "maakaardid.html#liikuvad-kaardid",
    "title": "31  Maakaardid",
    "section": "32.1 Liikuvad kaardid",
    "text": "32.1 Liikuvad kaardid\nÜsna hõlpsasti saame koostada ka liikuvaid kaarte, millelt saame lugeda iga objekti kohta olevat teavet. Kasutades selleks laiendust tmap, peame esmalt käsuga tmap_mode('view') teada andma, et soovime liikuvat kaarti. Seejärel kuvatakse kõik tm_shape käsuga joonistatud kaardid liikuvatena, kuni määrame käsuga tmap_mode('plot'), et soovime jälle kuvada kaarte piltidena. Liikuvatel kaartidel saab kuvada mh objekte, mis on sisestatud funktsiooniga st_read() või teisendatud funktsiooniga st_as_sf().\nKuna süütegude asukohad on teada tegelikult ruutkilomeetriste kaardiruutude kaupa, siis liigutame koordinaate 1000 m võrra juhuslikus suunas (st_jitter), et samal kaardiruudul asuvad punktid ei kattuks.\n\ntmap_mode('view')\n\ntmap mode set to interactive viewing\n\nteodSf %&lt;&gt;% st_jitter(amount = 1000)\ntm_shape(teodSf) + tm_dots(alpha = .5)\n\n\n\n\n\n\nLiikuvad kaardid saame salvestada veebilehena HTML vormingus ja nii neid ka jagada."
  },
  {
    "objectID": "viited.html",
    "href": "viited.html",
    "title": "Viited",
    "section": "",
    "text": "Cairo, A. (2016). The truthful art: data, charts, and maps for\ncommunication. New Riders.\n\n\nÇetinkaya-Rundel, M., & Ellison, V. (2021). A Fresh Look at\nIntroductory Data Science. Journal of Statistics and Data Science\nEducation, 29(sup1), S16–S26. https://doi.org/10.1080/10691898.2020.1804497\n\n\nCrameri, F., Shephard, G. E., & Heron, P. J. (2020). The misuse of\ncolour in science communication. Nature Communications,\n11(1), 5444. https://doi.org/10.1038/s41467-020-19160-7\n\n\nKelleher, J. D., & Tierney, B. (2018). Data science. The\nMIT Press.\n\n\nKitchin, R., & McArdle, G. (2016). What makes Big Data, Big Data?\nExploring the ontological characteristics of 26 datasets. Big Data\n& Society, 3(1), 205395171663113. https://doi.org/10.1177/2053951716631130\n\n\nPeng, R., & Matsui, E. (2016). The Art of Data Science.\nLeanpub.\n\n\nPinheiro, C., Patetta, M., & Safari, an O. M. C. (2021).\nIntroduction to Statistical and Machine Learning Methods for Data\nScience. SAS Institute Inc.\n\n\nSaltz, J. S., & Stanton, J. M. (2017). An introduction to data\nscience. SAGE Publications, Inc.\n\n\nSauga, A. (2020). Statistika õpik majanduseriala üliõpilastele\n(2nd ed.). TTÜ kirjastus.\n\n\nSpiegelhalter, D. J. (2019). The art of statistics: learning from\ndata. Pelican Books.\n\n\nStevens, S. S. (1946). On the Theory of Scales of Measurement.\nScience, 103(2684), 677–680. https://doi.org/10.1126/science.103.2684.677\n\n\nTaddy, M. (2019). Business data science: combining machine learning\nand economics to optimize, automate, and accelerate business\ndecisions (First edition). McGraw-Hill Education.\n\n\nWickham, H. (2014). Tidy Data. Journal of Statistical Software,\n059(i10). https://ideas.repec.org/a/jss/jstsof/v059i10.html\n\n\nWild, C. (2006). The concept of distribution. Statistics Education\nResearch Journal, 5(2), 10–26.\n\n\nWu, J. (1997). Statistics = data science? http://www2.\nisye. gatech. edu/~ jeffwu/presentations/datascience.pdf"
  }
]